<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 指针 &amp; 引用</title>
      <link href="/posts/cpp/08.html"/>
      <url>/posts/cpp/08.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、指针</h1><h2 id="1-1-指针简介">1.1 指针简介</h2><ul><li><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（<code>&amp;</code>）运算符访问的地址，它表示了在内存中的一个地址。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  var1;</span><br><span class="line"><span class="comment">// var1 变量的地址： 00000001000FF614</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;var1 变量的地址：&quot;</span> &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p><strong>指针是一个变量</strong>，其值为另一个变量的地址，即内存位置的直接地址。</p></li><li><p>就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。</p></li></ul><h2 id="1-2-指针声明">1.2 指针声明</h2><ul><li><p>指针变量声明的一般形式为：<code>type *var-name;</code></p><ul><li><code>type</code> 是指针的基类型，它必须是一个有效的 <code>C++</code> 数据类型。</li><li>星号 <code>*</code> 用来指定一个变量是指针。</li><li><code>var-name</code> 是指针变量的名称。</li></ul></li><li><p>所有指针值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的 <strong>十六进制数</strong>。</p></li><li><p><strong>不同数据类型的指针之间唯一的不同是</strong>：<strong>指针所指向的变量或常量的数据类型不同</strong>。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ip;    <span class="comment">// 一个整型的指针</span></span><br><span class="line"><span class="type">char</span>* ch;   <span class="comment">// 一个字符型的指针</span></span><br><span class="line"><span class="type">float</span>* fp;  <span class="comment">// 一个单精度浮点型的指针</span></span><br><span class="line"><span class="type">double</span>* dp; <span class="comment">// 一个双精度浮点型的指针</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-指针使用">1.3 指针使用</h2><ul><li><p>使用指针时会频繁进行以下几个操作：</p><ul><li>定义一个指针变量；</li><li>把变量地址赋值给指针；</li><li>访问指针变量中可用地址的值。</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">// 实际变量的声明</span></span><br><span class="line">    <span class="type">int</span>  *ip;        <span class="comment">// 指针变量的声明</span></span><br><span class="line"></span><br><span class="line">    ip = &amp;var;       <span class="comment">// 在指针变量中存储变量 var 的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出实际变量的值</span></span><br><span class="line">    <span class="comment">// Value of var variable: 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出在指针变量中存储的地址</span></span><br><span class="line">    <span class="comment">// Address stored in ip variable: 0xb64fdff9d4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span> &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问指针中地址的值</span></span><br><span class="line">    <span class="comment">// Value of *ip variable: 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-4-指针详解">1.4 指针详解</h2><h3 id="1-4-1-null-指针">1.4.1 Null 指针</h3><ul><li><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 <code>NULL</code> 值是一个良好的编程习惯。</p></li><li><p>赋为 <code>NULL</code> 值的指针被称为 <strong>空指针</strong>。</p></li><li><p><code>NULL</code> 是一个定义在标准库中的值为零的常量。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">int</span>  *ptr = NULL;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;ptr 的值是 &quot;</span> &lt;&lt; ptr ;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在大多数的操作系统上，程序不允许访问地址为 <code>0</code> 的内存，因为该内存是操作系统保留的。然而，内存地址 <code>0</code> 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</li></ul></li><li><p>可以使用 <code>if</code> 语句检查一个指针是否为空指针。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>  *ptr = NULL;</span><br><span class="line">    <span class="keyword">if</span>(!ptr) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ptr 是空指针 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-2-指针的算术运算">1.4.2 指针的算术运算</h3><ul><li>指针是一个使用数值表示的地址。因此，可以对指针进行四种算术运算：<code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>。</li></ul><h4 id="1-递增一个指针">（1）递增一个指针</h4><ul><li><p>在 <code>C++</code> 中，指针是一个变量，它存储一个内存地址。递增一个指针意味着将指针指向下一个内存位置，这通常是指向下一个数组元素。</p></li><li><p><strong>递增一个指针会根据指针所指向的数据类型自动调整指针的值</strong>。</p></li><li><p>当使用指针操作时，要确保指针指向有效的内存区域，否则可能会导致未定义行为或程序崩溃。在操作数组时，尤其要小心避免指针超出数组的范围。</p></li><li><p>假设 <code>ptr</code> 是一个指向整数 <code>100</code> 的 <strong>整型指针</strong>，是一个 <code>32</code> 位的整数。执行 <code>ptr++</code> 后，指针 <code>ptr</code> 会向前移动 <code>4</code> 个字节，指向下一个整型元素的地址。这是由于指针算术运算会根据指针的类型和大小来决定移动的距离。在这种情况下，由于是一个 <code>32</code> 位整数指针，每个整数占据 <code>4</code> 个字节，因此 <code>ptr++</code> 会将指针 <code>ptr</code> 向前移动 <code>4</code> 个字节，指向下一个整型元素的地址。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span>  *ptr = &amp;a;</span><br><span class="line">    cout &lt;&lt; ptr &lt;&lt; endl;    <span class="comment">// 0xc686bffd64</span></span><br><span class="line">    cout &lt;&lt; ++ptr &lt;&lt; endl;  <span class="comment">// 0xc686bffd68</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>假设 <code>ptr</code> 指向一个地址为 <code>1000</code> 的字符，执行 <code>ptr++</code> 指针 <code>ptr</code> 的值会增加，指向下一个字符元素的地址，由于 <code>ptr</code> 是一个字符指针，每个字符占据 <code>1</code> 个字节，因此 <code>ptr++</code> 会将 <code>ptr</code> 的值增加 <code>1</code>，执行后 <code>ptr</code> 指向地址 <code>1001</code>。</p></li><li><p>如果指针指向一个 <code>int</code> 类型的数组元素，那么递增指针将使其指向下一个 <code>int</code> 元素。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指向数组第一个元素的指针</span></span><br><span class="line">    <span class="type">int</span> *ptr = arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针指向的元素</span></span><br><span class="line">    <span class="comment">// 指针当前指向的元素: 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;指针当前指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递增指针</span></span><br><span class="line">    ptr++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针指向的元素</span></span><br><span class="line">    <span class="comment">// 递增指针后指向的元素: 20</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;递增指针后指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-递减一个指针">（2）递减一个指针</h4><ul><li><p>在 <code>C++</code> 中，指针不仅可以递增，也可以递减。递减一个指针意味着将指针指向后一个内存位置。与递增指针类似，递减指针也会根据指针所指向的数据类型自动调整指针的值。</p></li><li><p>递减指针时，指针的值将减少一个偏移量，该偏移量等于指针所指向数据类型的大小。例如，如果指针是 <code>int*</code> 类型，每次递减指针将减少4个字节（假设 <code>int</code> 类型占 <code>4</code> 个字节）。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指向数组第二个元素的指针</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针当前指向的元素</span></span><br><span class="line">    <span class="comment">// 指针当前指向的元素: 20</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;指针当前指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减指针</span></span><br><span class="line">    ptr--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针递减后指向的元素</span></span><br><span class="line">    <span class="comment">// 递减指针后指向的元素: 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;递减指针后指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-指针的加法和减法">（3）指针的加法和减法</h4><ul><li><p><code>ptr + n</code> (或 <code>n + ptr</code>)：将指针 <code>ptr</code> 向前移动 <code>n</code> 个元素的大小。如果 <code>ptr</code> 指向 <code>int</code> 类型的数组，每个 <code>int</code> 占 <code>4</code> 个字节，那么 <code>ptr + 1</code> 将指向数组的下一个 <code>int</code> 元素。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指向数组第一个元素的指针</span></span><br><span class="line">    <span class="type">int</span> *ptr = arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针当前指向的元素</span></span><br><span class="line">    <span class="comment">// 指针当前指向的元素: 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;指针当前指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针 ptr 向前移动 2 个元素</span></span><br><span class="line">    ptr = ptr + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针递减后指向的元素</span></span><br><span class="line">    <span class="comment">// 向前移动 2 个元素后指向的元素: 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;向前移动 2 个元素后指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ptr - n</code>：将指针 <code>ptr</code> 向后移动 <code>n</code> 个元素的大小。如果 <code>ptr</code> 指向 <code>int</code> 类型的数组，那么 <code>ptr - 1</code> 将指向数组的前一个 <code>int</code> 元素。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指向数组第三个元素的指针</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针当前指向的元素</span></span><br><span class="line">    <span class="comment">// 指针当前指向的元素: 30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;指针当前指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针 ptr 向后移动 2 个元素</span></span><br><span class="line">    ptr = ptr - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针递减后指向的元素</span></span><br><span class="line">    <span class="comment">// 向后移动 2 个元素后指向的元素: 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;向后移动 2 个元素后指向的元素: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-指针的比较">（4）指针的比较</h4><ul><li><p>在 <code>C++</code> 中，指针的比较操作可以用于确定两个指针是否指向相同的位置、一个指针指向的位置是否在另一个指针指向之前或之后等。指针的比较主要包括以下几种：</p><ul><li><p><strong>相等性比较</strong>（<code>==</code> 和 <code>!=</code>）：用于检查两个指针是否指向相同的位置。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *ptr1 = &amp;a;</span><br><span class="line">    <span class="type">int</span> *ptr2 = &amp;a;</span><br><span class="line">    <span class="type">int</span> *ptr3 = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较指针是否相等</span></span><br><span class="line">    <span class="comment">// ptr1 和 ptr2 指向相同的位置</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1 == ptr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 和 ptr2 指向相同的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 和 ptr2 指向不同的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较指针是否不相等</span></span><br><span class="line">    <span class="comment">// ptr1 和 ptr3 指向不同的位置</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1 != ptr3) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 和 ptr3 指向不同的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 和 ptr3 指向相同的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关系比较</strong>（<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>）：关系比较用于确定一个指针指向的位置是否在另一个指针指向之前或之后。这通常在指针指向同一个数组的元素时有意义。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr1 = &amp;arr[<span class="number">1</span>]; <span class="comment">// 指向数组的第二个元素</span></span><br><span class="line">    <span class="type">int</span> *ptr2 = &amp;arr[<span class="number">3</span>]; <span class="comment">// 指向数组的第四个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较指针的相对位置</span></span><br><span class="line">    <span class="comment">// ptr1 指向的元素在 ptr2 指向的元素之前</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1 &lt; ptr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 指向的元素在 ptr2 指向的元素之前&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 指向的元素不在 ptr2 指向的元素之前&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ptr2 指向的元素在 ptr1 指向的元素之后</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2 &gt; ptr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 指向的元素在 ptr1 指向的元素之后&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 指向的元素不在 ptr1 指向的元素之后&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注：关系比较（如 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）在同一数组的元素之间进行是有意义的。如果指针不属于同一个数组，关系比较的结果是未定义的。</li></ul></li></ul></li></ul><h3 id="1-4-3-指针数组">1.4.3 指针数组</h3><ul><li><p>在讲解指针数组之前，先看一个实例，它用到了一个由 <code>3</code> 个整数组成的数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  var[MAX] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="comment">// Value of var[0] = 10</span></span><br><span class="line">    <span class="comment">// Value of var[1] = 100</span></span><br><span class="line">    <span class="comment">// Value of var[2] = 200</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value of var[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; var[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存在这样一种情况：我们想要让数组存储指向 <code>int</code> 或 <code>char</code> 或其他数据类型的指针。下面是一个指向整数的指针数组的声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *ptr[MAX];</span><br></pre></td></tr></table></figure><ul><li>在这里，把 <code>ptr</code> 声明为一个数组，由 <code>MAX</code> 个 <strong>整数指针</strong> 组成。因此，<code>ptr</code> 中的每个元素，都是一个指向 <code>int</code> 值的指针。</li></ul></li><li><p>下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  var[MAX] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        ptr[i] = &amp;var[i]; <span class="comment">// 赋值为整数的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Value of var[0] = 10</span></span><br><span class="line">    <span class="comment">// Value of var[1] = 100</span></span><br><span class="line">    <span class="comment">// Value of var[2] = 200</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value of var[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; *ptr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-4-指针-vs-数组">1.4.4 指针 vs 数组</h3><ul><li>指针和数组是密切相关的。事实上，指针和数组在很多情况下是可以互换的。例：一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数</title>
      <link href="/posts/cpp/07.html"/>
      <url>/posts/cpp/07.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、函数简介</h1><ul><li><p>函数是 <strong>一组</strong> 一起执行同一个任务的语句。如何划分代码到不同的函数中由开发者决定，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p></li><li><p>每个 <code>C++</code> 程序都至少有一个函数，即主函数 <code>main()</code>。</p></li><li><p>函数 <strong>声明</strong> 告诉编译器函数的名称、返回类型和参数。</p></li><li><p>函数 <strong>定义</strong> 提供了函数的实际主体。</p></li><li><p><code>C++</code> 标准库提供了大量程序可以调用的内置函数。例：函数 <code>strcat()</code> 用来连接两个字符串，函数 <code>memcpy()</code> 用来复制内存到另一个位置。</p></li><li><p>函数还有很多叫法，比如方法、子例程或程序等。</p></li></ul><h1>二、函数定义</h1><ul><li><p><code>C++</code> 函数由一个 <strong>函数头</strong> 和一个 <strong>函数体</strong> 组成，定义格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter list)</span> </span>&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>return_type</code>：函数的返回值类型。一个函数可以返回一个值，有些函数仅需执行函数体而不返回值，在这种情况下，<code>return_type</code> 可设置为关键字 <code>void</code>。</li><li><code>function_name</code>：函数的实际名称，需要符合标识符命名规范。函数名和参数列表一起构成了函数签名。</li><li><code>parameter list</code>：参数列表。包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。这里的参数就像是占位符，被称为 <strong>形式参数</strong>。</li><li><code>body of the function</code>：函数体。包含一组定义函数执行任务的语句。</li></ul></li><li><p><code>C++</code> 不允许函数嵌套定义，即函数不能在其他函数中定义。</p></li><li><p>示例：定义一个 <code>max</code> 函数，函数有两个参数 <code>num1</code> 和 <code>num2</code>，返回这两个数中较大的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>三、函数声明</h1><ul><li>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</li><li>函数声明格式：<code>return_type function_name(parameter list);</code></li><li>针对上面定义的函数 <code>max()</code> 的函数声明为：<code>int max(int num1, int num2);</code><ul><li>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此 <code>int max(int, int);</code> 也是有效的声明。</li></ul></li><li>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，应该在调用函数的文件顶部声明函数。</li></ul><h1>四、函数调用</h1><ul><li>创建 <code>C++</code> 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</li><li>函数调用格式：<code>function_name(parameter list);</code><ul><li><code>function_name</code>：被调用函数的名称。</li><li><code>parameter list</code>：当函数被调用时，需要向参数列表传递值，这些值被称为 <strong>实际参数</strong>。实际参数的数据类型与数量与函数定义要相符。</li></ul></li><li>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行或到达函数的结束括号时，会把程序控制权交还给主程序。</li><li>如果函数返回一个值，则可以使用一个变量存储返回值：<code>return_type var = function_name(parameter list);</code>。</li><li>示例：<ul><li><p>在 <code>max.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 局部变量声明</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数来获取最大值</span></span><br><span class="line">ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Max value is : &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>五、函数参数</h1><ul><li>如果函数要使用参数，则必须声明接受参数值的变量，这些变量被称为函数的 <strong>形式参数</strong>。</li><li>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</li><li>当调用函数时，有 <strong>传值调用</strong>、**指针调用 **和 <strong>引用调用</strong> 三种向函数传递参数的方式。</li></ul><h2 id="5-1-传值调用">5.1 传值调用</h2><ul><li><p>传值调用会把参数的 <strong>实际值复制</strong> 给函数的形式参数。在这种情况下，<strong>修改函数内的形式参数不会影响实际参数</strong>，这意味着函数内的代码不会改变用于调用函数的实际参数。</p></li><li><p>示例：</p><ul><li><p>在 <code>swap.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">temp = x; <span class="comment">// 保存 x 的值</span></span><br><span class="line">x = y;    <span class="comment">// 把 y 值赋给 x</span></span><br><span class="line">y = temp; <span class="comment">// 把 x 值赋给 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;交换前，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">// 交换前，a 的值：100</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;交换前，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">// 交换前，b 的值：200</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用函数来交换值</span></span><br><span class="line">   <span class="built_in">swap</span>(a, b);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;交换后，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">// 交换后，a 的值：100</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;交换后，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">// 交换后，b 的值：200</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-2-指针调用">5.2 指针调用</h2><ul><li><p>指针调用把参数的 <strong>地址复制</strong> 给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，<strong>修改形式参数会影响实际参数</strong>。</p></li><li><p>按指针传递值，实际参数的指针会被传递给函数，需要声明函数的形式参数为指针类型。</p></li><li><p>示例：</p><ul><li><p>在 <code>swap.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span><span class="comment">// 形参数据类型为指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp = *x;<span class="comment">// 保存地址 x 的值</span></span><br><span class="line">*x = *y;<span class="comment">// 把 y 值赋给 x</span></span><br><span class="line">*y = temp;<span class="comment">// 把 x 值赋给 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;   <span class="comment">// 交换前，a 的值：100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;   <span class="comment">// 交换前，b 的值：200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 swap 函数来交换值：</span></span><br><span class="line">    <span class="comment">//      &amp;a 表示指向 a 的指针，即变量 a 的地址</span></span><br><span class="line">    <span class="comment">//      &amp;b 表示指向 b 的指针，即变量 b 的地址</span></span><br><span class="line">    <span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;   <span class="comment">// 交换后，a 的值：200</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;   <span class="comment">// 交换后，b 的值：100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-3-引用调用">5.3 引用调用</h2><ul><li><p>向函数传递参数的 <strong>引用调用</strong> 方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，<strong>修改形式参数会影响实际参数</strong>。</p></li><li><p>按引用传递值，实际参数的引用会被传递给函数，需要声明函数的形式参数为引用类型。</p></li><li><p>示例：</p><ul><li><p>在 <code>swap.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = x; <span class="comment">// 保存地址 x 的值</span></span><br><span class="line">    x = y;    <span class="comment">// 把 y 赋值给 x</span></span><br><span class="line">    y = temp; <span class="comment">// 把 x 赋值给 y</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.cpp</code> 文件中写入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-4-参数的默认值">5.4 参数的默认值</h2><ul><li><p>定义函数时可以为参数列表中的参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值；如果指定了值，则会忽略默认值，使用传递的值。</p></li><li><p>参数的默认值必须 <strong>从右向左</strong> 提供，即未指定默认值的参数不能出现在指定默认值参数的右边。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    result = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数来添加值</span></span><br><span class="line">    <span class="comment">// Total value is :300</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次调用函数</span></span><br><span class="line">    <span class="comment">// Total value is :120</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>六、Lambda 函数与表达式</h1><ul><li><p><code>C++11</code> 提供了对匿名函数的支持，称为 <code>Lambda</code> 函数（也叫 <code>Lambda</code> 表达式）。</p></li><li><p><code>Lambda</code> 表达式把函数看作对象。<code>Lambda</code> 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p></li><li><p><code>Lambda</code> 表达式本质上与函数声明非常类似。<code>Lambda</code> 表达式具体形式如下：</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 程序流程结构</title>
      <link href="/posts/cpp/06.html"/>
      <url>/posts/cpp/06.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><code>C</code> 语言中常用的编程结构有三种（其它编程语言也是如此），它们分别是：<ul><li><p><strong>顺序结构</strong>：代码从前向后依次执行，不跳过任何一条语句，所有的语句都会被执行。</p></li><li><p><strong>选择结构</strong>：也叫分支结构。代码会被分成多个部分，程序会根据特定条件（某个表达式的运算结果）来判断到底执行哪一部分。</p></li><li><p><strong>循环结构</strong>：程序会重复执行同一段代码，直到条件不再满足，或者遇到强行跳出语句（<code>break</code> 关键字）。</p></li></ul></li></ul><h2 id="一-选择结构">一、选择结构</h2><ul><li>选择结构（分支结构）涉及到的关键字包括 <code>if</code>、<code>else</code>、<code>switch</code>、<code>case</code>、<code>break</code>，还有一个条件运算符 <code>? :</code>（这是 <code>C</code> 语言中唯一的一个 <strong>三目运算符</strong>）。</li></ul><h3 id="1-1-if-语句">1.1 if 语句</h3><ul><li><p>一个 <code>if</code> 语句由一个布尔表达式后跟一个或多个语句组成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果布尔表达式为真将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果布尔表达式为 <code>true</code>，则 <code>if</code> 语句内的代码块将被执行。</li><li>如果布尔表达式为 <code>false</code>，则  <code>if</code> 语句结束后的第一组代码（闭括号后）将被执行。</li><li>C++ 把任何 **非零 **和 <strong>非空</strong> 的值假定为 <code>true</code>，把 <strong>零</strong>、<strong>空</strong> 或 <strong>null</strong> 假定为 <code>false</code>。</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 if 语句检查布尔条件</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果条件为真，则输出下面的语句</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 的值是 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 小于 20</span><br><span class="line">a 的值是 10</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-2-if-else-语句">1.2 if…else 语句</h3><ul><li><p>一个 <code>if</code> 语句后可跟一个可选的 <code>else</code> 语句，<code>else</code> 语句在布尔表达式为假时执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果布尔表达式为真将执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果布尔表达式为假将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果布尔表达式为 <code>true</code>，则执行 <code>if</code> 块内的代码。</li><li>如果布尔表达式为 <code>false</code>，则执行 <code>else</code> 块内的代码。</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查布尔条件</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果条件为真，则输出下面的语句</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果条件为假，则输出下面的语句</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 大于 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 的值是 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 大于 20</span><br><span class="line">a 的值是 100</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-3-运算符">1.3 ? : 运算符</h3><ul><li><p>条件运算符 <code>? :</code>，又被称为 <strong>三元运算符</strong>，因为它需要三个操作数，可以用来替代 <code>if...else</code> 语句。它的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure><ul><li><p><code>Exp1</code>、<code>Exp2</code> 和 <code>Exp3</code> 是表达式。</p></li><li><p><code>? :</code> 表达式的值是由 <code>Exp1</code> 决定的。</p></li><li><p>如果 <code>Exp1</code> 为真，则计算 <code>Exp2</code> 的值，且 <code>Exp2</code> 的计算结果则为整个 <code>? :</code> 表达式的值。</p></li><li><p>如果 <code>Exp1</code> 为假，则计算 <code>Exp3</code> 的值，且 <code>Exp3</code> 的计算结果则为整个 <code>? :</code> 表达式的值。</p></li></ul></li><li><p>示例：<strong>1.2</strong> <code>if...else</code> <strong>语句</strong> 中的示例可以改写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    a &lt; <span class="number">20</span> ? (cout &lt;&lt; <span class="string">&quot;a 小于 20&quot;</span> &lt;&lt; endl) : (cout &lt;&lt; <span class="string">&quot;a 大于 20&quot;</span> &lt;&lt; endl);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 的值是 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-if-else-if-else-语句">1.4 if…else if…else 语句</h3><ul><li><p>一个 <code>if</code> 语句后可跟一个可选的 <code>else if...else</code> 语句，这可用于测试多种条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 1 为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(boolean_expression <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 2 为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(boolean_expression <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 3 为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当上面条件都不为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用 <code>if...else if...else</code> 语句时，以下几点需要注意：</p><ul><li><p>一个 <code>if</code> 后可跟零个或一个 <code>else</code>，<code>else</code> 必须在所有 <code>else if</code> 之后。</p></li><li><p>一个 <code>if</code> 后可跟零个或多个 <code>else if</code>，<code>else if</code> 必须在 <code>else</code> 之前。</p></li><li><p>一旦某个 <code>else if</code> 匹配成功，其他的 <code>else if</code> 或 <code>else</code> 都将不会被测试。</p></li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 检查布尔条件</span></span><br><span class="line">   <span class="keyword">if</span>( a == <span class="number">10</span> )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 如果 if 条件为真，则输出下面的语句</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;a 的值是 10&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( a == <span class="number">20</span> )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 如果 else if 条件为真，则输出下面的语句</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;a 的值是 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( a == <span class="number">30</span> )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 如果 else if 条件为真，则输出下面的语句</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;a 的值是 30&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 如果上面条件都不为真，则输出下面的语句</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;没有匹配的值&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;a 的准确值是 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有匹配的值</span><br><span class="line">a 的准确值是 100</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-嵌套-if-语句">1.5 嵌套 if 语句</h3><ul><li><p><code>C++</code> 中，可以在一个 <code>if</code> 或 <code>else if</code> 语句内嵌套另一个 <code>if</code> 或 <code>else if</code> 语句：</p><ul><li><p><code>C++</code> 中嵌套 <code>if</code> 语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( boolean_expression <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 1 为 true 时执行</span></span><br><span class="line">   <span class="keyword">if</span>(boolean_expression <span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 当布尔表达式 2 为 ture 时执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 检查布尔条件</span></span><br><span class="line">   <span class="keyword">if</span>(a == <span class="number">100</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 如果条件为真，则检查下面的条件</span></span><br><span class="line">       <span class="keyword">if</span>(b == <span class="number">200</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// 如果条件为真，则输出下面的语句</span></span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;a 的值是 100，且 b 的值是 200&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;a 的准确值是 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;b 的准确值是 &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 的值是 100，且 b 的值是 200</span><br><span class="line">a 的准确值是 100</span><br><span class="line">b 的准确值是 200</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>C++</code> 中嵌套 <code>else if...else</code> 语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">   <span class="comment">// 如果 condition1 为 true，则执行此处的代码块</span></span><br><span class="line">   <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">      <span class="comment">// 如果 condition2 也为 true，则执行此处的代码块</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 condition2 为 false，则执行此处的代码块</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果 condition1 为 false，则执行此处的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x 小于 20&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">15</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x 小于 15&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x 大于等于 15&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x 大于等于 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x 小于 20</span><br><span class="line">x 大于等于 15</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="1-6-switch-语句">1.6 switch 语句</h3><ul><li><p>在 <code>C++</code> 中，<code>switch</code> 语句用于基于不同的条件执行不同的代码块，它通常用来替代一系列的 <code>if-else</code> 语句，使代码更清晰和易读：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 您可以有任意数量的 case 语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 可选的</span></span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个 <code>switch</code> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 <code>case</code>，且被测试的变量会对每个 <code>switch case</code> 进行匹配。</p></li><li><p><code>switch</code> 语句必须遵循下面的规则：</p><ul><li><code>switch</code> 语句中的 <code>expression</code> 必须是一个整型或枚举类型，或者是一个 <code>class</code> 类型，其中 <code>class</code> 有一个单一的转换函数将其转换为整型或枚举类型。</li><li>在一个 <code>switch</code> 中可以有 <strong>任意数量</strong> 的 <code>case</code> 语句。每个 <code>case</code> 后跟一个要比较的值和一个冒号 <code>:</code>。</li><li><code>case</code> 的 <code>constant-expression</code> 必须与 <code>switch</code> 中的 <code>expression</code> 具有相同的数据类型，且必须是一个常量或字面量。</li><li>当 <code>expression</code> 等于 <code>case</code> 中的常量时，<code>case</code> 后跟的语句将被执行，直到遇到 <code>break</code> 语句为止。</li><li>当遇到 <code>break</code> 语句时，<code>switch</code> 终止，控制流将跳转到 <code>switch</code> 语句后的下一行。</li><li>不是每一个 <code>case</code> 都需要包含 <code>break</code>。如果 <code>case</code> 语句不包含 <code>break</code>，控制流将会 <strong>不进行判断</strong> 而继续执行后续的 <code>case</code>，直到遇到 <code>break</code> 为止。</li><li>一个 <code>switch</code> 语句可以有一个可选的 <code>default case</code>，出现在 <code>switch</code> 的结尾。<code>default case</code> 可用于在上面所有 <code>case</code> 都不为真时执行一个任务。<code>default case</code> 中的 <code>break</code> 语句不是必需的。</li></ul></li><li><p><strong>注意事项：</strong></p><ul><li><p><strong><code>break</code> 语句：</strong> 每个 <code>case</code> 语句末尾的 <code>break</code> 语句是必要的，用于跳出 <code>switch</code> 语句。如果缺少 <code>break</code>，程序将继续执行下一个 <code>case</code>，这叫做&quot;贯穿&quot;。</p><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Number is 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;continue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Number is 2 or 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Number is not 1, 2, or 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">continue</span><br><span class="line">Number is 2 or 3</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong><code>default</code> 语句：</strong> <code>default</code> 语句是可选的，但通常在所有 <code>case</code> 都不匹配时使用，处理所有未列出的情况。</p></li><li><p><strong>表达式类型：</strong> <code>switch</code> 表达式通常是整数类型或枚举类型，浮点数和字符串类型是不可行的。</p></li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">char</span> grade = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">switch</span>(grade)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> :</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;很棒！&quot;</span> &lt;&lt; endl; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;做得好&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;您通过了&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span> :</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;最好再试一下&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span> :</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;无效的成绩&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;您的成绩是 &quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-嵌套-switch-语句">1.7 嵌套 switch 语句</h3><ul><li><p>可以把一个 <code>switch</code> 作为一个外部 <code>switch</code> 的语句序列的一部分，即可以在一个 <code>switch</code> 语句内使用另一个 <code>switch</code> 语句。即使内部和外部 <code>switch</code> 的 <code>case</code> 常量包含共同的值，也不会产生冲突。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">100</span>: </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;这是外部 switch 的一部分&quot;</span> &lt;&lt; endl;</span><br><span class="line">         <span class="keyword">switch</span>(b) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">               cout &lt;&lt; <span class="string">&quot;这是内部 switch 的一部分&quot;</span> &lt;&lt; endl;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;a 的准确值是 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;b 的准确值是 &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是外部 <span class="keyword">switch</span> 的一部分</span><br><span class="line">这是内部 <span class="keyword">switch</span> 的一部分</span><br><span class="line">a 的准确值是 <span class="number">100</span></span><br><span class="line">b 的准确值是 <span class="number">200</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二-循环结构">二、循环结构</h2><ul><li><code>C++</code> 中常用的循环结构有 <code>while</code> 循环、<code>do...while</code> 循环和 <code>for</code> 循环</li></ul><h3 id="2-1-while-循环">2.1 while 循环</h3><ul><li><p><code>C++</code> 中 <code>while</code> 循环的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环条件 <code>condition</code> 可以是任意的表达式，当条件为真（任意非零值都为真）时执行循环体 <code>statement(s)</code>。当条件为假时，将继续执行紧接着循环的下一条语句。因此，<code>while</code> <strong>循环的循环体可能一次都不会执行</strong>。</li><li>在这里，<code>statement(s)</code> 可以是一个单独的语句，也可以是几个语句组成的代码块。</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 - 100所有数字之和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;   <span class="comment">// 1 - 100所有数字之和为：5050</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-do-while-循环">2.2 do…while 循环</h3><ul><li><p><code>C++</code> 中 <code>do...while</code> 循环的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure><ul><li><code>while</code> 循环是在循环开始进行条件判断，<code>do...while</code> 循环是在循环结束进行条件判断，因此 <code>do...while</code> 循环会确保 <strong>至少执行一次循环体</strong>。</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 - 100所有数字之和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;   <span class="comment">// 1 - 100所有数字之和为：5050</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-for-循环">2.3 for 循环</h3><ul><li><p><code>for</code> 循环允许编写一个执行 <strong>特定次数</strong> 的循环的重复控制结构。</p></li><li><p><code>C++</code> 中 <code>for</code> 循环的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init; condition; increment)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>for</code> 循环的执行流程：</p></li><li><p><code>init</code> 会首先被执行，且 <strong>只会执行一次</strong>。这一步允许声明并初始化任何循环控制变量。该语句允许留空，只要有一个分号 <code>;</code> 出现即可。</p></li><li><p>接下来，会判断 <code>condition</code>。如果为真，则执行循环体。如果为假，则不执行循环体，且程序会跳转到紧接着 <code>for</code> 循环的下一条语句。该语句允许留空，只要有一个分号 <code>;</code> 出现即可。</p></li><li><p>在执行完 <code>for</code> 循环体后，程序会跳回到 <code>for</code> 循环开始的 <code>increment</code> 语句。该语句允许更新循环控制变量。该语句允许留空，只要有一个分号 <code>;</code> 出现即可。</p></li><li><p><code>condition</code> 条件再次被判断。如果为真，则再次执行循环体，这个过程会不断重复（执行循环体，然后更新循环控制变量，然后重新判断 <code>condition</code> 条件）。当 <code>condition</code> 条件变为假时，<code>for</code> 循环终止。</p></li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 - 100所有数字之和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;   <span class="comment">// 1 - 100所有数字之和为：5050</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-嵌套循环">2.4 嵌套循环</h3><ul><li><p>可以在 <code>while</code>、<code>for</code> 或 <code>do..while</code> 循环内使用一个或多个循环。</p></li><li><p><code>C++</code> 中嵌套 <code>for</code> 循环语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init; condition; increment)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> (init; condition; increment)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">statement</span>(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>C++</code> 中嵌套 <code>while</code> 循环语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">while</span>(condition)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">statement</span>(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>C++</code> 中嵌套 <code>do...while</code> 循环语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">statement</span>(s); <span class="comment">// 可以放置更多的语句</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">statement</span>(s);</span><br><span class="line">   &#125;<span class="keyword">while</span>(condition);</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure></li><li><p>可以在任何类型的循环内嵌套其他任何类型的循环。例：一个 <code>for</code> 循环可以嵌套在一个 <code>while</code> 循环内，反之亦然。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> (init; condition; increment)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">statement</span>(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-循环控制语句">2.5 循环控制语句</h3><h4 id="2-5-1-break-语句">2.5.1 break 语句</h4><ul><li><p><code>break</code> 关键字通常单独作为一行语句出现，所以又被称为 <code>break</code> 语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>break</code> 关键字通常和 <code>if</code> 语句一起使用，即满足条件时便跳出循环。</p></li><li><p><code>C++</code> 中 <code>break</code> 语句有以下两种用法：</p><ul><li>当 <code>break</code> 语句出现在一个循环内时，循环会立即终止，且程序将继续执行紧接着循环的下一条语句。</li><li>它可用于终止 <code>switch</code> 语句中的一个 <code>case</code>。</li></ul></li><li><p>在嵌套循环中使用 <code>break</code> 语句，<code>break</code> 语句只会停止执行当前所在的循环，然后开始执行该块之后的下一行代码。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// do 循环执行</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">       a = a + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>( a &gt; <span class="number">15</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// 终止循环</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span>( a &lt; <span class="number">20</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-5-2-continue-语句">2.5.2 continue 语句</h4><ul><li><p><code>continue</code> 会单次跳过当前循环中的代码，强迫开始下一次循环。</p></li><li><p>对于 <code>for</code> 循环，<code>continue</code> 语句会导致执行条件判断和循环增量部分。</p></li><li><p>对于 <code>while</code> 和 <code>do...while</code> 循环，<code>continue</code> 语句会导致程序跳转回到条件判断部分。</p></li><li><p>示例：输出 <code>1 - 100</code> 之间的所有奇数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-5-3-goto-语句">2.5.3 goto 语句</h4><ul><li><p><code>goto</code> 语句允许把控制无条件转移到同一函数内的被标记的语句。</p></li><li><p><code>C++</code> 中 <code>goto</code> 语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure><ul><li><code>label</code> 是识别被标记语句的标识符，可以是任何除 <code>C++</code> 关键字以外的纯文本。</li><li>标记语句 <code>statement</code> 可以是任何语句，放置在标识符和冒号 <code>:</code> 后边。</li></ul></li><li><p>在任何编程语言中，都不建议使用 <code>goto</code> 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 <code>goto</code> 语句的程序可以改写成不需要使用 <code>goto</code> 语句的写法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数组 &amp; 字符串</title>
      <link href="/posts/cpp/05.html"/>
      <url>/posts/cpp/05.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-数组">一、数组</h2><ul><li><code>C++</code> 支持数组数据结构，它可以存储一个 <strong>固定大小</strong> 的 <strong>相同数据类型</strong> 元素的 <strong>顺序</strong> 集合。</li><li>数组是用来存储一系列具有相同数据类型的变量，即数组是可变的。</li></ul><h3 id="1-1-声明数组">1.1 声明数组</h3><ul><li>数组的声明并不是声明一个个单独的变量，例：<code>number0</code>、<code>number1</code>、…、<code>number99</code>。而是声明一个数组变量，例： <code>numbers</code>，然后使用 <code>numbers[0]</code>、<code>numbers[1]</code>、…、<code>numbers[99]</code> 来代表一个个单独的变量。</li><li><code>C++</code> 声明数组的格式：<code>typeName arrayName[arraySize];</code><ul><li><code>typeName</code>：数组中元素的数据类型。</li><li><code>arrayName</code>：数组名，需要符合标识符命名规则。</li><li><code>arraySize</code>：数组中含有的元素数量，必须为大于 <code>0</code> 的整型常量。</li></ul></li></ul><h3 id="1-2-初始化数组">1.2 初始化数组</h3><ul><li><p><code>C++</code> 可以使用一个初始化语句，对数组进行初始化。例：<code>int arr[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</code></p><ul><li>等号 <code>=</code> 可以省略，即 <code>int arr[10]&#123;0,1,2,3,4,5,6,7,8,9&#125;;</code>。</li><li>大括号 <code>&#123;&#125;</code> 之间的值的数目 <strong>不能大于</strong> 数组声明时在方括号 <code>[]</code> 中指定的元素数目。</li><li>大括号 <code>&#123;&#125;</code> 之间的值的数目 <strong>可以小于</strong> 数组声明时在方括号 <code>[]</code> 中指定的元素数目，如果部分初始化数组，编译器会将剩余的元素默认为 <code>0</code>。<ul><li>如果仅将数组的第一个元素初始化为  <code>0</code>，编译器会将数组所有元素初始化为 <code>0</code>。例：<code>int arr[10] =&#123;0&#125;;</code>，会将整型数组的所有元素初始化为 <code>0</code>。</li><li>将数组所有元素初始化为 <code>0</code> 的另一种方式：<code>typeName arrayName[arraySize]&#123;&#125;;</code> 。例：<code>int arr[3]&#123;&#125;;</code>。</li></ul></li><li>如果在初始化数组时将方括号 <code>[]</code> 留空，则 <code>C++</code> 编译器将自动计算数组长度。例：<code>int arr[] = &#123;0,1,2,3,4&#125;;</code></li></ul></li><li><p>可以先声明数组，然后再对数组元素逐一初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> arr[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-访问数组元素">1.3 访问数组元素</h3><ul><li><p>数组元素可以通过数组名称加索引的方式进行访问：<code>arrayName[index];</code> 。元素的索引 <code>index</code> 是放在方括号内，跟在数组名称的后边。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> arr[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;// <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-多维数组">1.4 多维数组</h3><ul><li><code>C++</code> 支持多维数组。多维数组声明的一般形式：<code>type arrayname[size1][size2]...[sizeN];</code></li><li>多维数组可以通过在括号内为每行指定值来进行初始化；也可以将初始化值放在一个括号内，编译器会按照每个维度的大小自动初始化。</li><li>访问多维数组的元素同样是使用下标索引进行访问：<code>arrayname[index1][index2]...[indexN];</code></li></ul><h4 id="1-4-1-二维数组">1.4.1 二维数组</h4><ul><li><p>多维数组最简单的形式是二维数组。对于二维数组，每个元素本身就是一个一维数组。</p></li><li><p>声明一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 列二维数组的格式：<code>type arrayName[x][y];</code>。例：<code>int arr[3][4]</code> 声明一个 <code>3</code> 行 <code>4</code> 列整型数组。</p></li><li><p>初始化 <code>3</code> 行 <code>4</code> 列整型数组的方式：</p><ul><li><p>方式一：为每行指定值来进行初始化，初始值不够每行长度时，编译器会将剩余的元素默认为 <code>0</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,// 初始化索引号为 <span class="number">0</span> 的行</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,// 初始化索引号为 <span class="number">1</span> 的行</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;// 初始化索引号为 <span class="number">2</span> 的行</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方式二：将所有初始值放在一个括号内：<code>int arr[3][4]&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;</code>。初始值不够数组全部元素数量时，编译器会将剩余的元素默认为 <code>0</code>。</p></li></ul></li><li><p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例：<code>arr[2][2]</code> 获取数组 <code>arr</code> 中第 <code>3</code> 行第 <code>3</code> 个元素。</p></li></ul><h2 id="二-字符串">二、字符串</h2><ul><li><p>在 <code>C++</code> 中，字符串是由字符组成的序列。</p></li><li><p><code>C++</code> 提供了以下两种类型的字符串表示形式：</p><ul><li><p><code>C</code> 风格字符串。</p></li><li><p><code>C++</code> 引入的 <code>string</code> 类类型。</p></li></ul></li></ul><h3 id="2-1-c-风格字符串">2.1 C 风格字符串</h3><ul><li><p><code>C</code> 风格的字符串起源于 <code>C</code> 语言，并在 <code>C++</code> 中继续得到支持，格式：<code>char 变量名[] = &quot;字符串值&quot;;</code>。</p></li><li><p>字符串实际上是使用 <code>null</code> 字符 <code>\0</code> 终止的一维 <strong>字符数组</strong>。</p></li><li><p>声明和初始化一个字符串 <code>&quot;Hello world!&quot;</code>：<code>char str[13] = &quot;Hello world!&quot;;</code></p><ul><li>由于在数组末尾自动存储了空字符 <code>\0</code>，所以字符数组的大小需要比字符串 <code>&quot;Hello world!&quot;</code> 包含的字符数多一个。</li><li>依据数组初始化规则，可以把上面的语句写成以下语句：<code>char str[] = &quot;Hello world!&quot;;</code></li></ul></li><li><p><code>C++</code> 中有大量的函数用来操作以 <code>null</code> 结尾的字符串：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>strcpy_s(s1, s2)</code></td><td>复制字符串 <code>s2</code> 到字符串 <code>s1</code></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>strcat_s(s1, s2)</code></td><td>连接字符串 <code>s2</code> 到字符串 <code>s1</code> 的末尾。<br />注：连接字符串也可以直接使用 <code>+</code> 号。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>strlen(s1)</code></td><td>返回字符串 <code>s1</code> 的长度（不包含 <code>null</code> 字符 <code>\0</code> ）。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>strcmp(s1, s2)</code></td><td>两个字符串自左向右 <strong>逐个字符</strong> 比较（按 <code>ASCII</code> 值大小相比较），直到出现 <strong>不同</strong> 的字符或遇 <code>\0</code> 为止。<br />如果 <code>s1</code> 和 <code>s2</code> 是相同的，则返回 <code>0</code>；<br />如果 <code>s1 &lt; s2</code> 则返回值小于 <code>0</code>；<br />如果 <code>s1 &gt; s2</code> 则返回值大于 <code>0</code>。<br />当两个字符串不相等时，没有规定返回值会是 <code>1</code> 或 <code>-1</code>，只规定了正数和负数。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>strchr(s1, ch)</code></td><td>有些会把两个字符的 ASCII 码之差作为比较结果由函数值返回。返回一个指针，指向字符串 <code>s1</code> 中字符 <code>ch</code> 的第一次出现的位置。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>strstr(s1, s2)</code></td><td>返回一个指针，指向字符串 <code>s1</code> 中字符串 <code>s2</code> 的第一次出现的位置。</td></tr></tbody></table><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">11</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = <span class="string">&quot; ZZZ&quot;</span>;</span><br><span class="line"><span class="type">char</span> str3[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> measure;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy_s</span>(str3, str1);<span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<span class="comment">// str1: Hello</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;strlen(str1): &quot;</span> &lt;&lt; <span class="built_in">strlen</span>(str1) &lt;&lt; endl;<span class="comment">// strlen(str1): 5</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;strcpy_s(str3, str1): &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<span class="comment">// strcpy_s(str3, str1): Hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat_s</span>(str1, str2);<span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;strcat_s(str1, str2): &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<span class="comment">// strcat_s(str1, str2): Hello World</span></span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strlen</span>(str1);<span class="comment">// 连接后，str1 的总长度</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;strlen(str1): &quot;</span> &lt;&lt; len &lt;&lt; endl;<span class="comment">// strlen(str1): 11</span></span><br><span class="line"></span><br><span class="line">measure = <span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;strcmp(str1, str2): &quot;</span> &lt;&lt; measure &lt;&lt; endl;<span class="comment">// strcmp(str1, str2): 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-2-c-中的-string-类">2.2 C++ 中的 String 类</h3><ul><li><code>C++</code> 标准库提供了 <code>String</code> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。</li><li><code>&lt;string&gt;</code> 是 <code>C++</code> 标准库中用于处理字符串的头文件。</li><li><code>&lt;string&gt;</code> 头文件提供了 <code>std::string</code> 类，它是对 <code>C</code> 风格字符串的封装，提供了更安全、更易用的字符串操作功能。</li><li>要在 <code>C++</code> 程序中使用 <code>&lt;string&gt;</code> 库，首先需要包含这个头文件：<code>#include &lt;string&gt;</code>。</li></ul><h4 id="2-2-1-基本语法">2.2.1 基本语法</h4><ul><li><p><code>std::string</code> 类的基本语法如下：</p><ul><li><p>声明字符串变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br></pre></td></tr></table></figure></li><li><p>初始化字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>+</code> 连接字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">std::string result = str1 + str2;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-2-常用成员函数">2.2.2  常用成员函数</h4><ul><li><p><code>std::string</code> 类提供了许多成员函数来操作字符串：</p><ul><li><p><code>size()</code> ：返回字符串的长度（字符数）。</p></li><li><p><code>length()</code> ：与 <code>size()</code> 相同，返回字符串的长度。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 12</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; endl;<span class="comment">// 12</span></span><br></pre></td></tr></table></figure></li><li><p><code>empty()</code>：判断字符串是否为空，返回 <code>0</code> 或 <code>1</code>。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">empty</span>() &lt;&lt; endl;<span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>at(index)</code>：访问字符串中指定索引  <code>index</code>  的字符（带边界检查）。</p><ul><li>函数 <code>at()</code> 在使用时会检查下标是否有效。如果给定的下标超出字符的长度范围，系统会抛出 <code>out_of_range</code> 异常。下标操作符 <code>[]</code> 在使用时不检查索引的有效性，如果下标超出字符的长度范围，会导致未定义行为。对于常量字符串，使用下标操作符时，字符串的最后字符（即 <code>'\0'</code>）是有效的。对应 <code>string</code> 类型对象（常量型）最后一个字符的下标是有效的，调用返回字符 <code>'\0'</code>。</li></ul></li><li><p><code>substr(pos, n)</code> ：返回从指定位置 <code>pos</code> 开始，长度为 <code>n</code>（默认 <code>0</code>）的子字符串。</p><ul><li><p>若 <code>pos</code> 值超过了 <code>string</code> 的长度，则 <code>substr</code> 函数会抛出一个 <code>out_of_range</code> 异常；</p></li><li><p>若 <code>pos+n</code> 值超过了 <code>string</code> 的长度，则 <code>substr</code> 会调整 <code>n</code> 的值，只拷贝到 <code>string</code> 的末尾。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;<span class="comment">// lo Worl</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">6</span>) &lt;&lt; endl;<span class="comment">// World!</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">27</span>) &lt;&lt; endl;<span class="comment">// World!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>find(str, pos)</code>：从索引 <code>pos</code>（默认 <code>0</code>）开始查找子字符串 <code>str</code> 在主字符串中的位置，返回值为目标字符的位置，当没有找到目标字符时返回 <code>npos</code>。</p><ul><li><p><code>string::npos</code> 是字符串可储存的最大字符数，通常是无符号 <code>int</code> 或无符号 <code>long</code> 的最大取值。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;<span class="comment">// 18446744073709551615</span></span><br><span class="line">cout &lt;&lt; str.npos &lt;&lt; endl;<span class="comment">// 18446744073709551615</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&quot;l&quot;</span>) &lt;&lt; endl;<span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&quot;l&quot;</span>, <span class="number">6</span>) &lt;&lt; endl;<span class="comment">// 9</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&quot;or&quot;</span>) &lt;&lt; endl;<span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rfind(str, pos)</code> ：从索引 <code>pos</code>（默认 <code>-1</code>）开始开始查找子字符串 <code>str</code> 的位置，返回值为目标字符的位置，当没有找到目标字符时返回 <code>npos</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">rfind</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;<span class="comment">// 18446744073709551615</span></span><br><span class="line">cout &lt;&lt; str.npos &lt;&lt; endl;<span class="comment">// 18446744073709551615</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">rfind</span>(<span class="string">&quot;l&quot;</span>) &lt;&lt; endl;<span class="comment">// 9</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">rfind</span>(<span class="string">&quot;l&quot;</span>, <span class="number">6</span>) &lt;&lt; endl;<span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">rfind</span>(<span class="string">&quot;or&quot;</span>) &lt;&lt; endl;<span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li><li><p><code>replace(pos, len, str)</code>：将主字符串中从索引 <code>pos</code> 开始，长度为 <code>len</code>的子字符串替换为 <code>str</code>，返回被替换后的字符串。</p><ul><li><p>注：当 <code>len</code> 大于从 <code>pos</code> 开始到字符串结尾所包含的字符数量时，仅替换到字符串末尾。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;LL&quot;</span>) &lt;&lt; endl;<span class="comment">// HeLLo World!</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;<span class="comment">// HeLLo World!</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">replace</span>(<span class="number">9</span>, <span class="number">17</span>, <span class="string">&quot;AAAAA&quot;</span>) &lt;&lt; endl;<span class="comment">// HeLLo WorAAAAA</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>append(str, len)</code> ：在主字符串末尾添加子字符串的前 <code>len</code> 个字符（不设置则全部添加）。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">append</span>(<span class="string">&quot; C++&quot;</span>) &lt;&lt; endl;<span class="comment">// Hello C++</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">append</span>(<span class="string">&quot; Hello World!&quot;</span>, <span class="number">6</span>) &lt;&lt; endl;<span class="comment">// Hello C++ Hello</span></span><br></pre></td></tr></table></figure></li><li><p><code>insert(pos, str)</code> ：在主字符串索引为 <code>pos</code> 的位置前插入子字符串 <code>str</code>。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;Hello &quot;</span>) &lt;&lt; endl;<span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure></li><li><p><code>erase(pos, len)</code>：删除主字符串中开始索引为 <code>pos</code> 位置，长度为 <code>len</code> 的子字符串。</p><ul><li><p>注：当 <code>len</code> 大于从 <code>pos</code> 开始到字符串结尾所包含的字符数量时，仅删除到字符串末尾。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl;<span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>clear()</code>：清空字符串，无返回值。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 运算符</title>
      <link href="/posts/cpp/04.html"/>
      <url>/posts/cpp/04.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。</li><li><code>C++</code> 提供了算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</li></ul><h2 id="一-算术运算符">一、算术运算符</h2><ul><li><p><code>C++</code> 具有五个基本算术运算的运算符：加法、减法、乘法、除法和取模，这些运算符使用两个操作数来计算最终结果，被称为 <strong>双目运算符</strong>。</p></li><li><p><code>C++</code> 提供了自增运算符 <code>++</code> 和自减运算符 <code>--</code>，这些运算符使用单个操作数来计算最终结果，被称为 <strong>单目运算符</strong>。</p></li><li><p>假设变量 <code>a</code> 的值为 <code>10</code>，变量 <code>b</code> 的值为 <code>20</code>，则：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">把两个操作数相加</td><td style="text-align:left"><code>a + b</code> 将得到 <code>30</code></td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">从第一个操作数中减去第二个操作数</td><td style="text-align:left"><code>a - b</code> 将得到 <code>-10</code></td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">把两个操作数相乘</td><td style="text-align:left"><code>a * b</code> 将得到 <code>200</code></td></tr><tr><td style="text-align:left"><code>/</code></td><td style="text-align:left">分子除以分母，若任一操作数为浮点数，则返回浮点数</td><td style="text-align:left"><code>b / a</code> 将得到 <code>2</code></td></tr><tr><td style="text-align:left"><code>%</code></td><td style="text-align:left">取模运算符，返回整数除法的余数</td><td style="text-align:left"><code>b % a</code> 将得到 <code>0</code></td></tr><tr><td style="text-align:left"><code>++</code></td><td style="text-align:left">自增运算符，整数值增加 1</td><td style="text-align:left"><code>a++</code> 或 <code>++a</code> 将得到 <code>11</code></td></tr><tr><td style="text-align:left"><code>--</code></td><td style="text-align:left">自减运算符，整数值减少 1</td><td style="text-align:left"><code>a--</code> 或 <code>--a</code> 将得到 <code>9</code></td></tr></tbody></table><ul><li><p>自增运算符 <code>++</code> 会把操作数加 <code>1</code>，自减运算符 <code>--</code> 会把操作数减 <code>1</code>。</p></li><li><p>无论是自增运算符还是自减运算符，都可以放在操作数的前面（前缀）或后面（后缀）。但是如果使用前缀形式，则会在表达式计算之前完成自增或自减，如果使用后缀形式，则会在表达式计算之后完成自增或自减。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a + b++: &quot;</span> &lt;&lt; a + b++ &lt;&lt; endl;<span class="comment">// 30</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a + ++b: &quot;</span> &lt;&lt; a + ++b &lt;&lt; endl;<span class="comment">// 32</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二-关系运算符">二、关系运算符</h2><ul><li><p><code>C++</code> 提供了六个关系运算符来对数字进行比较，这些运算符使用两个操作数来计算最终结果，被称为 <strong>双目运算符</strong>。</p></li><li><p>假设变量 <code>a</code> 的值为 <code>10</code>，变量 <code>b</code> 的值为 <code>20</code>，则：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left"><code>==</code></td><td style="text-align:left">检查两个操作数的值是否相等，如果相等则为真，否则为假</td><td style="text-align:left"><code>a == b</code> 为假</td></tr><tr><td style="text-align:left"><code>!=</code></td><td style="text-align:left">检查两个操作数的值是否相等，如果不相等则为真，否则为假</td><td style="text-align:left"><code>a != b</code> 为真</td></tr><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则为真，否则为假</td><td style="text-align:left"><code>a &gt; b</code> 为假</td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则为真，否则为假</td><td style="text-align:left"><code>a &lt; b</code> 为真</td></tr><tr><td style="text-align:left"><code>&gt;=</code></td><td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则为真，否则为假</td><td style="text-align:left"><code>a &gt;= b</code> 为假</td></tr><tr><td style="text-align:left"><code>&lt;=</code></td><td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则为真，否则为假</td><td style="text-align:left"><code>a &lt;= b</code> 为真</td></tr></tbody></table></li></ul><h2 id="三-逻辑运算符">三、逻辑运算符</h2><ul><li><p><code>C++</code> 逻辑运算符包括逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code> 和逻辑非 <code>!</code>，它们用于执行复合的逻辑操作。</p></li><li><p><code>&amp;&amp;</code> 和 <code>||</code> 使用两个操作数来计算最终结果，被称为 <strong>双目运算符</strong>。<code>!</code> 使用单个操作数来计算最终结果，被称为 <strong>单目运算符</strong>。</p></li><li><p>假设变量 <code>a</code> 的值为 <code>True</code>，变量 <code>b</code> 的值为 <code>False</code>，则：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left"><code>&amp;&amp;</code></td><td style="text-align:left">逻辑与运算符。如果两个操作数都 <code>true</code>，则条件为 <code>true</code>。</td><td style="text-align:left"><code>a &amp;&amp; b</code> 为 <code>false</code></td></tr><tr><td style="text-align:left"><code>||</code></td><td style="text-align:left">逻辑或运算符。如果两个操作数中有任意一个 <code>true</code>，则条件为 <code>true</code>。</td><td style="text-align:left"><code>a || b</code> 为 <code>true</code></td></tr><tr><td style="text-align:left"><code>!</code></td><td style="text-align:left">逻辑非运算符。用来逆转单个操作数的逻辑状态，如果条件为 <code>true</code> 则逻辑非运算符将使其为 <code>false</code>，反之亦然。</td><td style="text-align:left"><code>!a</code> 为  <code>false</code></td></tr></tbody></table></li></ul><h2 id="四-位运算符">四、位运算符</h2><ul><li><p>位运算符作用于二进制位，即 <code>0</code>、<code>1</code>，并逐位执行操作。</p></li><li><p><code>&amp;</code>、<code>|</code> 和 <code>^</code> 使用两个操作数来计算最终结果，被称为 <strong>双目运算符</strong>。</p></li><li><p><code>~</code>、<code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 使用单个操作数来计算最终结果，被称为 <strong>单目运算符</strong>。</p></li><li><p>下表显示了 <code>C++</code> 支持的位运算符。</p><ul><li>变量 <code>a</code> 的值为 <code>60</code>，二进制 <code>00111100</code>。</li><li>变量 <code>b</code> 的值为 <code>13</code>，二进制 <code>00001101</code>。</li></ul><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">按位与运算符，按二进制位进行 “与” 运算。<br />运算规则：两位都为 <code>1</code> 时，结果为 <code>1</code>，否则为 <code>0</code>。<br />即：<code>0&amp;0=0</code>、<code>0&amp;1=0</code>、<code>1&amp;0=0</code>、<code>1&amp;1=1</code></td><td style="text-align:left"><code>a &amp; b</code> 将得到 <code>12</code>，即为 <code>00001100</code></td></tr><tr><td style="text-align:left"><code>|</code></td><td style="text-align:left">按位或运算符，按二进制位进行 “或” 运算。<br />运算规则： 两位都为 <code>0</code> 时，结果为 <code>0</code>，否则为 <code>1</code>。<br />即：<code>0|0=0</code>、<code>0|1=1</code>、<code>1|0=1</code>、<code>1|1=1</code></td><td style="text-align:left"><code>a | b</code> 将得到 <code>61</code>，即为 <code>00111101</code></td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">异或运算符，按二进制位进行 “异或” 运算。<br />运算规则：两个位相同为 <code>0</code>，相异为 <code>1</code>。<br />即：<code>0^0=0</code>、<code>0^1=1</code>、<code>1^0=1</code>、<code>1^1=0</code></td><td style="text-align:left"><code>a ^ b</code> 将得到 <code>49</code>，即为 <code>00110001</code></td></tr><tr><td style="text-align:left"><code>~</code></td><td style="text-align:left">取反运算符，按二进制位进行 “取反” 运算。<br />运算规则：<code>0</code> 变 <code>1</code>，<code>1</code> 变 <code>0</code>。即：<code>~1=0</code>、<code>~0=1</code></td><td style="text-align:left"><code>~a</code> 将得到 <code>-61</code>，即为 <code>11000011</code>。</td></tr><tr><td style="text-align:left"><code>&lt;&lt;</code></td><td style="text-align:left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 <code>0</code>）。左移 <code>n</code> 位相当于乘以 <code>2</code> 的 <code>n</code> 次方。</td><td style="text-align:left"><code>a &lt;&lt; 2</code> 将得到 <code>240</code>，即为 <code>11110000</code></td></tr><tr><td style="text-align:left"><code>&gt;&gt;</code></td><td style="text-align:left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 <code>0</code>，负数左补 <code>1</code>，右边丢弃。右移 <code>n</code> 位相当于除以 <code>2</code> 的 <code>n</code> 次方。</td><td style="text-align:left"><code>a &gt;&gt; 2</code> 将得到 <code>15</code>，即为 <code>00001111</code></td></tr></tbody></table></li></ul><h2 id="五-赋值运算符">五、赋值运算符</h2><ul><li><p>赋值运算符就是在上述运算符基础上进行赋值操作。<code>C++</code> 支持的赋值运算符如下表所示：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">简单的赋值运算符，把右边操作数的值赋给左边操作数。</td><td style="text-align:left"><code>c = a + b</code> 把 <code>a + b</code> 的值赋给 <code>c</code></td></tr><tr><td style="text-align:left"><code>+=</code></td><td style="text-align:left">加且赋值运算符，把左边操作数加上右边操作数的结果赋值给左边操作数。</td><td style="text-align:left"><code>c += a</code> 等同于 <code>c = c + a</code></td></tr><tr><td style="text-align:left"><code>-=</code></td><td style="text-align:left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数。</td><td style="text-align:left"><code>c -= a</code> 等同于 <code>c = c - a</code></td></tr><tr><td style="text-align:left"><code>*=</code></td><td style="text-align:left">乘且赋值运算符，把左边操作数乘以右边操作数的结果赋值给左边操作数。</td><td style="text-align:left"><code>c *= a</code> 等同于 <code>c = c * a</code></td></tr><tr><td style="text-align:left"><code>/=</code></td><td style="text-align:left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数。</td><td style="text-align:left"><code>c /= a</code> 等同于 <code>c = c / a</code></td></tr><tr><td style="text-align:left"><code>%=</code></td><td style="text-align:left">取模且赋值运算符，求两个操作数模的结果赋值给左边操作数。</td><td style="text-align:left"><code>c %= a</code> 等同于 <code>c = c % a</code></td></tr><tr><td style="text-align:left"><code>&lt;&lt;=</code></td><td style="text-align:left">左移且赋值运算符，把左边操作数左移右边操作数的结果赋值给左边操作数。</td><td style="text-align:left"><code>c &lt;&lt;= a</code> 等同于 <code>c = c &lt;&lt; a</code></td></tr><tr><td style="text-align:left"><code>&gt;&gt;=</code></td><td style="text-align:left">右移且赋值运算符，把左边操作数右移右边操作数的结果赋值给左边操作数。</td><td style="text-align:left"><code>c &gt;&gt;= a</code> 等同于 <code>c = c &gt;&gt; a</code></td></tr><tr><td style="text-align:left"><code>&amp;=</code></td><td style="text-align:left">按位与且赋值运算符，把左边操作数和右边操作数进行按位与操作的结果赋值给左边操作数。</td><td style="text-align:left"><code>c &amp;= a</code> 等同于 <code>c = c &amp; a</code></td></tr><tr><td style="text-align:left"><code>|=</code></td><td style="text-align:left">按位或且赋值运算符，把左边操作数和右边操作数进行按位或操作的结果赋值给左边操作数。</td><td style="text-align:left"><code>c |= a</code> 等同于 <code>c = c | a</code></td></tr><tr><td style="text-align:left"><code>^=</code></td><td style="text-align:left">按位异或且赋值运算符，把左边操作数和右边操作数进行按位异或操作的结果赋值给左边操作数。</td><td style="text-align:left"><code>c ^= a</code> 等同于 <code>c = c ^ a</code></td></tr></tbody></table></li></ul><h2 id="六-其他运算符">六、其他运算符</h2><ul><li><p>下表列出了 <code>C++</code> 支持的其他一些重要的运算符：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>sizeof</code></td><td style="text-align:left">返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td style="text-align:left">Condition ? X : Y</td><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr><tr><td style="text-align:left">,</td><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr><tr><td style="text-align:left">.（点）和 -&gt;（箭头）</td><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr><tr><td style="text-align:left">Cast</td><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr></tbody></table></li></ul><h2 id="七-运算符优先级">七、运算符优先级</h2><ul><li><p>下表按运算符 <strong>优先级从高到低</strong> 列出各个运算符，在表达式中，较高优先级的运算符会优先被计算。</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">运算符</th><th style="text-align:left">结合性</th></tr></thead><tbody><tr><td style="text-align:left">后缀</td><td style="text-align:left"><code>()</code> 、<code>[]</code>、<code>-&gt;</code>、<code>.</code>、<code>++</code>、<code>--</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">一元</td><td style="text-align:left"><code>+</code>、<code>-</code>、<code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>(type)*</code>、<code>&amp;</code>、<code>sizeof</code></td><td style="text-align:left"><strong>从右到左</strong></td></tr><tr><td style="text-align:left">乘除</td><td style="text-align:left"><code>*</code>、<code>/</code>、<code>%</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left"><code>+</code>、<code>-</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">相等</td><td style="text-align:left"><code>==</code>、<code>!=</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位与 <code>AND</code></td><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位异或 <code>XOR</code></td><td style="text-align:left"><code>^</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位或 <code>OR</code></td><td style="text-align:left"><code>|</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">逻辑与 <code>AND</code></td><td style="text-align:left"><code>&amp;&amp;</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">逻辑或 OR</td><td style="text-align:left"><code>||</code></td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left"><code>? : </code></td><td style="text-align:left"><strong>从右到左</strong></td></tr><tr><td style="text-align:left">赋值</td><td style="text-align:left"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&gt;&gt;=</code>、<code>&lt;&lt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code></td><td style="text-align:left"><strong>从右到左</strong></td></tr><tr><td style="text-align:left">逗号</td><td style="text-align:left"><code>,</code></td><td style="text-align:left">从左到右</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 输入 &amp; 输出</title>
      <link href="/posts/cpp/03.html"/>
      <url>/posts/cpp/03.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><code>C++</code> 的 <code>I/O</code>（<code>Input/Output</code>） 发生在流中，流是字节序列。</p></li><li><p>如果字节流是从设备（例：键盘、磁盘驱动器、网络连接等）流向内存，这叫做 <strong>输入操作</strong>。</p></li><li><p>如果字节流是从内存流向设备（例：显示屏、打印机、磁盘驱动器、网络连接等），这叫做 <strong>输出操作</strong>。</p></li><li><p>使用 <code>C++</code> 的输入输出，需要在文件开头引入头文件 <code>&lt;iostream&gt;</code>，该文件定义了标准输入流 <code>cin</code> 对象和标准输出流 <code>cout</code> 对象。</p></li></ul><h2 id="一-标准输入流-cin">一、标准输入流（cin）</h2><ul><li><p>预定义对象 <code>cin</code> 是 <code>iostream</code> 类的一个实例，<code>cin</code> 是 <code>C++</code> 的内置对象，而不是关键字。</p></li><li><p><code>cin</code> 对象附属到标准输入设备，通常是键盘。</p></li><li><p><code>cin</code> 需要与流提取运算符 <code>&gt;&gt;</code> 相结合使用。</p></li><li><p>流提取运算符 <code>&gt;&gt;</code> 在读入下一个输入项前会忽略前一项后面的空格，因此多个输入可以放置在同一行并使用空格分隔。</p></li><li><p><code>C++</code> 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入名字：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您的名字是：&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p><code>&gt;&gt;</code> 在同一个语句中可以被多次使用。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入名字和年龄：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name &gt;&gt; age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您的名字是：&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您的年龄是：&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二-标准输出流-cout">二、标准输出流（cout）</h2><ul><li>预定义的对象 <code>cout</code> 是 <code>iostream</code> 类的一个实例，<code>cout</code> 是 <code>C++</code> 的内置对象，而不是关键字。</li><li><code>cout</code> 对象附属到标准输出设备，通常是显示屏。</li><li><code>cout</code> 需要与流插入运算符 <code>&lt;&lt;</code> 相结合使用。</li><li><code>C++</code> 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 基本数据类型</title>
      <link href="/posts/cpp/02.html"/>
      <url>/posts/cpp/02.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-简介">一、简介</h2><ul><li><p><code>C++</code> 规定在创建一个变量或常量时，必须明确指定相应的数据类型，否则无法为变量分配内存。</p></li><li><p><code>C++</code> 内置了对许多不同数据类型的支持，这些被称为基本数据类型，又被称为基本类型或内置类型。</p></li><li><p>数据类型存在的意义即为变量分配适合的内存空间。</p></li><li><p>下表列出了 <code>7</code> 种最基本的 <code>C++</code> 数据类型：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">整型</td><td style="text-align:center"><code>int</code></td></tr><tr><td style="text-align:center">浮点型</td><td style="text-align:center"><code>float</code></td></tr><tr><td style="text-align:center">字符型</td><td style="text-align:center"><code>char</code></td></tr><tr><td style="text-align:center">双浮点型</td><td style="text-align:center"><code>double</code></td></tr><tr><td style="text-align:center">布尔型</td><td style="text-align:center"><code>bool</code></td></tr><tr><td style="text-align:center">无类型</td><td style="text-align:center"><code>void</code></td></tr><tr><td style="text-align:center">宽字符型</td><td style="text-align:center"><code>wchar_t</code></td></tr></tbody></table><ul><li><code>wchar_t</code> 的定义：<code>typedef short int wchar_t;</code>，因此 <code>wchar_t</code> 实际上的空间与 <code>short int</code> 相同。</li></ul></li><li><p>一些基本类型可以使用一个或多个类型修饰符进行修饰，然后成为新的数据类型，下表列出了 <code>7</code> 种修饰符：</p><table><thead><tr><th>修饰符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>signed</code></td><td>表示有符号类型（默认）</td><td><code>signed int x = -10;</code></td></tr><tr><td><code>unsigned</code></td><td>表示无符号类型</td><td><code>unsigned int y = 10;</code></td></tr><tr><td><code>short</code></td><td>表示短整型</td><td><code>short int z = 100;</code></td></tr><tr><td><code>long</code></td><td>表示长整型</td><td><code>long int a = 100000;</code></td></tr><tr><td><code>const</code></td><td>表示常量，值不可修改</td><td><code>const int b = 5;</code></td></tr><tr><td><code>volatile</code></td><td>表示变量可能被意外修改，禁止编译器优化</td><td><code>volatile int c = 10;</code></td></tr><tr><td><code>mutable</code></td><td>表示类成员可以在 <code>const</code> 对象中修改</td><td><code>mutable int counter;</code></td></tr></tbody></table><ul><li>默认情况下，<code>int</code>、<code>short</code>、<code>long</code> 都是带符号的，即 <code>signed</code>。</li></ul></li><li><p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>大小（字节）</th><th>范围/取值示例</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔类型，表示真或假</td><td><code>1</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>char</code></td><td>字符类型，通常用于存储 <code>ASCII</code> 字符</td><td><code>1</code></td><td><code>-128 ~ 127</code></td></tr><tr><td><code>unsigned char</code></td><td>无符号字符类型</td><td><code>1</code></td><td><code>0 ~ 255</code></td></tr><tr><td><code>wchar_t</code></td><td>宽字符类型，用于存储 <code>Unicode</code> 字符</td><td><code>Windows</code> 下 <code>2</code> ；<code>Linux</code> 下  <code>4</code></td><td>取决于操作系统</td></tr><tr><td><code>char16_t</code></td><td><code>16</code> 位 <code>Unicode</code> 字符类型（<code>C++11</code> 引入）</td><td><code>2</code></td><td><code>0 ~ 65,535</code></td></tr><tr><td><code>char32_t</code></td><td><code>32</code> 位 <code>Unicode</code> 字符类型（<code>C++11</code> 引入）</td><td><code>4</code></td><td><code>0 ~ 4,294,967,295</code></td></tr><tr><td><code>short</code>（<code>short int</code>）</td><td>短整型</td><td><code>2</code></td><td><code>-32,768 ~ 32,767</code></td></tr><tr><td><code>unsigned short</code></td><td>无符号短整型</td><td><code>2</code></td><td><code>0 ~ 65,535</code></td></tr><tr><td><code>int</code></td><td>整型</td><td><code>4</code></td><td><code>-2,147,483,648 ~ 2,147,483,647</code></td></tr><tr><td><code>unsigned int</code></td><td>无符号整型</td><td><code>4</code></td><td><code>0 ~ 4,294,967,295</code></td></tr><tr><td><code>long</code>（<code>long int</code>）</td><td>长整型</td><td><code>Windows</code> 下 <code>4</code> ；<code>Linux</code> 下 <code>4</code> 或 <code>8</code></td><td>取决于操作系统</td></tr><tr><td><code>unsigned long</code></td><td>无符号长整型</td><td><code>Windows</code> 下 <code>4</code> ；<code>Linux</code> 下 <code>4</code> 或 <code>8</code></td><td>取决于操作系统</td></tr><tr><td><code>long long</code></td><td>长长整型（<code>C++11</code> 引入）</td><td><code>8</code></td><td><code>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</code></td></tr><tr><td><code>unsigned long long</code></td><td>无符号长长整型（<code>C++11</code> 引入）</td><td><code>8</code></td><td><code>0 ~ 18,446,744,073,709,551,615</code></td></tr><tr><td><code>float</code></td><td>单精度浮点数</td><td><code>4</code></td><td>约 <code>±3.4e±38</code>（<code>6</code> ~ <code>7</code> 位有效数字）</td></tr><tr><td><code>double</code></td><td>双精度浮点数</td><td><code>8</code></td><td>约 <code>±1.7e±308</code>（<code>15</code> 位有效数字）</td></tr><tr><td><code>long double</code></td><td>扩展精度浮点数</td><td><code>8</code>、<code>10</code>、<code>12</code> 或 <code>16</code></td><td>取决于操作系统和编译器</td></tr></tbody></table></li></ul><h2 id="二-整数类型">二、整数类型</h2><h3 id="2-1-带符号整数类型">2.1 带符号整数类型</h3><table><thead><tr><th style="text-align:left">类型名称</th><th style="text-align:left">大小（字节）</th><th style="text-align:left">取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>char</code>（<code>signed char</code>）</td><td style="text-align:left"><code>1</code></td><td style="text-align:left"><code>-128</code>（-2^7^）~ <code>127</code>（2^7^-1）</td></tr><tr><td style="text-align:left"><code>short</code>（<code>short int</code>）</td><td style="text-align:left"><code>2</code></td><td style="text-align:left"><code>-32768</code>（-2^15^）~ <code>32767</code>（-2^15^-1）</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>4</code></td><td style="text-align:left"><code>-2,147,483,648</code>（-2^31^）~ <code>+2,147,483,647</code>（2^31^-1）</td></tr><tr><td style="text-align:left"><code>long</code>（<code>long int</code>）</td><td style="text-align:left"><code>4</code>（<code>Windows</code>）</td><td style="text-align:left"><code>-2,147,483,648</code>（-2^31^）~ <code>+2,147,483,647</code>（2^31^-1）</td></tr><tr><td style="text-align:left"><code>long long</code></td><td style="text-align:left"><code>8</code>（<code>Windows</code>）</td><td style="text-align:left"><code>-9,223,372,036,854,775,808</code>（-2^63^） ~ <code>9,223,372,036,854,775,807</code>（2^63^-1）</td></tr></tbody></table><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">111</span>;<span class="comment">// 输出 o</span></span><br><span class="line"><span class="type">short</span> s = <span class="number">11</span>;<span class="comment">// 输出 11</span></span><br><span class="line"><span class="type">int</span> inum = <span class="number">222</span>;<span class="comment">// 输出 222</span></span><br><span class="line"><span class="type">long</span> lnum = <span class="number">3333</span>;<span class="comment">// 输出 3333</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> llnum = <span class="number">44444</span>;<span class="comment">// 输出 44444</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-无符号的整数类型">2.2 无符号的整数类型</h3><ul><li>带符号整数类型前加上关键字 <code>unsigned</code> 即成为无符号整数类型。</li><li>无符号整数类型的取值范围宽度与带符号整数类型一致，只是将负数取值范围相应向右移动。</li></ul><table><thead><tr><th style="text-align:left">类型名称</th><th style="text-align:left">大小（字节）</th><th style="text-align:left">取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left"><code>1</code></td><td style="text-align:left"><code>0 ~ 255</code>（2^8^-1）</td></tr><tr><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left"><code>2</code></td><td style="text-align:left"><code>0 ~ 65,535</code>（2^16^-1）</td></tr><tr><td style="text-align:left"><code>unsigned int</code></td><td style="text-align:left"><code>4</code></td><td style="text-align:left"><code>0 ~ 4,294,967,295</code>（2^32^-1）</td></tr><tr><td style="text-align:left"><code>unsigned long</code></td><td style="text-align:left"><code>4</code>（<code>Windows</code>）</td><td style="text-align:left"><code>0 ~ 4,294,967,295</code>（2^32^-1）</td></tr><tr><td style="text-align:left"><code>unsigned long long</code></td><td style="text-align:left"><code>8</code>（<code>Windows</code>）</td><td style="text-align:left"><code>0</code> ~ <code>18446744073709551615</code>（2^64^-1）</td></tr></tbody></table><h3 id="2-3-c-标准库-climits">2.3 C++ 标准库 &lt;climits&gt;</h3><ul><li><code>&lt;climits&gt;</code> 是 <code>C++</code> 标准库中的一个头文件，提供了与整数类型相关的限制和特性。它定义了一组常量，描述了各种整数类型（如 <code>char</code>、<code>int</code>、<code>long</code> 等）的最小值、最大值和其他相关属性。这些常量来自 <code>C</code> 标准库的 <code>&lt;limits.h&gt;</code> 头文件。</li><li>使用 <code>&lt;climits&gt;</code> 库需要在文件开头引入：<code>#include&lt;climits&gt;</code></li></ul><h4 id="2-2-1-climits-提供的常量">2.2.1 &lt;climits&gt; 提供的常量</h4><ul><li><code>&lt;climits&gt;</code> 提供的常量描述了不同整数类型在特定平台上的特性。</li></ul><h5 id="1-字符类型-char">（1）字符类型 char</h5><ul><li><p><code>CHAR_BIT</code>：<code>char</code> 类型的位数（通常为 <code>8</code>）。</p></li><li><p><code>CHAR_MIN</code>：<code>char</code> 类型的最小值。</p></li><li><p><code>CHAR_MAX</code>：<code>char</code> 类型的最大值。</p></li><li><p><code>SCHAR_MIN</code>：有符号 <code>char</code> 类型的最小值。</p></li><li><p><code>SCHAR_MAX</code>：有符号 <code>char</code> 类型的最大值。</p></li><li><p><code>UCHAR_MAX</code>：无符号 <code>char</code> 类型的最大值。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char类型是&quot;</span> &lt;&lt; CHAR_BIT &lt;&lt; <span class="string">&quot;位&quot;</span> &lt;&lt; endl;<span class="comment">// char类型是8位</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char类型的最大值是：&quot;</span> &lt;&lt; CHAR_MAX &lt;&lt; endl;<span class="comment">// char类型的最大值是：127</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char类型的最小值是：&quot;</span> &lt;&lt; CHAR_MIN &lt;&lt; endl;<span class="comment">// char类型的最小值是：-128</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有符号char类型的最大值是：&quot;</span> &lt;&lt; SCHAR_MAX &lt;&lt; endl;<span class="comment">// 有符号char类型的最大值是：127</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有符号char类型的最小值是：&quot;</span> &lt;&lt; SCHAR_MIN &lt;&lt; endl;<span class="comment">// 有符号char类型的最小值是：-128</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无符号char类型的最大值是：&quot;</span> &lt;&lt; UCHAR_MAX &lt;&lt; endl;<span class="comment">// 无符号char类型的最大值是：255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-短整型-short">（2）短整型 short</h5><ul><li><p><code>SHRT_MIN</code>：<code>short</code> 类型的最小值。</p></li><li><p><code>SHRT_MAX</code>：<code>short</code> 类型的最大值。</p></li><li><p><code>USHRT_MAX</code>：无符号 <code>short</code> 类型的最大值。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short类型的最大值是：&quot;</span> &lt;&lt; SHRT_MAX &lt;&lt; endl;<span class="comment">// short类型的最大值是：32767</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short类型的最小值是：&quot;</span> &lt;&lt; SHRT_MIN &lt;&lt; endl;<span class="comment">// short类型的最小值是：-32768</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无符号short类型的最大值是：&quot;</span> &lt;&lt; USHRT_MAX &lt;&lt; endl;<span class="comment">// 无符号short类型的最大值是：65535</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-整型-int">（3）整型 int</h5><ul><li><p><code>INT_MIN</code>：<code>int</code> 类型的最小值。</p></li><li><p><code>INT_MAX</code>：<code>int</code> 类型的最大值。</p></li><li><p><code>UINT_MAX</code>：无符号 <code>int</code> 类型的最大值。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int类型的最大值是：&quot;</span> &lt;&lt; INT_MAX &lt;&lt; endl;<span class="comment">// int类型的最大值是：2147483647</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int类型的最小值是：&quot;</span> &lt;&lt; INT_MIN &lt;&lt; endl;<span class="comment">// int类型的最小值是：-2147483648</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无符号int类型的最大值是：&quot;</span> &lt;&lt; UINT_MAX &lt;&lt; endl;<span class="comment">// 无符号int类型的最大值是：4294967295</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-长整型-long-long-int">（4）长整型 long（long int）</h5><ul><li><p><code>LONG_MIN</code>：<code>long</code> 类型的最小值。</p></li><li><p><code>LONG_MAX</code>：<code>long</code> 类型的最大值。</p></li><li><p><code>ULONG_MAX</code>：无符号 <code>long</code> 类型的最大值。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long类型的最大值是：&quot;</span> &lt;&lt; LONG_MAX &lt;&lt; endl;<span class="comment">// long类型的最大值是：2147483647</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long类型的最小值是：&quot;</span> &lt;&lt; LONG_MIN &lt;&lt; endl;<span class="comment">// long类型的最小值是：-2147483648</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无符号long类型的最大值是：&quot;</span> &lt;&lt; ULONG_MAX &lt;&lt; endl;<span class="comment">// 无符号long类型的最大值是：4294967295</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-长长整型-long-long-long-long-int">（5）长长整型 long long（long long int）</h5><ul><li><p><code>LLONG_MIN</code>：<code>long long</code> 类型的最小值。</p></li><li><p><code>LLONG_MAX</code>：<code>long long</code> 类型的最大值。</p></li><li><p><code>ULLONG_MAX</code>：无符号 <code>long long</code> 类型的最大值。</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long类型的最大值是：&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; endl;<span class="comment">// long long类型的最大值是：9223372036854775807</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long类型的最小值是：&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt; endl;<span class="comment">// long long类型的最小值是：-9223372036854775808</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无符号long long类型的最大值是：&quot;</span> &lt;&lt; ULLONG_MAX &lt;&lt; endl;<span class="comment">// 无符号long long类型的最大值是：18446744073709551615</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-字符类型">三、字符类型</h2><ul><li><p>字符类型 <code>char</code> 仅占用 <code>1</code> 个字节，用于存储单个字符，例：字母和数字。</p></li><li><p><code>char</code> 类型可以接收单引号 <code>''</code> 包裹的 <strong>单个字符</strong> 或 <code>-128</code> ~ <code>127</code> 之间的数字。</p></li><li><p>字符型变量并不是把字符本身存放到内存中，而是将对应的 <code>ASCII</code> 字符集编码存入到内存中。</p></li><li><p><code>char</code> 类型接收数字后，当输出时会自动转成 <code>ASCII</code> 字符集对应的字符进行输出，负值为保留字符集，不同编译器显示不同。</p></li><li><p><code>ASCII</code> 字符集如下：</p><table><thead><tr><th style="text-align:left">ASCII值</th><th style="text-align:left">控制字符</th><th style="text-align:left">ASCII值</th><th style="text-align:left">控制字符</th><th style="text-align:left">ASCII值</th><th style="text-align:left">控制字符</th><th style="text-align:left">ASCII值</th><th style="text-align:left">控制字符</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">NUT</td><td style="text-align:left">32</td><td style="text-align:left">(space)</td><td style="text-align:left">64</td><td style="text-align:left">@</td><td style="text-align:left">96</td><td style="text-align:left">、</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">SOH</td><td style="text-align:left">33</td><td style="text-align:left">!</td><td style="text-align:left">65</td><td style="text-align:left">A</td><td style="text-align:left">97</td><td style="text-align:left">a</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">STX</td><td style="text-align:left">34</td><td style="text-align:left">&quot;</td><td style="text-align:left">66</td><td style="text-align:left">B</td><td style="text-align:left">98</td><td style="text-align:left">b</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">ETX</td><td style="text-align:left">35</td><td style="text-align:left">#</td><td style="text-align:left">67</td><td style="text-align:left">C</td><td style="text-align:left">99</td><td style="text-align:left">c</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">EOT</td><td style="text-align:left">36</td><td style="text-align:left">$</td><td style="text-align:left">68</td><td style="text-align:left">D</td><td style="text-align:left">100</td><td style="text-align:left">d</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">ENQ</td><td style="text-align:left">37</td><td style="text-align:left">%</td><td style="text-align:left">69</td><td style="text-align:left">E</td><td style="text-align:left">101</td><td style="text-align:left">e</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">ACK</td><td style="text-align:left">38</td><td style="text-align:left">&amp;</td><td style="text-align:left">70</td><td style="text-align:left">F</td><td style="text-align:left">102</td><td style="text-align:left">f</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">BEL</td><td style="text-align:left">39</td><td style="text-align:left">,</td><td style="text-align:left">71</td><td style="text-align:left">G</td><td style="text-align:left">103</td><td style="text-align:left">g</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">BS</td><td style="text-align:left">40</td><td style="text-align:left">(</td><td style="text-align:left">72</td><td style="text-align:left">H</td><td style="text-align:left">104</td><td style="text-align:left">h</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">HT</td><td style="text-align:left">41</td><td style="text-align:left">)</td><td style="text-align:left">73</td><td style="text-align:left">I</td><td style="text-align:left">105</td><td style="text-align:left">i</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">LF</td><td style="text-align:left">42</td><td style="text-align:left">*</td><td style="text-align:left">74</td><td style="text-align:left">J</td><td style="text-align:left">106</td><td style="text-align:left">j</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">VT</td><td style="text-align:left">43</td><td style="text-align:left">+</td><td style="text-align:left">75</td><td style="text-align:left">K</td><td style="text-align:left">107</td><td style="text-align:left">k</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">FF</td><td style="text-align:left">44</td><td style="text-align:left">,</td><td style="text-align:left">76</td><td style="text-align:left">L</td><td style="text-align:left">108</td><td style="text-align:left">l</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">CR</td><td style="text-align:left">45</td><td style="text-align:left">-</td><td style="text-align:left">77</td><td style="text-align:left">M</td><td style="text-align:left">109</td><td style="text-align:left">m</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">SO</td><td style="text-align:left">46</td><td style="text-align:left">.</td><td style="text-align:left">78</td><td style="text-align:left">N</td><td style="text-align:left">110</td><td style="text-align:left">n</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">SI</td><td style="text-align:left">47</td><td style="text-align:left">/</td><td style="text-align:left">79</td><td style="text-align:left">O</td><td style="text-align:left">111</td><td style="text-align:left">o</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">DLE</td><td style="text-align:left">48</td><td style="text-align:left">0</td><td style="text-align:left">80</td><td style="text-align:left">P</td><td style="text-align:left">112</td><td style="text-align:left">p</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">DCI</td><td style="text-align:left">49</td><td style="text-align:left">1</td><td style="text-align:left">81</td><td style="text-align:left">Q</td><td style="text-align:left">113</td><td style="text-align:left">q</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">DC2</td><td style="text-align:left">50</td><td style="text-align:left">2</td><td style="text-align:left">82</td><td style="text-align:left">R</td><td style="text-align:left">114</td><td style="text-align:left">r</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left">DC3</td><td style="text-align:left">51</td><td style="text-align:left">3</td><td style="text-align:left">83</td><td style="text-align:left">S</td><td style="text-align:left">115</td><td style="text-align:left">s</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left">DC4</td><td style="text-align:left">52</td><td style="text-align:left">4</td><td style="text-align:left">84</td><td style="text-align:left">T</td><td style="text-align:left">116</td><td style="text-align:left">t</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left">NAK</td><td style="text-align:left">53</td><td style="text-align:left">5</td><td style="text-align:left">85</td><td style="text-align:left">U</td><td style="text-align:left">117</td><td style="text-align:left">u</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left">SYN</td><td style="text-align:left">54</td><td style="text-align:left">6</td><td style="text-align:left">86</td><td style="text-align:left">V</td><td style="text-align:left">118</td><td style="text-align:left">v</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left">TB</td><td style="text-align:left">55</td><td style="text-align:left">7</td><td style="text-align:left">87</td><td style="text-align:left">W</td><td style="text-align:left">119</td><td style="text-align:left">w</td></tr><tr><td style="text-align:left">24</td><td style="text-align:left">CAN</td><td style="text-align:left">56</td><td style="text-align:left">8</td><td style="text-align:left">88</td><td style="text-align:left">X</td><td style="text-align:left">120</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left">EM</td><td style="text-align:left">57</td><td style="text-align:left">9</td><td style="text-align:left">89</td><td style="text-align:left">Y</td><td style="text-align:left">121</td><td style="text-align:left">y</td></tr><tr><td style="text-align:left">26</td><td style="text-align:left">SUB</td><td style="text-align:left">58</td><td style="text-align:left">:</td><td style="text-align:left">90</td><td style="text-align:left">Z</td><td style="text-align:left">122</td><td style="text-align:left">z</td></tr><tr><td style="text-align:left">27</td><td style="text-align:left">ESC</td><td style="text-align:left">59</td><td style="text-align:left">;</td><td style="text-align:left">91</td><td style="text-align:left">[</td><td style="text-align:left">123</td><td style="text-align:left">{</td></tr><tr><td style="text-align:left">28</td><td style="text-align:left">FS</td><td style="text-align:left">60</td><td style="text-align:left">&lt;</td><td style="text-align:left">92</td><td style="text-align:left">\</td><td style="text-align:left">124</td><td style="text-align:left">|</td></tr><tr><td style="text-align:left">29</td><td style="text-align:left">GS</td><td style="text-align:left">61</td><td style="text-align:left">=</td><td style="text-align:left">93</td><td style="text-align:left">]</td><td style="text-align:left">125</td><td style="text-align:left">}</td></tr><tr><td style="text-align:left">30</td><td style="text-align:left">RS</td><td style="text-align:left">62</td><td style="text-align:left">&gt;</td><td style="text-align:left">94</td><td style="text-align:left">^</td><td style="text-align:left">126</td><td style="text-align:left">`</td></tr><tr><td style="text-align:left">31</td><td style="text-align:left">US</td><td style="text-align:left">63</td><td style="text-align:left">?</td><td style="text-align:left">95</td><td style="text-align:left">_</td><td style="text-align:left">127</td><td style="text-align:left">DEL</td></tr></tbody></table><ul><li><code>ASCII</code> 字符集大致由以下两部分组成：<ul><li><code>ASCII</code> 非打印控制字符：<code>0</code> ~ <code>31</code> 为控制字符，查看或打印文档时不可见，用于控制像打印机等外部设备。</li><li><code>ASCII</code> 打印字符：<code>32</code> ~ <code>126</code> 为打印字符，能够在键盘上找到，查看或打印文档时会出现。</li></ul></li></ul></li><li><p>转义字符：<code>C++</code> 中定义了一些字母前加反斜杠 <code>\</code> 来表示常见的那些不能显示的 <code>ASCII</code> 字符，例：<code>\0</code>、<code>\t</code>、<code>\n</code>等，这些用 <code>\</code> 表示的字符被称为转义字符。常见转移字符如下表：</p><table><thead><tr><th>转义字符</th><th>意义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃(BEL)</td><td>007</td></tr><tr><td><code>\b</code></td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td><code>\f</code></td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td><code>\n</code></td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td><code>\r</code></td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td><code>\t</code></td><td>水平制表(HT) （跳到下一个TAB位置）<br /><code>\t</code> 默认占用 <code>8</code> 个空格，当 <code>\t</code> 前字符串超过 <code>8</code> 个字符时，<code>\t</code> 占用 <code>16</code> 个字符，以此类推。</td><td>009</td></tr><tr><td><code>\v</code></td><td>垂直制表(VT)</td><td>011</td></tr><tr><td><code>\\</code></td><td>代表一个反斜线字符 <code>\</code></td><td>092</td></tr><tr><td><code>\'</code></td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td><code>\&quot;</code></td><td>代表一个双引号字符</td><td>034</td></tr><tr><td><code>\?</code></td><td>代表一个问号</td><td>063</td></tr><tr><td><code>\0</code></td><td>空字符(NUL)</td><td>000</td></tr><tr><td><code>\ddd</code></td><td>1到3位八进制数所代表的任意字符</td><td>三位八进制</td></tr><tr><td><code>\xhh</code></td><td>十六进制所代表的任意字符</td><td>十六进制</td></tr></tbody></table></li></ul><h2 id="四-浮点数类型">四、浮点数类型</h2><table><thead><tr><th style="text-align:left">类型名称</th><th style="text-align:left">大小（字节）</th><th style="text-align:left">取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>float</code></td><td style="text-align:left"><code>4</code></td><td style="text-align:left">约 <code>±3.4e±38</code>（<code>6</code> ~ <code>7</code> 位有效数字）</td></tr><tr><td style="text-align:left"><code>double</code></td><td style="text-align:left"><code>8</code></td><td style="text-align:left">约 <code>±1.7e±308</code>（<code>15</code> 位有效数字）</td></tr><tr><td style="text-align:left"><code>long double</code></td><td style="text-align:left"><code>8</code>、<code>10</code>、<code>12</code> 或 <code>16</code></td><td style="text-align:left">取决于操作系统和编译器</td></tr></tbody></table><ul><li><p><code>C++</code> 中无明确标注的浮点数默认是 <code>double</code> 类型。</p></li><li><p>如果创建 <code>float</code> 类型数据，需要使用 <code>f</code> 或 <code>F</code> 后缀，如果不使用后缀，会发生隐式转换，即 <code>double</code> 类型转换为<code>float</code> 类型。</p></li><li><p>如果创建 <code>long double</code> 类型数据，需要使用 <code>l</code> 或 <code>L</code> 后缀，如果不使用后缀，会发生隐式转换，即 <code>double</code> 类型转换为<code>long double</code> 类型。</p></li><li><p><code>C++</code> 默认输出 <code>6</code> 位有效数字（含小数点前数字）。</p></li><li><p><code>C++</code> 有两种写入浮点数的方式：</p><ul><li>第一种使用标准的小数点符号，例：<code>3.1415926</code>。</li><li>第二种使用科学计数法表示，例：<code>2.22E5</code> 表示 <code>222000</code>。</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> numf = <span class="number">3.1415926f</span>;</span><br><span class="line"><span class="type">double</span> numd = <span class="number">2.22E5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> numld = <span class="number">2.222E10L</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long double占用&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; endl;<span class="comment">// long double占用8字节</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(numf).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">// float</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(numd).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">// double</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(numld).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">// long double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sizeof</code> 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小。<code>sizeof</code> 运算符还可用于获取类、结构、共用体和其他用户自定义数据类型的大小。语法：<code>sizeof (data type)</code></li><li><code>typeid</code>  是一个关键字，它用来获取一个表达式的类型信息。<code>typeid(expression).name()</code> 可以返回表达式的数据类型。</li></ul></li></ul><h2 id="五-布尔类型">五、布尔类型</h2><ul><li><p><code>C++</code> 的 <code>bool</code> 类型一般占用 <code>1</code> 个字节长度。</p></li><li><p><code>bool</code> 类型只有两个取值，<code>true</code>（真）和 <code>false</code>（假）。</p></li><li><p><code>C++</code> 中使用 <code>cout</code> 输出 <code>bool</code> 变量的值时还是用数字 <code>1</code> 和 <code>0</code> 表示，而不是 <code>true</code> 或 <code>false</code>。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;flag:&quot;</span> &lt;&lt; flag &lt;&lt; endl;<span class="comment">// 输出 flag:1</span></span><br></pre></td></tr></table></figure></li><li><p>字面量 <code>true</code> 和 <code>false</code> 可以自动类型转换为 <code>int</code> 类型，<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numtrue = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> numefalse = <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;numtrue:&quot;</span> &lt;&lt; numtrue &lt;&lt; endl;<span class="comment">// 输出 numtrue:1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;numefalse:&quot;</span> &lt;&lt; numefalse &lt;&lt; endl;<span class="comment">// 输出 numefalse:0</span></span><br></pre></td></tr></table></figure></li><li><p>任何数字或指针值都可以隐式转换为 <code>bool</code> 值，非零值转换为 <code>true</code>，零值转换为 <code>false</code>。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> num = <span class="number">1314</span>;</span><br><span class="line"><span class="type">bool</span> zer0 = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;<span class="comment">// num:1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;zer0:&quot;</span> &lt;&lt; zer0 &lt;&lt; endl;<span class="comment">// zer0:0</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 C++</title>
      <link href="/posts/cpp/01.html"/>
      <url>/posts/cpp/01.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、安装 Visual Studio 2022 IDE</h1><ul><li><p>进入官网 <a href="https://visualstudio.microsoft.com/zh-hans/vs/">https://visualstudio.microsoft.com/zh-hans/vs/</a> 下载相应版本。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/01.png" width=799/></div></li><li><p>开始安装</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/02.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/03.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/04.png" width=399/></div><ul><li>使用 <code>Visual Studio</code> 进行 <code>C++</code> 的开发，选择使用 <code>C++</code> 的桌面开发，设置全部下载后再安装，其他皆为默认。</li></ul><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/05.png" width=799/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/06.png" width=799/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/07.png" width=799/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/08.png" width=799/></div></li></ul><h1>二、使用 Visual Studio 创建第一个 C++ 项目 Helloworld</h1><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/09.png" width=520/></div><ul><li>打开 <code>Visual Studio 2022</code>，提示登录，这里我选择 <code>Skip and add accounts later</code> 跳过登录。</li></ul><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/10.png" width=520/></div><ul><li>根据个人喜好进行开发设置和主题设置。</li></ul><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/11.png" width=520/></div><ul><li><p>创建一个空项目 <code>Helloworld</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/12.png" width=666/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/13.png" width=666/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/14.png" width=666/></div></li><li><p><code>Visual Studio 2022 Pro</code>  产品密钥：<code>TD244-P4NB7-YQ6XK-Y8MMM-YWV2J</code></p></li><li><p>创建文件：右键源文件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 添加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 新建项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Helloworld.cpp</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/15.png" width=666/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/16.png" width=399/></div></li><li><p>向文件中写入以下代码并运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://gcore.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Cpp/01/17.png" width=399/></div><ul><li><p>接下来我们讲解一下上面这段程序：</p><ul><li><p><code>C++</code> 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <code>&lt;iostream&gt;</code>。</p></li><li><p>下一行 <code>using namespace std;</code> 告诉编译器使用 <code>std</code> 命名空间。命名空间是 <code>C++</code> 中一个相对新的概念。</p></li><li><p>下一行 <code>// main() 是程序开始执行的地方</code> 是一个单行注释。单行注释以 <code>//</code> 开头，在行末结束。</p></li><li><p>下一行 <code>int main()</code> 是主函数，程序从这里开始执行。</p></li><li><p>下一行 <code>cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</code> 会在屏幕上显示消息 <code>Hello World</code> 并换行。</p></li><li><p>下一行 <code>return 0;</code> 终止 <code>main</code> 函数，并向调用进程返回值 <code>0</code>。</p></li></ul></li></ul></li></ul><h1>三、C++ 基础入门</h1><h2 id="3-1-注释">3.1 注释</h2><ul><li><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码，注释中的所有字符会被 <code>C++</code> 编译器忽略。</p></li><li><p><code>C++</code> 支持 <strong>单行注释</strong> 和 <strong>多行注释</strong> 两种格式：</p><ul><li><p><strong>单行注释</strong>：</p><ul><li><p>格式：<code>// 描述信息</code></p></li><li><p>用法：放在一行代码的上方或末尾，对该行代码进行解释说明。</p></li></ul></li><li><p>注：在 <code>//</code> 注释内，<code>/*</code> 和 <code>*/</code> 字符没有特殊的含义。</p></li><li><p><strong>多行注释</strong>：</p><ul><li><p>格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>为了美观可以在每行前都加上 <code>*</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *多行注释</span><br><span class="line"> *多行注释</span><br><span class="line"> *多行注释</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用法：放在一段代码的上方，对该段代码整体进行解释说明。</p></li><li><p>注：</p><ul><li>在 <code>/*</code> 和 <code>*/</code> 注释内部，<code>//</code> 字符没有特殊的含义。</li><li>多行注释无法嵌套使用。</li></ul></li></ul></li></ul></li></ul><h2 id="3-2-c-分号">3.2 C++ 分号</h2><ul><li>在 <code>C++</code> 中，分号是语句结束符。也就是说，每个语句必须以分号结束，它表明一个逻辑实体的结束。因此，<code>C++</code> 中允许多条语句放置在同一行，但是不建议这样操作。</li></ul><h2 id="3-3-c-语句块">3.3 C++ 语句块</h2><ul><li><p>在 <code>C++</code> 中，语句块是一组使用大括号 <code>&#123;&#125;</code> 括起来的按逻辑连接的语句。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&#123;&#125;</code> 包裹的语句就是一个语句块。</li></ul></li></ul><h2 id="3-4-c-标识符">3.4 C++ 标识符</h2><ul><li><code>C++</code> 标识符是用来为变量、函数、类、模块，或任何其他用户自定义项目进行命名的。</li><li><code>C++</code> 规定了一些标识符命名的规则：<ul><li>标识符不能是关键字。</li><li>标识符只能由字母（<code>A~Z</code> 或 <code>a~z</code>）、数字（<code>0~9</code>）或下划线（<code>_</code>）组成。</li><li>标识符的首字符必须为字母或下划线。</li><li>标识符中的字母严格区分大小写。</li></ul></li></ul><h2 id="3-5-c-关键字">3.5 C++ 关键字</h2><ul><li><p>关键字，又名保留字，是 <code>C++</code> 中预先保留的单词（标识符），这些保留字不能作为常量名、变量名或其他标识符名称。</p></li><li><p><code>ISO C++98/03</code> 关键字共 <code>63</code> 个，如下表所示：</p><table><thead><tr><th style="text-align:center"><code>asm</code></th><th style="text-align:center"><code>do</code></th><th style="text-align:center"><code>if</code></th><th style="text-align:center"><code>return</code></th><th style="text-align:center"><code>typedef</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>auto</code></td><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>inline</code></td><td style="text-align:center"><code>short</code></td><td style="text-align:center"><code>typeid</code></td></tr><tr><td style="text-align:center"><code>bool</code></td><td style="text-align:center"><code>dynamic_cast</code></td><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>signed</code></td><td style="text-align:center"><code>typename</code></td></tr><tr><td style="text-align:center"><code>break</code></td><td style="text-align:center"><code>else</code></td><td style="text-align:center"><code>long</code></td><td style="text-align:center"><code>sizeof</code></td><td style="text-align:center"><code>union</code></td></tr><tr><td style="text-align:center"><code>case</code></td><td style="text-align:center"><code>enum</code></td><td style="text-align:center"><code>mutable</code></td><td style="text-align:center"><code>static</code></td><td style="text-align:center"><code>unsigned</code></td></tr><tr><td style="text-align:center"><code>catch</code></td><td style="text-align:center"><code>explicit</code></td><td style="text-align:center"><code>namespace</code></td><td style="text-align:center"><code>static_cast</code></td><td style="text-align:center"><code>using</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>export</code></td><td style="text-align:center"><code>new</code></td><td style="text-align:center"><code>struct</code></td><td style="text-align:center"><code>virtual</code></td></tr><tr><td style="text-align:center"><code>class</code></td><td style="text-align:center"><code>extern</code></td><td style="text-align:center"><code>operator</code></td><td style="text-align:center"><code>switch</code></td><td style="text-align:center"><code>void</code></td></tr><tr><td style="text-align:center"><code>const</code></td><td style="text-align:center"><code>false</code></td><td style="text-align:center"><code>private</code></td><td style="text-align:center"><code>template</code></td><td style="text-align:center"><code>volatile</code></td></tr><tr><td style="text-align:center"><code>const_cast</code></td><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>protected</code></td><td style="text-align:center"><code>this</code></td><td style="text-align:center"><code>wchar_t</code></td></tr><tr><td style="text-align:center"><code>continue</code></td><td style="text-align:center"><code>for</code></td><td style="text-align:center"><code>public</code></td><td style="text-align:center"><code>throw</code></td><td style="text-align:center"><code>while</code></td></tr><tr><td style="text-align:center"><code>default</code></td><td style="text-align:center"><code>friend</code></td><td style="text-align:center"><code>register</code></td><td style="text-align:center"><code>true</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>delete</code></td><td style="text-align:center"><code>goto</code></td><td style="text-align:center"><code>reinterpret_cast</code></td><td style="text-align:center"><code>try</code></td><td style="text-align:center"></td></tr></tbody></table></li></ul><h2 id="3-6-c-变量">3.6 C++ 变量</h2><h3 id="3-6-1-简介">3.6.1 简介</h3><ul><li>变量是 <code>C++</code> 程序可操作的 <strong>内存空间</strong> 的 <strong>别称</strong>，每个变量仅存储 <strong>特定类型</strong> 的数据。</li><li>每个变量都有一个基本类型来定义它可以存储的数据类型，每个基本类型都是一个唯一的类型名称，它是一个关键字。</li><li><code>C++</code> 也允许定义各种其他类型的变量，例：<strong>枚举</strong>、<strong>指针</strong>、<strong>数组</strong>、<strong>引用</strong>、<strong>数据结构</strong>、<strong>类</strong> 等，这将会在后续的章节中进行讲解。</li></ul><h3 id="3-6-2-变量的定义">3.6.2 变量的定义</h3><ul><li><p>变量的定义用于告诉编译器在何处创建变量的存储，以及如何创建变量的存储，还可以在声明的时候初始化（指定一个初始值 <code>value</code>）。</p><ul><li>注：若变量在定义时未初始化，在被使用前一定要初始化。</li></ul></li><li><p>格式：<code>type varname_1 [= value1], varname_2 [= value2], varname_3 [= value3], ...;</code></p><ul><li><code>type</code>：指定变量的数据类型。</li><li><code>varname</code>：自定义变量名，需要符合标识符命名规则。</li><li><code>value</code>：可选，指定变量初始化的值。</li></ul></li><li><p>可以同时定义多个 <strong>同类型</strong> 的变量。</p></li><li><p>在一个程序中，变量有且仅有一次定义。</p></li></ul><h3 id="3-6-3-变量的声明">3.6.3 变量的声明</h3><ul><li>变量的声明用于向编译器保证变量以给定的类型和名称形式存在，这样能够保证编译器继续下一步的编译。</li><li>格式：<code>extern type varname_1, varname_2, varname_3, ...;</code><ul><li><code>extern</code>：关键字，用于变量的声明。</li><li><code>type</code>：需要声明的变量的数据类型。</li><li><code>varname</code>：需要声明的变量的名称。</li><li>注：变量在声明时不需要赋值。</li></ul></li><li>变量的声明只在编译时有它的意义，在程序链接时需要实际定义的变量。</li><li>可以使用 <strong>extern</strong> 关键字在任何地方声明一次或多次变量，但该变量只能在某个文件、函数或代码块中被定义一次。</li><li>当使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序链接时是可用的），变量声明就显得非常有用。</li></ul><h3 id="3-6-4-变量的作用域">3.6.4 变量的作用域</h3><ul><li><p>一般来说有三个地方可以定义变量：</p><ul><li><p>在函数或一个代码块内部声明的变量，称为 <strong>局部变量</strong>。它们只能被函数内部或者代码块内部的语句使用。</p><ul><li>当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。</li></ul></li><li><p>在函数参数的定义中声明的变量，称为 <strong>形式参数</strong>。</p></li><li><p>在所有函数外部定义的变量（通常是在程序的头部），称为 <strong>全局变量</strong>。</p><ul><li><p>全局变量的值在程序的整个生命周期内都是有效的。</p></li><li><p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。</p></li><li><p>定义全局变量时，系统会自动初始化为下列值：</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">初始化默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>0</code></td></tr><tr><td style="text-align:left"><code>char</code></td><td style="text-align:left"><code>'\0'</code></td></tr><tr><td style="text-align:left"><code>float</code></td><td style="text-align:left"><code>0.0</code></td></tr><tr><td style="text-align:left"><code>double</code></td><td style="text-align:left"><code>0.0</code></td></tr><tr><td style="text-align:left"><code>pointer</code></td><td style="text-align:left"><code>NULL</code></td></tr></tbody></table></li></ul></li></ul></li><li><p>作用域是程序的一个区域，变量的作用域可以分为以下几种：</p><ul><li><p><strong>局部作用域</strong>：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。</p></li><li><p><strong>全局作用域</strong>：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。</p></li><li><p><strong>块作用域</strong>：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。</p></li><li><p><strong>类作用域</strong>：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。</p></li></ul></li><li><p><strong>注</strong>：如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。</p></li></ul><h2 id="3-7-c-常量">3.7 C++ 常量</h2><h3 id="3-7-1-宏常量">3.7.1 宏常量</h3><ul><li><code>C++</code> 可以使用 <code>#define</code> 来定义常量，格式：<code>#define 常量名 常量值</code>。</li><li>宏常量通常在文件最上方定义。</li></ul><h3 id="3-7-2-const-常量">3.7.2 const 常量</h3><ul><li><p><code>C++</code> 可以使用 <code>const</code> 关键字来定义常量，与定义变量的区别就是在变量定义之前加上 <code>const</code> 关键字。</p></li><li><p>格式：<code>const type identifier_1 = value1, identifier_2 = value2, identifier_3 = value3, ...;</code></p><ul><li><code>const</code>：关键字，用于常量的定义。</li><li><code>type</code>：指定常量的数据类型。</li><li><code>identifier</code>：自定义常量名，需要符合标识符命名规则，建议大写。</li><li><code>value</code>：指定常量的值，定义常量时就要指定。</li></ul></li><li><p>常量是 <strong>固定值</strong>，在程序执行期间不会改变。这些固定的值，又叫做 <strong>字面量</strong>。</p></li><li><p>除了使用 <code>const</code> 关键字来定义常量 ，<code>C++</code> 中还提供了在 <strong>文件开头</strong> 使用 <code>#define</code> 预处理器定义常量的形式：<code>#define identifier value</code></p><ul><li><code>#define</code>：宏定义，后续章节讲述。</li><li><code>identifier</code>：自定义常量名，需要符合标识符命名规则，建议大写。</li><li><code>value</code>：指定常量的值，定义常量时就要指定。注：常量名 <code>identifier</code> 和常量值 <code>value</code> 之间无需添加赋值符号 <code>=</code>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 面向对象编程（上）</title>
      <link href="/posts/python/python3/13.html"/>
      <url>/posts/python/python3/13.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、面向对象相关术语</h1><ul><li><p><strong>类</strong>：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所 <strong>共有的</strong> 属性和方法。<strong>对象是类的实例</strong>。</p></li><li><p><strong>实例对象</strong>：通过类创建出的实例。对象包括两个数据成员（类属性和实例属性）和方法。</p></li><li><p><strong>实例化</strong>：<strong>创建</strong> 一个类的 <strong>实例对象</strong> 的过程。</p></li><li><p><strong>属性</strong>：类中的所有变量都被称为属性。</p></li><li><p><strong>方法</strong>：类中的所有函数通常称为方法。不过，和函数所有不同的是，类方法至少要包含一个 <code>self</code> 参数。</p></li><li><p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p></li><li><p>方法重载：类中支持多个同名函数，但参数的个数或类型要不同，在调用的时候，解释器会根据参数的个数或者类型，调用相应的函数.</p></li><li><p>封装：将类的某些部分（属性、方法）隐藏起来，具有一定的保护作用，隐藏对象的属性和方法实现细节，仅对外提供公共的访问方式。</p></li><li><p>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</p></li><li><p>多态：多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）.</p></li></ul><h2 id="二-面向过程与面向对象">二、面向过程与面向对象</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>程序员从面向过程的 <strong>执行者</strong> 转化成了面向对象的 <strong>指挥者</strong>。</p><h3 id="2-1-面向过程编程-procedure-oriented-programming">2.1 面向过程编程（Procedure Oriented Programming）</h3><ul><li><p>面向过程编程是一种以过程为中心的编程思想，它首先分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，在使用时依次调用，是一种基础的顺序的思维方式。</p></li><li><p>面向过程编程主要关注 “<strong>怎么做</strong>”，强调的是功能行为，即完成任务的具体细节，以 <strong>函数</strong> 为最小单位。</p></li><li><p>面向过程编程的重心在 <strong>算法</strong>。尼古拉斯·沃斯：“算法 + 数据结构 = 程序”。</p></li><li><p>面向过程编程好处是开发的速度快，但由于整个程序耦合得非常紧，任何一个处理函数和数据都可能关联到其他地方，增加了后期修改和维护的难度（<strong>耦合度高</strong>，<strong>扩展力低</strong>）。</p></li></ul><h3 id="2-2-面向对象编程-object-oriented-programming">2.2 面向对象编程（Object Oriented Programming）</h3><ul><li><p>面向对象编程是按照人们认识客观世界的思维方式，采用基于 <strong>对象</strong>（<strong>实体</strong>）的概念，以对象为中心，以类和继承为构造机制，来认识、理解、刻画客观世界并设计、构建相应的软件系统。</p></li><li><p>面向对象编程主要关注 “<strong>谁来做</strong>”，强调的是具备了功能的对象，即完成任务的对象，以 <strong>类</strong> / <strong>对象</strong> 为最小单位。</p></li><li><p>面向对象编程更侧重于 <strong>数据结构</strong>。</p></li><li><p>面向对象编程方法直接把所有事物都当作独立的对象，处理问题过程中所思考的不再主要是怎样用算法来描述问题，而是直接考虑重现问题中 <strong>各个对象之间的关系</strong>。</p></li><li><p>面向对象编程中的类和继承是适应人们一般思维方式的描述范式，方法是允许作用于该类对象上的各种操作。这种对象、类、消息和方法的程序设计范式的基本点在于对象的 <strong>封装性</strong> 和类的 <strong>继承性</strong>。通过 <strong>封装</strong> 能将对象的定义和对象的实现分开，通过 <strong>继承</strong> 能体现类与类之间的关系，以及由此带来的 <strong>动态绑定</strong> 和实体的 <strong>多态性</strong>。</p></li><li><p>面向对象编程实现了代码的 <strong>高内聚</strong>（相关功能聚合） 和 <strong>低耦合</strong>（模块之间的关联度低）。。</p></li><li><p>面向对象编程具有以下优点：</p><ul><li><p><strong>可重用性</strong>：可重用性是面向对象编程的一个核心思想。通过类的继承性，共享公有属性，简化了对象、类的创建代码量，增加了代码的重用性，提高开发效率。另外，重用经过测试的代码还可以使产生额外错误的可能性达到最小。</p></li><li><p><strong>可扩展性</strong>：可扩展性是对现代应用软件提出的又一个重要要求。类的继承性使类能反映现实世界的层次结构，多态性反映了现实世界的复杂多样。类的继承性和多态性使得面向对象编程具有良好的可重用性和可扩展性。新的功能可以很容易地加入到系统中，便于程序的修改。</p></li><li><p><strong>可管理性</strong>：通过封装性能够将代码与其处理的数据结合，方便管理。</p></li></ul></li></ul><h2 id="三-类的定义">三、类的定义</h2><h3 id="3-1-语法格式">3.1 语法格式</h3><ul><li><p><code>Python</code> 中使用 <code>class</code> <strong>关键字</strong> 来定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    类属性（≥<span class="number">0</span> 个）</span><br><span class="line">    类方法（≥<span class="number">0</span> 个）</span><br></pre></td></tr></table></figure><ul><li><p>类名建议使用 <strong>大驼峰</strong> 格式命名（所有单词首字母大写，其余字母小写）。</p></li><li><p>类名后边括号中是它的父类，如果没有需要继承的父类，则默认继承 <code>object</code> 类（<code>object</code> 为 <code>Python</code> 所有类的默认父类）。<code>Python3</code> 可以省略 <code>(object)</code>，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    类属性（≥<span class="number">0</span> 个）</span><br><span class="line">    类方法（≥<span class="number">0</span> 个）</span><br></pre></td></tr></table></figure></li><li><p>类中的属性和方法不是必须的，且它们所在的位置是任意的，没有固定的前后顺序。</p><ul><li>如果一个类没有任何类属性和类方法，可以使用 <code>pass</code> 关键字作为类体。</li></ul></li><li><p>同属一个类的所有类属性和类方法，要保持统一的缩进格式，通常统一缩进 <code>4</code> 个空格。</p></li></ul></li></ul><h3 id="3-2-name-属性">3.2 __name__ 属性</h3><ul><li><p>当使用 <code>print</code> 函数直接打印类名时（例：<code>print(Person)</code>），输出为 <code>&lt;class '__main__.Person'&gt;</code>。这里的 <code>__main__</code> 与 <code>__name__</code> 属性有关。</p></li><li><p><code>__name__</code> 属性是一个变量，它的值取决于模块是如何运行的。</p><ul><li><p>当一个 <code>Python</code> 模块或包被导入（<code>import</code>）时，<code>__name__</code> 会被设为模块的名称。通常，这将是 <code>Python</code> 文件本身的名称去掉 <code>.py</code> 后缀。例：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.__name__)  <span class="comment"># math</span></span><br></pre></td></tr></table></figure></li><li><p>如果模块是在最高层级代码环境中执行的，则它的 <code>__name__</code> 会被设为字符串 <code>'__main__'</code>。</p></li><li><p>如果模块是包的组成部分，则 <code>__name__</code> 还将包含父包的路径。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> process</span><br><span class="line"><span class="built_in">print</span>(process.__name__)  <span class="comment"># concurrent.futures.process</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="四-类的对象">四、类的对象</h2><h3 id="4-1-实例对象的创建">4.1 实例对象的创建</h3><h4 id="4-1-1-概述">4.1.1 概述</h4><ul><li><p>实例对象的创建又称为 <strong>类的实例化</strong>，语法：<code>实例对象名 = 类名(参数)</code>。</p><ul><li><p>如果构造函数仅有一个 <code>self</code> 参数，我们无需为 <code>self</code> 传参。</p></li><li><p>如果构造函数有多个参数时，我们需要为构造函数传递参数，否则抛出异常 <code>TypeError: __init__() missing * required positional arguments</code>。</p></li></ul></li><li><p>每实例化一次类，就会返回一个新的实例对象。实例对象的 <strong>数据类型</strong> 就是所属的类。</p></li></ul><h4 id="4-1-2-实例化的过程">4.1.2 实例化的过程</h4><ul><li><p><code>__new__</code> 方法负责对象的 <strong>创建</strong>，而 <code>__init__</code> 方法负责对象的 <strong>初始化</strong>。</p></li><li><p><code>__new__</code> 方法是在我们 <strong>调用类名进行实例化时</strong> 自动调用的，<code>__init__</code> 方法是在这个类的每一次 <strong>实例化对象之后</strong> 自动调用的。</p></li></ul><h5 id="1-构造方法-new-cls-args-kwargs">（1）构造方法 __new__(cls, *args, **kwargs)</h5><ul><li><p>每一次实例化类时，<code>Python</code> <strong>首先调用</strong> 的是该类的 <strong>构造方法</strong> <code>__new__(cls, *args, **kwargs)</code>，用于 <strong>新建</strong> 该类的 <strong>实例</strong> <code>self</code> 并 <strong>返回</strong>。如果该类没有定义 <code>__new__</code> 方法，则去 <strong>父类</strong> 中依次查找，直到 <code>object</code> 类（<code>object</code> 类是所有类的基类），然后。</p><ul><li>参数 <code>cls</code> 就代表着要实例化的类，此参数在实例化时由 <code>Python</code> 解释器自动提供，后面的参数直接传递给 <code>__init__</code> 方法。</li><li>实例化传入的其他实参传递给形参 <code>*args</code> 和 <code>**kwargs</code>，然后 <code>__new__</code> 方法会根据形参 <code>cls</code> 接收到的那个类对象创建出一个对应的实例对象，并返回该对象。</li></ul></li><li><p><code>__new__</code> 方法可以是 <code>object</code> 的，也可以是自己 <strong>重写</strong> 的，重点是最后 <strong>必须</strong> 要 <code>return</code> 这个创建好的对象的引用。</p></li><li><p><code>__new__</code> 方法始终都是类的 <strong>静态方法</strong>，即使没有被加上静态方法装饰器。</p></li><li><p>如果要得到当前类的实例，<strong>必须</strong> 在当前类中的 <code>__new__</code> 方法语句中调用当前类的父类的 <code>__new__</code> 方法。事实上，如果当前类中没有重写 <code>__new__</code> 方法，<code>Python</code> 默认就是调用该类的直接父类的 <code>__new__</code> 方法来构造该类的实例。</p></li><li><p><code>__new__</code> 方法主要是当你继承一些不可变的 <code>class</code>（例：<code>int</code>、<code>str</code>、<code>tuple</code>）时， 提供给你一个自定义这些类的实例化过程的途径。</p></li></ul><h5 id="2-初始化方法-init-self-args-kwargs">（2）初始化方法 __init__(self, *args, **kwargs)</h5><ul><li><p>新建好实例对象后，类的 <strong>初始化方法</strong> <code>__init__(self, *args, **kwargs)</code> 会接收这个实例 <code>self</code> 作为自己的第一个参数，然后依次传入 <code>__new__</code> 方法中接收到的位置参数和关键字参数，对实例对象 <code>self</code> 进行初始化操作，即 <strong>定制实例属性</strong>。</p><ul><li><p><code>self</code> 只是一个参数名称，可以自定义修改。</p></li><li><p>如果当前类中没有定义 <code>__init__</code> 方法，<code>Python</code> 同样会去 <strong>父类</strong> 中依次查找，直到 <code>object</code> 类。</p></li></ul></li><li><p><code>__init__</code> 方法 <strong>不能有返回值</strong>，因为 <code>__new__</code> 方法中已经返回了一个实例对象 <code>self</code>。如果显式 <code>return</code> 了返回值，则抛出异常 <code>TypeError: __init__() should return None, not '***'</code>。</p></li><li><p>如果 <code>__new__</code> 方法 <strong>没有返回</strong> 当前类的实例，那么当前类的 <code>__init__</code> 方法 <strong>不会被调用</strong>。</p></li><li><p>如果 <code>__new__</code> 方法返回其他类的实例，那么会调用被返回的实例对象对应类的构造方法。</p></li><li><p><code>__new__</code> 方法可以决定是否要使用当前类的 <code>__init__</code> 方法，因为 <code>__new__</code> 可以调用其他类的构造方法或者直接返回别的对象来作为当前类的实例。</p></li></ul><h3 id="4-2-实例对象的使用">4.2 实例对象的使用</h3><ul><li><p>使用已创建好的实例对象，通过 <code>实例对象.变量名</code> 的格式访问或修改类中的实例属性。</p></li><li><p>使用已创建好的实例对象，通过 <code>实例对象.方法名(参数)</code> 的格式调用类中的方法。</p><ul><li>另一种方法调用的方式：将 <code>实例对象.方法名</code> 赋值给一个 <code>变量</code>，然后在变量后添加 <code>(参数)</code> 来调用，即 <code>变量(参数)</code>。</li></ul></li></ul><h2 id="五-类的成员">五、类的成员</h2><ul><li><p>定义类的时候，会创建属于类的作用域（局部作用域），类对象属于全局变量。</p><ul><li><p>类中的类属性、类方法、实例方法和变量等全部都会被定义好。</p><ul><li>方法同名时，后定义的会覆盖先定义的。</li></ul></li><li><p>方法中的属性、变量、嵌套的方法等此时没有被定义。</p></li></ul></li></ul><h3 id="5-1-方法">5.1 方法</h3><ul><li>方法就是定义在类中的函数。</li><li><strong>注</strong>：<strong>类中存在的同名方法</strong>，<strong>后定义的方法会覆盖先定义的方法</strong>。</li><li>类中的属性和方法是类定义时被定义好，实例属性在实例化对象时被定义好。</li></ul><h4 id="5-1-1-实例方法-对象方法">5.1.1 实例方法（对象方法）</h4><ul><li><p>在类中使用参数（通常 <code>self</code>）<strong>接收实例对象</strong> 的方法都被称为 <strong>实例方法</strong>，也称为对象方法。</p><ul><li>类的 <strong>初始化方法</strong> <code>__init__</code> 理论上也属于 <strong>实例方法</strong>，因此可以使用 <code>实例对象.__init__([实参列表])</code> 对其进行调用。</li></ul></li><li><p>定义实例方法的 <strong>格式</strong> 与定义函数的格式 <strong>类似</strong>，只是实例方法要求 <strong>至少要包含一个参数</strong>（通常使用 <code>self</code> 命名），用于 <code>Python</code> 自动 <strong>绑定</strong> 调用此方法的 <strong>实例对象</strong>。格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self[, 形参列表]</span>):</span><br><span class="line">    方法体 或 <span class="keyword">pass</span></span><br><span class="line">    [<span class="keyword">return</span> 返回值]</span><br></pre></td></tr></table></figure><ul><li><code>PyCharm</code> 中可以使用快捷 <code>Ctrl + P</code> 查看方法需要的参数。</li></ul></li><li><p>实例方法是一种 <strong>绑定方法</strong>，与实例对象（<code>self</code>）之间存在 <strong>绑定关系</strong>，与类本身没有绑定关系。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  stu = Student()</span><br><span class="line">  <span class="built_in">print</span>(stu.func)  <span class="comment"># &lt;bound method Student.func of &lt;__main__.Student object at 0x000001198D20D040&gt;&gt;</span></span><br><span class="line">  <span class="built_in">print</span>(Student.func)  <span class="comment"># &lt;function Student.func at 0x0000025FF44C8EE0&gt;</span></span><br><span class="line"></span><br><span class="line">  - 我们 **推荐** 使用类的实例对象 **直接调用** 实例方法，格式：`实例对象.方法名([实参列表])`。</span><br><span class="line">  </span><br><span class="line">  - `<span class="variable language_">self</span>` 参数不需要我们手动传递，`Python` 会自动将调用此方法的 **实例对象** 传递给 `<span class="variable language_">self</span>` 参数，即实例方法的第一个参数位隐式接收实例对象。</span><br><span class="line"></span><br><span class="line">- 在 `Python` 中也支持使用类名 **间接调用** 实例方法，格式：`类名.方法名(<span class="variable language_">self</span>，[实参列表])`。</span><br><span class="line"></span><br><span class="line">  - 需要 **手动** 为 `<span class="variable language_">self</span>` 参数传递调用此方法的 **实例对象**。</span><br><span class="line"></span><br><span class="line">- `Python` 允许为实例对象 **动态增加实例方法**：</span><br><span class="line"></span><br><span class="line">  - 方式 `<span class="number">1</span>`：直接将模块中定义的函数 **等号赋值**（`=`）给实例对象，这种方式 **无法正常创建绑定关系**。例：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">            <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">eat</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">            </span><br><span class="line">    stu = Student(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line">    stu.eat = eat</span><br><span class="line">    stu.eat()  <span class="comment"># eat</span></span><br><span class="line">    <span class="built_in">print</span>(stu.eat)  <span class="comment"># &lt;function eat at 0x00000179574B7310&gt;</span></span><br><span class="line"></span><br><span class="line">  - 方式 `<span class="number">2</span>`：使用 `types` 模块中的 `MethodType` 函数。</span><br><span class="line">  </span><br><span class="line">    - 格式：`MethodType(func, <span class="built_in">object</span>)`，可以将一个可调用对象 `func` 绑定到 `<span class="built_in">object</span>`（实例对象或类对象）上，形成绑定关系。例：</span><br><span class="line"></span><br><span class="line">      ```python</span><br><span class="line">      <span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">          <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">              <span class="variable language_">self</span>.name = name</span><br><span class="line">      </span><br><span class="line">          <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">      </span><br><span class="line">      stu = Student(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line">      stu.eat = MethodType(eat, stu)</span><br><span class="line">      stu.eat()  <span class="comment"># eat</span></span><br><span class="line">      <span class="built_in">print</span>(stu.eat)  <span class="comment"># &lt;bound method eat of &lt;__main__.Student object at 0x0000017EE11E7F40&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5.1.2 类方法</span></span><br><span class="line"></span><br><span class="line">- 在类中使用参数（通常 `cls`）**接收类本身**（不是实例对象），并且使用 `@<span class="built_in">classmethod</span>` 装饰器进行装饰的方法都被称为 **类方法**，</span><br><span class="line"></span><br><span class="line">- 类方法的 **定义格式** 与实例方法定义格式 **相似**，它也要至少包含一个参数（通常将其命名为 `cls`），用于 `Python` 自动绑定调用此方法的 **类本身**。并且类方法上方需要使用 `@<span class="built_in">classmethod</span>` 装饰器进行装饰。格式：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">cls[, 形参列表]</span>):</span><br><span class="line">      方法体 或 <span class="keyword">pass</span></span><br><span class="line">      [<span class="keyword">return</span> 返回值]</span><br></pre></td></tr></table></figure><ul><li>如果没有 <code>＠classmethod</code> 装饰器，<code>Python</code> 解释器会将类方法认定为实例方法。</li></ul></li><li><p>类方法是一种 <strong>绑定方法</strong>，与类对象（<code>cls</code>）之间存在 <strong>绑定关系</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line"><span class="meta">      @classmethod</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">cls</span>):</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(Student.func)  <span class="comment"># &lt;bound method Student.func of &lt;class &#x27;__main__.Student&#x27;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">- 我们 **推荐** 使用类名 **直接调用** 类方法，格式：`类对象.类方法([实参列表])`。</span><br><span class="line">  </span><br><span class="line">  - `cls` 参数不需要我们手动传递，`Python` 会自动将调用此方法的 **类对象** 传递给 `cls` 参数，即类方法的第一个参数位隐式接收类对象。</span><br><span class="line"></span><br><span class="line">- 在 `Python` 中也支持使用实例对象 **间接调用** 类方法，格式：`实例对象.类方法([实参列表])`。</span><br><span class="line">- 实例对象间接调用类方法同样不需要我们手动传递 `cls` 参数。</span><br><span class="line">  - `实例对象.类方法([实参列表])` 的本质：`<span class="built_in">type</span>(对象名).类方法([实参列表])`。</span><br><span class="line"></span><br><span class="line">- 类方法只能被类对象及实例与子类对象及实例调用。</span><br><span class="line"></span><br><span class="line">- `Python` 允许为类对象 **动态增加类方法**：方式与为实例对象动态增加实例方法相同。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5.1.3 静态方法</span></span><br><span class="line"></span><br><span class="line">- 静态方法没有类似 `<span class="variable language_">self</span>`、`cls` 这样的特殊参数，因此 `Python` 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</span><br><span class="line"></span><br><span class="line">- 定义静态方法的 **格式** 与定义普通函数 **完全一样**，只是静态方法被放进了类中并使用 `@<span class="built_in">staticmethod</span>` 装饰器进行装饰。格式：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">[形参列表]</span>):</span><br><span class="line">      方法体 或 <span class="keyword">pass</span></span><br><span class="line">      [<span class="keyword">return</span> 返回值]</span><br><span class="line"></span><br><span class="line">- 静态方法是一种 **非绑定方法**，不与类或对象绑定。</span><br><span class="line"></span><br><span class="line">- 静态方法的调用，既可以使用类对象：`类对象.静态方法([实参列表])`，也可以使用实例对象：`实例对象.静态方法([实参列表])`。</span><br><span class="line"></span><br><span class="line">- `@<span class="built_in">property</span>` 也是 `python` 的一种装饰器，是内置的属性装置器，被装饰的方法会变成只读属性。示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">all_attr</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>\t<span class="subst">&#123;self.age&#125;</span>\t<span class="subst">&#123;selt.grade&#125;</span>&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(stu.all_attr)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-4-魔术方法">5.1.4 魔术方法</h4><ul><li><p>在 <code>Python</code> 中，所有以双下划线 <code>__</code> 包起来的方法，统称为 <code>Magic Method</code>（魔术方法），它是一种 <strong>官方定义好</strong> 的特殊方法。</p></li><li><p>普通方法需要我们主动调用，而一般情况下我们不主动调用魔术方法，在 <strong>特定情况</strong> 下魔术方法会自动被调用。</p></li><li><p>魔术方法在类或对象的 <strong>某些事件触发</strong> 后会自动执行，让类具有神奇的 “魔力”。如果希望定制特殊功能的类，那么就需要对这些方法进行重写。</p><ul><li>注：事件触发条件也是官方定义好的。</li></ul></li><li><p><code>Python</code> 中常用的运算符、<code>for</code> 循环、以及类操作等都是运行在魔术方法之上的。</p></li></ul><h3 id="5-2-属性">5.2 属性</h3><h4 id="5-2-1-类属性">5.2.1 类属性</h4><ul><li><p><strong>类属性</strong>（类变量）：以 <code>属性名 = 属性值</code> 格式定义在 <strong>类体中</strong> 且在 <strong>方法体之外</strong> 的变量被称为类属性，类属性在所有实例化对象中是 <strong>共享</strong> 的，即类属性就是实例对象所 <strong>共有</strong> 的属性。</p><ul><li><p>类属性既可以使用 <strong>类名调用</strong>：<code>类名.类属性名</code>；也可以使用类的 <strong>实例对象调用</strong>：<code>实例对象.属性名</code>。<strong>推荐使用类名调用</strong>。</p><ul><li><code>实例对象.类属性名</code> 的本质：<code>type(对象名).类属性名</code></li></ul></li><li><p>当类属性的 <strong>值存在</strong> 时，使用 <code>类名.类属性名 = 类属性值</code> 相当于 <strong>修改类属性</strong>。</p></li><li><p>通过 <strong>类名</strong> 访问一个 <strong>不存在</strong> 的 <strong>类属性</strong> 时，就是为类和对象 <strong>动态增加类属性</strong>。</p></li><li><p>可以使用 <code>del</code> 关键字 <strong>动态删除类属性</strong>，格式：<code>del 类名.类属性名</code>。<strong>注</strong>：不能使用实例对象名删除类属性。</p></li><li><p>类属性为所有实例化对象共有，通过类名 <strong>修改类属性</strong> 的值，<strong>会影响</strong> 所有实例化对象。</p></li><li><p>通过类的实例化对象对类属性进行赋值，其本质不是修改类属性的值，而是为该对象定义新的实例属性，这种操作被称作 <strong>动态定义实例属性</strong>。</p></li></ul></li></ul><h4 id="5-2-2-实例属性">5.2.2 实例属性</h4><ul><li><p><strong>实例属性</strong>（实例变量）：以 <code>self.属性名 = 属性值</code> 格式定义在 <strong>方法体</strong> 中的变量被称为实例属性，实例属性需要使用 <code>self.</code> 访问，它只属于 <strong>调用方法</strong> 的实例对象，即实例属性是实例对象 <strong>特有的</strong>。</p><ul><li><p>实例属性只能通过对象名访问（<code>实例对象.属性名</code>），无法通过类名访问。</p></li><li><p>当实例属性的 <strong>值存在</strong> 时，使用 <code>实例对象.属性名 = 属性值</code> 相当于 <strong>修改属性</strong>。</p><ul><li>使用 <code>实例对象.__init__([实参列表])</code> 可以同时修改所有属性的值。</li></ul></li><li><p>通过 <strong>实例对象名</strong> 访问一个 <strong>不存在</strong> 的 <strong>实例属性</strong> 时，就是为实例对象 <strong>动态增加实例属性</strong>。每个实例之间新增的实例属性是互不干扰的。</p></li><li><p>当实例属性和类属性 <strong>同名</strong> 时，对象会 <strong>优先</strong> 调用 <strong>实例属性</strong>，而不是类属性（此时的类属性需要 <code>类名.属性名</code> 才可以访问）。</p></li><li><p>可以使用 <code>del</code> 关键字 <strong>动态删除实例属性</strong>，格式：<code>del 实例对象.属性名</code>。</p></li><li><p>通过对象 <strong>修改实例属性</strong> 的值，<strong>不会影响</strong> 同类的其它实例化对象，更不会影响同名的类属性。</p></li></ul></li></ul><h4 id="5-2-3-属性相关内置函数">5.2.3 属性相关内置函数</h4><h5 id="1-setattr">（1）setattr</h5><ul><li><p>格式：<code>setattr(object, name, value)</code>，<code>Python</code> 内置函数，可以为 <strong>类</strong> 或 <strong>实例对象</strong> <code>object</code> 的属性 <code>name</code> 设置属性值，其中 <code>name</code> 要求为 <strong>字符串形式</strong>，无返回值。例：<code>setattr(stu, &quot;age&quot;, 18)</code>。</p><ul><li><p><code>setattr(object, name, value)</code> 等价于 <code>object.name = value</code>。</p></li><li><p>如果 <strong>属性不存在</strong>，就是为类 / 实例对象动态 <strong>新增</strong> 类属性 / 实例属性。</p></li></ul></li></ul><h5 id="2-getattr">（2）getattr</h5><ul><li><p>格式：<code>getattr(object, name[, default])</code>，<code>Python</code> 内置函数，可以根据属性名 <code>name</code> <strong>返回</strong> 对应的属性值，其中 <code>name</code> 要求为 <strong>字符串形式</strong>。例：<code>getattr(stu, &quot;age&quot;)</code>。</p><ul><li><p><code>getattr(object, name)</code> 等价于 <code>object.name</code>。</p></li><li><p>如果属性不存在，返回默认值 <code>default</code>，如果没有指定 <code>default</code>，则抛出异常 <code>AttributeError: '***' object has no attribute '***'</code>。</p></li></ul></li></ul><h5 id="3-delattr">（3）delattr</h5><ul><li><p>格式：<code>delattr(object, name)</code>，<code>Python</code> 内置函数，用于删除 <strong>类</strong> 或 <strong>实例对象</strong> <code>object</code> 的属性 <code>name</code>，其中 <code>name</code> 要求为 <strong>字符串形式</strong>，无返回值。例：<code>delattr(stu, &quot;age&quot;)</code>。</p><ul><li><p><code>delattr(object, name)</code> 等价于 <code>del object.name</code>。</p></li><li><p>当 <code>name</code> 属性不存在时，<code>delattr</code> 函数会抛出异常 <code>AttributeError: ***</code>。</p></li></ul></li></ul><h5 id="4-hasattr">（4）hasattr</h5><ul><li><p>格式：<code>hasattr(object, name)</code>，<code>Python</code> 内置函数，用于判断 <strong>类</strong> 或 <strong>实例对象</strong> 是否拥有属性 <code>name</code>，其中 <code>name</code> 要求为 <strong>字符串形式</strong>。如果拥有属性则返回 <code>True</code>，否则返回 <code>False</code>。例：<code>hasattr(stu, &quot;age&quot;)</code>。</p><ul><li><code>hasattr</code> 函数是通过调用 <code>getattr</code> 函数，查看是否抛出 <code>AttributeError</code> 异常来实现的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 函数（下）</title>
      <link href="/posts/python/python3/11.html"/>
      <url>/posts/python/python3/11.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、封包、解包</h1><h2 id="1-1-封包-pack">1.1 封包（pack）</h2><ul><li><p>封包就是将多个元素合起来作为一个整体使用。</p></li><li><p><strong>将多个值赋值给一个变量时</strong>，<code>Python</code> <strong>会自动将这些值封装成元组</strong>，<strong>这个特性称之为封包</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(num)  <span class="comment"># (5, 6, 7, 8, 9)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(num, <span class="built_in">tuple</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p><strong>当函数的不定长参数接收多个参数值时</strong>，<code>Python</code> <strong>会自动进行封包</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">      <span class="built_in">print</span>(args)</span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">type</span>(args))</span><br><span class="line">      <span class="built_in">print</span>(kwargs)</span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">type</span>(kwargs))</span><br><span class="line">  </span><br><span class="line">  lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  func(lst, name=<span class="string">&quot;dong&quot;</span>, age=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">- **当函数返回多个值时**，`Python` **会自动进行封包**。例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  var = func()</span><br><span class="line">  <span class="built_in">print</span>(var)  <span class="comment"># (5, 6, 7, 8, 9)</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(var))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">isinstance</span>(var, <span class="built_in">tuple</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p>实际开发过程中，很少主动进行封包操作。</p></li></ul><h2 id="1-2-解包-unpack">1.2 解包（unpack）</h2><ul><li><p>解包就是将容器里面的元素逐个取出来使用。</p></li><li><p>可迭代对象都支持解包。</p><ul><li>可迭代对象：列表、元组、字典、集合、字符串、<code>range</code>、迭代器（<code>reversed</code>、<code>zip</code>、<code>enumerate</code>）等</li></ul></li></ul><h3 id="1-2-1-赋值多变量">1.2.1 赋值多变量</h3><h4 id="1-普通序列赋值">（1）普通序列赋值</h4><ul><li><p><strong>将一个可迭代对象赋值给多个变量时</strong>，<code>Python</code> <strong>会自动解包</strong>，将可迭代对象中的元素逐一赋值给每个变量，因此变量个数要与可迭代对象的元素数量相同，否则抛出异常 <code>ValueError: too many values to unpack</code> 或 <code>ValueError: not enough values to unpack</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">a, b, c = lst</span><br><span class="line"><span class="built_in">print</span>(a, b, c)  <span class="comment"># 5 6 7</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-增强序列赋值">（2）增强序列赋值</h4><ul><li><p>当我们就想 <strong>将元素数量大于变量个数的可迭代对象赋值给变量时</strong>，可以在其中一个变量前面加一个星号（<code>*</code>），代表这个变量可接收 <code>0</code> 个、<code>1</code> 个或多个元素，并把这些值组成一个 <strong>列表</strong>。</p></li><li><p>多个变量中不允许存在多个带星号（<code>*</code>）的变量。</p></li><li><p><strong>解包过程</strong>：首先将其他变量根据位置确定对应赋值的元素，剩下的元素组成一个 <strong>列表</strong> 赋值给带星号（<code>*</code>）的变量。</p></li><li><p>带星号（<code>*</code>）的变量与不定长参数 <code>*args</code> 不同：</p><ul><li><p><code>*</code> <strong>变量是不贪婪的</strong>，会先让其他变量赋值，剩余的值全部给<code>*</code> 变量，<code>*</code> 变量后面的变量能够被赋值。</p></li><li><p><strong>不定长参数</strong> <code>*args</code> <strong>是贪婪的</strong>，会将所有的实参值全部获取，<code>*args</code> 后面的参数不会被赋值。</p></li></ul></li><li><p>当仅为一个带星号（<code>*</code>）的变量赋值可迭代对象时，必须要在变量名后添加 <strong>逗号</strong>（<code>,</code>）。例：<code>*a, = [10]</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, *b, c, d = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)  <span class="comment"># 1 [3, 5, 7, 9, 2] 6 8</span></span><br><span class="line">a, b, *c, d = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)  <span class="comment"># 5 6 [] 7</span></span><br><span class="line">*a, b, c = (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)  <span class="comment"># [5] 2 7</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-接收函数返回值">（3）接收函数返回值</h4><ul><li><p>当函数返回多个值时，<code>Python</code> 会自动将多个值封包成一个元组，使用多个变量接收函数返回值时，<code>Python</code> 会自动解包，将元组中的元素逐一赋值给每个变量。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">  </span><br><span class="line">  a, *b, c = func()</span><br><span class="line">  <span class="built_in">print</span>(a, b, c)  <span class="comment"># 5 [6, 7, 8] 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 1.2.2 交换两个变量值</span></span><br><span class="line"></span><br><span class="line">- 在 `Python` 中，交换两个变量的值非常方便，本质上也是自动解包的过程。</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  a, b = <span class="number">6</span>, <span class="number">8</span></span><br><span class="line">  b, a = a, b</span><br><span class="line">  <span class="built_in">print</span>(a, b)  <span class="comment"># 8 6</span></span><br></pre></td></tr></table></figure><ul><li><code>b, a = a, b</code> 首先将 <code>a, b</code> 封包成为一个元组，然后赋值给 <code>b, a</code> 进行解包。</li></ul></li></ul><h3 id="1-2-3-遍历字典">1.2.3 遍历字典</h3><ul><li><p>字典的 <code>items</code> 方法可以返回字典中所有的键值对组成的列表，列表中的每一项都是一个元组。当我们使用 <code>for</code> 循环遍历字典，并用两个变量同时获取每次遍历出的元组时，<code>Python</code> 会自动解包。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">member_list = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;height&quot;</span>: <span class="number">177</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xin&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;height&quot;</span>: <span class="number">168</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;man&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;height&quot;</span>: <span class="number">179</span>&#125;]</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   name:dong, age:19, height:177,</span></span><br><span class="line"><span class="comment">#   name:xin, age:18, height:168,</span></span><br><span class="line"><span class="comment">#   name:man, age:20, height:179,</span></span><br><span class="line"><span class="keyword">for</span> member_d <span class="keyword">in</span> member_list:</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> member_d.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>:<span class="subst">&#123;v&#125;</span>, &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-4-和-解包运算符">1.2.4 * 和 ** 解包运算符</h3><ul><li><p>使用 <code>*</code> 可迭代解包运算符可以将可迭代对象解包成 <strong>位置参数</strong>，<code>**</code> 字典解包运算符可以将字典解包成 <strong>关键字参数</strong>，这种解包方式主要运用在函数传参的过程中。</p></li><li><p>示例 <code>1</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 封包</span></span><br><span class="line">      <span class="built_in">print</span>(args)  <span class="comment"># (5, 6, 7, 8, 9)</span></span><br><span class="line">      <span class="built_in">print</span>(*args)  <span class="comment"># 解包，输出：5 6 7 8 9</span></span><br><span class="line">      <span class="built_in">print</span>(kwargs)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line">      <span class="built_in">print</span>(*kwargs)  <span class="comment"># 解包，输出：name age</span></span><br><span class="line">      </span><br><span class="line">  lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  member = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line">  func(*lst, **member)  <span class="comment"># 解包</span></span><br><span class="line"></span><br><span class="line">- 示例 `<span class="number">2</span>`：利用字典解包运算符 `**` 合并两个字典。</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  dict_1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>&#125;</span><br><span class="line">  dict_2 = &#123;<span class="string">&quot;id&quot;</span>: <span class="number">12937728351568141336</span>&#125;</span><br><span class="line">  dict_3 = &#123;**dict_1, **dict_2&#125;</span><br><span class="line">  <span class="built_in">print</span>(dict_3)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;id&#x27;: 12937728351568141336&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、命名空间与作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.1 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.1.1 概述</span></span><br><span class="line"></span><br><span class="line">- 命名空间（`Namespace`）是从名称到对象的映射，大部分命名空间是通过 **字典** 来实现的（内置命名空间不是由字典实现，而是由 `builtins` 模块实现）。</span><br><span class="line"></span><br><span class="line">- **作用**：命名空间提供了一种在项目中避免名字冲突的方法。各个命名空间是独立的，没有任何关系的，所以同一个命名空间中不能有重名，但不同的命名空间可以重名且相互没有任何影响。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.1.2 分类</span></span><br><span class="line"></span><br><span class="line">- `Python` 命名空间可分为 `<span class="number">3</span>` 类，不同的命名空间也具有不同的生命周期。</span><br><span class="line"></span><br><span class="line">  &lt;div align=center&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/11/01.png&quot;</span> height=<span class="string">&quot;199&quot;</span>/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （1）内置命名空间（built-in names）</span></span><br><span class="line"></span><br><span class="line">- 内置命名空间是 `Python` 自带的命名空间，任何模块都可以访问，包含了像 `<span class="built_in">abs</span>()` 这样的内置函数（`function`）和 `BaseException` 这样的内置异常（`exception`）等。</span><br><span class="line"></span><br><span class="line">  - `builtins` 模块就是内置命名空间。使用下列代码即可查看 `builtins` 模块中的属性、方法、类型组成的列表。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    <span class="keyword">import</span> builtins</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">dir</span>(builtins))</span><br></pre></td></tr></table></figure></li><li><p>生命周期：内置命名空间在 <code>Python</code> 解释器启动时被创建，在解释器终止时被删除。</p></li></ul><h4 id="2-全局命名空间-global-names">（2）全局命名空间（global names）</h4><ul><li><p>全局命名空间记录了 <strong>模块</strong> 中定义的对象，包含模块中定义的函数、类、其他导入的模块、模块级的变量与常量。</p><ul><li>解释器会为程序中 <code>import</code> 加载的模块创建一个全局命名空间。</li></ul></li><li><p><code>globals()</code> 内置函数会以字典形式返回 <strong>当前模块</strong> 的 <strong>全局命名空间</strong>。</p></li><li><p>生命周期：一个模块的全局命名空间在这个模块被 <code>import</code> 的时候创建，并且模块的全局命名空间会一直存在，直到解释器终止。</p></li></ul><h4 id="3-局部命名空间-local-names">（3）局部命名空间（local names）</h4><ul><li><p>局部命名空间，也称为本地命名空间，是每个 <strong>函数</strong> 所拥有的命名空间，记录了函数中定义的所有变量，包括函数的入参、内部定义的局部变量。</p></li><li><p><code>locals()</code> 内置函数会以字典形式返回 <strong>当前函数</strong> 的 <strong>局部命名空间</strong>。该函数需要在函数内部调用。</p></li><li><p><code>locals()</code> 内置函数在函数外的使用效果等同于 <code>globals()</code> 内置函数。</p></li><li><p>生命周期：局部命名空间在一个函数被调用的时候创建。如果这个函数 <code>return</code> 或 <code>raise</code> 了一个不由该函数处理的异常，则该命名空间被删除。</p><ul><li><strong>注</strong>：每个递归调用都有它们自己的局部命名空间。</li></ul></li></ul><h3 id="2-1-3-命名空间查找-创建-销毁顺序">2.1.3 命名空间查找、创建、销毁顺序</h3><h4 id="1-命名空间查找顺序">（1）命名空间查找顺序</h4><ul><li><p>如果程序执行时使用一个变量 <code>var</code>，那么 <code>Python</code> 查找变量的顺序为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>局部的命名空间</mtext><mo>→</mo><mtext>全局命名空间</mtext><mo>→</mo><mtext>内置命名空间</mtext></mrow><annotation encoding="application/x-tex">局部的命名空间 \rightarrow 全局命名空间 \rightarrow 内置命名空间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">间</span></span></span></span></span></p></li><li><p>如果按照这个顺序找不到相应的变量，<code>Python</code> 将放弃查找并抛出异常：<code>NameError: name 'var' is not defined</code>。</p></li></ul><h4 id="2-命名空间创建顺序">（2）命名空间创建顺序</h4><ul><li><code>Python</code> 解释器启动 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 创建内置命名空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 加载模块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 创建全局命名空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 函数被调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 创建局部命名空间。</li></ul><h4 id="3-命名空间销毁顺序">（3）命名空间销毁顺序</h4><ul><li>函数调用结束 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 销毁函数对应的局部命名空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Python</code> 解释器终止 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 销毁全局命名空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 销毁内置命名空间。</li></ul><h3 id="2-1-4-相关内置函数">2.1.4 相关内置函数</h3><h4 id="1-eval">（1）eval</h4><ul><li><p>格式：<code>eval(expression[, globals[, locals]])</code>，用于执行一个字符串形式的表达式 <code>expression</code>，并 <strong>返回执行结果</strong>。</p><ul><li><p><code>expression</code>：字符串，内容为表达式。</p></li><li><p><code>globals</code>：字典，默认使用当前作用域的全局命名空间。</p></li><li><p><code>locals</code>：字典，默认使用当前作用域的局部命名空间。</p><ul><li>如果提供了 <code>globals</code> 参数，而 <code>locals</code> 参数被忽略，那么它将会取与 <code>globals</code> 相同的值。</li></ul></li></ul></li><li><p>如果 <code>globals</code> 与 <code>locals</code> 参数都为空，那么将遵循命名空间的查找顺序查找是否存在变量；如果提供了 <code>globals</code> 参数，而 <code>locals</code> 参数为空，则仅查找 <code>globals</code> 参数中是否存在变量；如果两个参数都不为空，先查找 <code>locals</code> 参数，再查找 <code>globals</code> 参数。如果在指定的命名空间中没有查找到相关变量，会抛出异常 <code>NameError: name 'xxx' is not defined</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">      a = <span class="number">3</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a + b&quot;</span>))  <span class="comment"># 5</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a + b&quot;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">5</span>&#125;))  <span class="comment"># 9</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a + b&quot;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">7</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">9</span>&#125;))  <span class="comment"># 17</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a + b&quot;</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">7</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">9</span>&#125;))  <span class="comment"># 15</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a + b&quot;</span>, <span class="literal">None</span>, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">9</span>&#125;))  <span class="comment"># 10</span></span><br><span class="line">  </span><br><span class="line">  func()</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （2）exec</span></span><br><span class="line"></span><br><span class="line">- 格式：`<span class="built_in">exec</span>(<span class="built_in">object</span>[, <span class="built_in">globals</span>[, <span class="built_in">locals</span>]])`，传入 `<span class="built_in">exec</span>` 函数的 `<span class="built_in">object</span>` 实参可以是 **字符串**，也可以是 **字节码对象**。通常 `<span class="built_in">exec</span>` 函数配合 `<span class="built_in">compile</span>` 函数来使用。**无返回值**。</span><br><span class="line"></span><br><span class="line">  - `<span class="built_in">object</span>` 可以是字符串或者字节码对象。</span><br><span class="line"></span><br><span class="line">    - 如果 `<span class="built_in">object</span>` 实参是字符串则会被 `<span class="built_in">exec</span>` 函数编译并执行。</span><br><span class="line"></span><br><span class="line">    - 如果是字节码对象则会被直接执行。</span><br><span class="line"></span><br><span class="line">  - `<span class="built_in">globals</span>`：字典，默认使用当前作用域的全局命名空间。</span><br><span class="line"></span><br><span class="line">  - `<span class="built_in">locals</span>`：字典，默认使用当前作用域的局部命名空间。</span><br><span class="line"></span><br><span class="line">- 如果 `<span class="built_in">globals</span>` 与 `<span class="built_in">locals</span>` 参数都为空，那么将遵循命名空间的查找顺</span><br><span class="line">序查找是否存在变量；如果提供了 `<span class="built_in">globals</span>` 参数，而 `<span class="built_in">locals</span>` 参数为空，则仅查找 `<span class="built_in">globals</span>` 参数中是否存在变量；如果两个参数都不为空，先查找 `<span class="built_in">locals</span>` 参数，再查找 `<span class="built_in">globals</span>` 参数。如果在指定的命名空间中没有查找到相关变量，会抛出异常 `NameError: name <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined`。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （3）eval 和 exec 区别</span></span><br><span class="line"></span><br><span class="line">- `<span class="built_in">eval</span>` 函数返回表达式执行后的结果，而 `<span class="built_in">exec</span>` 函数没有返回值。</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">eval</span>` 函数只能执行单个表达式，而 `<span class="built_in">exec</span>` 函数可以执行代码块。例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  str_exec = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  import random</span></span><br><span class="line"><span class="string">  for i in range(3):</span></span><br><span class="line"><span class="string">      num = random.randint(-10, 10)</span></span><br><span class="line"><span class="string">      if num &gt; 0:</span></span><br><span class="line"><span class="string">          print(pow(2, num))</span></span><br><span class="line"><span class="string">      else:</span></span><br><span class="line"><span class="string">          print(pow(2, num) * 100)</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="built_in">exec</span>(str_exec)</span><br><span class="line">  <span class="comment"># 25.0</span></span><br><span class="line">  <span class="comment"># 6.25</span></span><br><span class="line">  <span class="comment"># 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.2 作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.1 概述</span></span><br><span class="line"></span><br><span class="line">- `Python` 作用域就是一个程序可以直接访问命名空间的正文区域。</span><br><span class="line"></span><br><span class="line">- `Python` 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</span><br><span class="line"></span><br><span class="line">- 变量并不是在哪个位置都可以访问的，访问权限取决于这个变量是在哪里赋值的，也就是在哪个作用域内的。</span><br><span class="line"></span><br><span class="line">- 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。</span><br><span class="line"></span><br><span class="line">- 循环语句、条件语句都不会引入新的作用域，只有 **模块**、**类**、**函数**（`<span class="keyword">def</span>`、`<span class="keyword">lambda</span>`）和 **推导式** 会引入新的作用域。例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="comment"># 循环语句不会引入新的作用域</span></span><br><span class="line">  lst = []</span><br><span class="line">  <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">      lst.append(e ** <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(e)  <span class="comment"># 9</span></span><br><span class="line">  <span class="comment"># 推导式会引入新的作用域</span></span><br><span class="line">  lst = [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">  <span class="built_in">print</span>(i)  <span class="comment"># NameError: name &#x27;i&#x27; is not defined</span></span><br><span class="line">  <span class="comment"># 如果想使用推导式中的 i，可以 range(1, 10)[-1]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-分类">2.2.2 分类</h3><ul><li><code>Python</code> 的作用域一共有 <code>4</code> 种（<code>LEGB</code> 作用域）</li></ul><h4 id="1-l-local-局部作用域">（1）L（Local）局部作用域</h4><ul><li><p>最内层，包含局部变量，例：函数 / 方法内部。</p></li><li><p>在函数内部创建的变量属于该函数的局部作用域，并且只能在该函数内部使用。</p></li><li><p>默认情况下局部是无法修改全局变量的。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">  lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">      lst[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">      <span class="built_in">print</span>(lst)  <span class="comment"># [100, 2, 3]</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">id</span>(lst[<span class="number">0</span>]))  <span class="comment"># 140720425284496</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3]</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(lst[<span class="number">0</span>]))  <span class="comment"># 140720425281328</span></span><br><span class="line">  func()</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （2）E（Enclosing）闭包函数外函数作用域</span></span><br><span class="line"></span><br><span class="line">- **闭包函数** 外，外部函数内的作用域叫做 `Enclosing` 作用域。</span><br><span class="line"></span><br><span class="line">- 在一个外函数中定义了一个内函数，内函数中调用了外函数中定义的变量，并且外函数的返回值是内函数的引用，这样就构成了一个 **闭包函数**。例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">      name = <span class="string">&quot;dong&quot;</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">          <span class="built_in">print</span>(name)</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> inner</span><br><span class="line">  </span><br><span class="line">  outer()()  <span class="comment"># 输出：dong</span></span><br><span class="line">  </span><br><span class="line">  - `name = <span class="string">&quot;dong&quot;</span>` 和 `<span class="keyword">return</span> inner` 的作用域就是 `Enclosing` 作用域。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （3）G（Global）全局作用域</span></span><br><span class="line"></span><br><span class="line">- 模块文件中声明的变量，即模块级别的变量，具有全局作用域。</span><br><span class="line"></span><br><span class="line">- 模块的全局变量就是一个模块对象的属性，仅限于单个模块文件中。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （4）B （Built-in） 内置作用域</span></span><br><span class="line"></span><br><span class="line">- 系统内解释器定义的变量，例：预定义在 `builtin` 模块内的变量（定义在模块内、类和函数之外）。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.3 搜索顺序</span></span><br><span class="line"></span><br><span class="line">- `Python` 以 `L` $\rightarrow$ `E` $\rightarrow$ `G` $\rightarrow$ `B` 的搜索顺序查找变量，即：局部作用域搜索不到，便会去闭包函数外的函数中搜索，再搜索不到就会去全局作用域搜索，最后搭配内置作用域中搜索。如果所有作用域都搜索不到，就会抛出异常 `NameError: name <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined`。</span><br><span class="line"></span><br><span class="line">- `Python` 只会从当前作用域开始搜索，而且不会向更深层搜索。</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">      <span class="comment"># 因为局部作用域中定义了 a，所以就不会使用全局的 a</span></span><br><span class="line">      <span class="comment"># 局部先使用了 a：a * 10，后定义了 a：a = a * 10</span></span><br><span class="line">      <span class="comment"># 所以报错变量 a 在引用前还没有定义</span></span><br><span class="line">      a = a * <span class="number">10</span>  </span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># UnboundLocalError: local variable &#x27;a&#x27; referenced before assignment</span></span><br><span class="line">  func()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.4 全局变量和局部变量</span></span><br><span class="line"></span><br><span class="line">- 定义在函数内部的变量拥有一个局部作用域（`Local`），被叫做 **局部变量**。</span><br><span class="line"></span><br><span class="line">- 闭包函数外函数（`Enclosing`）包含了非局部（`non-local`）且非全局（`non-<span class="keyword">global</span>`）的变量。</span><br><span class="line"></span><br><span class="line">- 定义在函数外的拥有全局作用域（`Global`）的变量，被称为 **全局变量**。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.5 global 和 nonlocal 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### （1）global</span></span><br><span class="line"></span><br><span class="line">- 在普通函数中，虽然可以直接使用全局变量，但是不可以直接修改全局变量。从变量的作用域来说，一旦修改全局变量，那么 `Python` 就会创建并使用一个同名的局部变量。因此，如果需要在普通函数中修改全局变量，需要使用 `<span class="keyword">global</span>` 关键字指定当前变量使用的是外部的全局变量。示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">      <span class="keyword">global</span> a</span><br><span class="line">      a = a * <span class="number">10</span></span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(func())  <span class="comment"># 100</span></span><br><span class="line">  <span class="built_in">print</span>(a)  <span class="comment"># 100</span></span><br><span class="line"></span><br><span class="line">- `<span class="keyword">global</span>` 关键字可以用于局部作用域（`Local`）和闭包函数外函数（`Enclosing`）作用域。</span><br><span class="line"></span><br><span class="line">  - 示例 `<span class="number">1</span>`：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    num = <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        num *= <span class="number">111</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">            <span class="built_in">print</span>(num)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    </span><br><span class="line">    outer()()   <span class="comment"># 666</span></span><br></pre></td></tr></table></figure><ul><li><p>示例 <code>2</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">666</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    num = <span class="number">888</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        num += <span class="number">111</span></span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">outer()()<span class="comment"># 777</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>当 <code>global</code> 关键字指定的变量在全局作用域中未定义时，<code>Python</code> 会自动创建一个同名的全局变量。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">888</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">outer()()   <span class="comment"># 888</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-nonlocal">（2）nonlocal</h4><ul><li><p>如果你希望通过定义在内部的函数去修改其外部函数中的变量（非全局变量），那么需要使用 <code>nonlocal</code> 声明指定的变量不是局部变量。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">      num = <span class="number">888</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">          <span class="keyword">nonlocal</span> num</span><br><span class="line">          num += <span class="number">111</span></span><br><span class="line">          <span class="built_in">print</span>(num)</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> inner</span><br><span class="line">  </span><br><span class="line">  outer()()<span class="comment"># 999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三、常用高阶函数</span></span><br><span class="line"></span><br><span class="line">- 高阶函数就是参数或（和）返回值为函数的函数。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.1 filter</span></span><br><span class="line"></span><br><span class="line">- 格式：`<span class="built_in">filter</span>(function, iterable)`，`Python` 内置函数。</span><br><span class="line"></span><br><span class="line">- 功能：使用函数 `function` 对可迭代对象 `iterable` 中的数据进行过滤，将 `iterable` 中的每个元素作为参数传递给 `function`，根据返回结果进行判断，将判断为 `<span class="literal">True</span>` 的元素构建成新的迭代器并返回。</span><br><span class="line"></span><br><span class="line">- `function` 是必需参数，可以为仅接收一个实参的函数或 `<span class="literal">None</span>`。如果 `function` 为 `<span class="literal">None</span>`，直接判断 `iterable` 中的元素，将判断为 `<span class="literal">True</span>` 的元素构建成新的迭代器并返回。等价于 `<span class="built_in">filter</span>(<span class="built_in">bool</span>, iterable)`，即 `function` 设置成内置函数 `<span class="built_in">bool</span>()`。</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">filter</span>(function, iterable)` 相当于一个生成器表达式：</span><br><span class="line"></span><br><span class="line">  - 当 `function` 参数不为 `<span class="literal">None</span>` 时，等价于：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    (item <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> function(item))</span><br></pre></td></tr></table></figure><ul><li><p>当 <code>function</code> 为 <code>None</code> 时，等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(item <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> item)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>示例：</p><pre><code class="language-python">lst = [5, 2, 7, &quot;dong&quot;, None, 0, True, False, [], &#123;&quot;age&quot;: 18&#125;]# function 参数设置为 None，等价于 filter(bool, iterable)filter_lst = filter(None, lst)print(filter_lst)  # &lt;filter object at 0x000001B4BC221820&gt;print(list(filter_lst))  # [5, 2, 7, 'dong', True, &#123;'age': 18&#125;]# function 参数设置为内置函数 strfilter_lst = filter(str, lst)print(filter_lst)  # &lt;filter object at 0x000001B4BC2210A0&gt;print(list(filter_lst))  # [5, 2, 7, 'dong', None, 0, True, False, [], &#123;'age': 18&#125;]# function 参数设置为 lambda 表达式filter_lst = filter(lambda item: len(str(item)) &gt; 2, lst)print(filter_lst)  # &lt;filter object at 0x000001B4BC221820&gt;print(list(filter_lst))  # ['dong', None, True, False, &#123;'age': 18&#125;]# function 参数设置为自定义函数def func(item):  if isinstance(item, int):  # True 和 False 都是 int 类型，因为 bool 是 int 子类      return item - 2  elif item:      return len(item) &gt; 2  else:      return itemfilter_lst = filter(func, lst)print(filter_lst)  # &lt;filter object at 0x000001B4BC221160&gt;print(list(filter_lst))  # [5, 7, 'dong', 0, True, False]</code></pre></li></ul><h2 id="3-2-map">3.2 map</h2><ul><li><p>格式：<code>map(function, *iterables)</code>，<code>Python</code> 内置函数。</p></li><li><p>功能：将可迭代对象 <code>iterable</code> 中每一项作为参数调用函数 <code>function</code>，返回包含每次 <code>function</code> 函数返回值的迭代器。</p><ul><li><p><code>function</code>：函数，可以是 <code>lambda</code> 函数、内置函数、自定义函数等，参数个数要与 <code>iterable</code> 相同。</p></li><li><p><code>*iterables</code>：可迭代对象，不定长参数，当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就结束。</p></li></ul></li><li><p>示例：</p><pre><code class="language-python">lst = [5, 2, 7, 1, 9]tup = (2, 1, 9, 5, 8, 7)# function 设置为 lambda 表达式print(list(map(lambda x: x * 10, tup)))  # [20, 10, 90, 50, 80, 70]print(list(map(lambda x, y: x * y, tup, lst)))  # [10, 2, 63, 5, 72]# function 设置为内置函数print(list(map(bin, lst)))  # ['0b101', '0b10', '0b111', '0b1', '0b1001']print(list(map(min, tup, lst)))  # [2, 1, 7, 1, 8]# function 设置为自定义函数def func(param1, param2):  if param1 &gt; param2:      return pow(param1, param2) % 10  else:      return pow(param2, param1) % 10print(list(map(func, tup, lst)))  # [5, 2, 9, 5, 1]</code></pre></li></ul><h2 id="3-3-reduce">3.3 reduce</h2><ul><li><p>格式：<code>reduce(function, iterable[, initial])</code>，在 <code>Python2</code> 中 <code>reduce</code> 函数是内置函数，而在 <code>Python3</code> 中 <code>reduce</code> 函数被放置到 <code>functools</code> 模块中，所以在使用的时候需要引入 <code>functools</code> 模块来调用 <code>reduce</code> 函数：<code>from functools import reduce</code>。</p><ul><li><p><code>function</code>：必需参数，要求是能够接收两个实参的函数。</p></li><li><p><code>iterable</code>：必需参数，可迭代对象。</p></li><li><p><code>initial</code>：可选参数，初始值。</p></li></ul></li><li><p><code>reduce</code> 函数的执行流程是 ：在迭代 <code>iterable</code> 的过程中，首先把前两个元素（只能两个）传给函数，然后把函数执行得到的结果和第三个元素作为两个实参传给函数，函数执行后得到的结果又和第四个元素作为两个实参传给函数，依此类推，最终 <strong>返回一个函数计算结果</strong>。</p><ul><li><p>当指定 <code>initial</code> 参数时，先把 <code>initial</code> 值和 <code>iterable</code> 的第一个元素作为两个实参传给函数。</p></li><li><p>如果 <code>iterable</code> 为空，则函数返回 <code>initial</code>，如果 <code>initial</code> 没有指定则抛出异常 <code>TypeError: reduce() of empty sequence with no initial value</code>。</p></li><li><p>如果 <code>iterable</code> 只有一个元素且没有指定 <code>initial</code>，则返回该元素。</p></li></ul></li><li><p>示例：</p><pre><code class="language-python">from functools import reducetup = (2, 6, 9, 5, 2, 7)# function 设置为 lambda 表达式print(reduce(lambda x, y: x + y, tup))      # 31print(reduce(lambda x, y: x + y, tup, 100)) # 131# function 设置为内置函数print(reduce(max, tup))     # 9print(reduce(max, tup, 10)) # 10# function 设置为自定义函数def func(num1, num2):  return num1 if num1 &gt; num2 else num2print(reduce(func, tup))        # 9print(reduce(func, tup, 10))    # 10</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 函数（上）</title>
      <link href="/posts/python/python3/10.html"/>
      <url>/posts/python/python3/10.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、函数定义</h1><h2 id="1-1-函数简介">1.1 函数简介</h2><ul><li><p>函数是一段 <strong>封装好</strong> 的，<strong>可重复使用</strong> 的，用来实现单一或相关联功能的代码。</p></li><li><p>函数可以简化程序，清晰结构。</p></li><li><p>在类中定义的函数又被称为 <strong>方法</strong>。</p></li></ul><h2 id="1-2-函数定义的语法">1.2 函数定义的语法</h2><ul><li><p>语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">[形参列表]</span>):</span><br><span class="line">    函数体 或 <span class="keyword">pass</span></span><br><span class="line">    [<span class="keyword">return</span> 返回值]</span><br></pre></td></tr></table></figure><ul><li><p>关键字：</p><ul><li><p><code>def</code>：定义函数的关键字，所有函数都以此开头，后接函数名。</p></li><li><p><code>return</code>：结束函数，返回一个值给调用者，不填写返回值的 <code>return</code> 相当于返回 <code>None</code>，即 <code>return None</code>。</p></li><li><p><code>pass</code>：如果函数不做任何事情，或者函数体中的某些分支语句不做任何事情，可以使用 <code>pass</code> 语句用作占位语句，保持程序结构的完整性。</p></li></ul></li><li><p>函数名：一个符合 <code>Python</code> 语法的标识符，建议做到见名知意。</p></li><li><p>形参列表：形参列表中的参数用逗号 <code>,</code> 分开，声明了调用函数时需要传入的参数。如果函数不接收任何参数，参数列表就为空 <code>()</code>。</p></li><li><p>形参：形式参数，函数在定义时声明的参数。</p><ul><li>注：函数不需要参数，也要保留括号 “<code>()</code>”，否则 <code>Python</code> 解释器报错 “<code>invaild syntax</code>”。</li></ul></li><li><p>函数体：定义一个函数功能的所有代码组成的整体，以冒号 <code>:</code> 开头并缩进。第一行语句可以选择性地使用注释书写函数说明。</p><ul><li>注：可以使用 <code>pass</code> 定义空函数。</li></ul></li><li><p>返回值：函数是否具有返回值取决于关键字 <code>return</code>，使用 <code>return</code> 返回函数被调用后得出的结果，可以是表达式，也可以是变量，默认为 <code>return None</code>。</p><ul><li><code>return</code> 作用：<ul><li>将 <code>return</code> 后面跟着的对象返回给函数的调用方。</li><li>结束 <code>return</code> 语句所在的函数，即函数体中位于 <code>return</code> 后的语句不会被执行。</li></ul></li><li><strong>注</strong>：<code>Python</code> <strong>函数支持多返回值</strong>（<strong>封包</strong>）。</li></ul></li></ul></li><li><p>示例 <code>1</code>：计算长方形的面积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rectangleArea</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    该方法计算长方形的面积并返回</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> width * height</span><br></pre></td></tr></table></figure></li><li><p>示例 <code>2</code>：打印三角形图案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">triangle</span>(<span class="params">pattern, layer, reverse=<span class="literal">False</span></span>):</span><br><span class="line">    rg = <span class="built_in">range</span>(layer + <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>) <span class="keyword">if</span> reverse <span class="keyword">else</span> <span class="built_in">range</span>(<span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rg:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(pattern * (<span class="number">2</span> * i - <span class="number">1</span>)).center(<span class="number">2</span> * layer - <span class="number">1</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-文档字符串-docstrings">1.3 文档字符串（DocStrings）</h2><ul><li><p>文档字符串是一个重要工具，用于解释说明函数的功能与用法，是一个函数的使用说明书。</p></li><li><p>我们可以在函数体的 <strong>第一行</strong> 使用 <strong>一对</strong> 三个单引号 <code>'''</code> 或 <strong>一对</strong> 三个双引号 <code>&quot;&quot;&quot;</code> 来定义文档字符串。</p></li><li><p>文档字符串应该：</p><ul><li><p>包含函数做什么，而不是怎么做的。</p></li><li><p>让使用者不需要看一行代码，只需要看文档就可以。</p></li><li><p>包含输入和输出的详细描述。</p></li><li><p>对于复杂的代码可以在代码旁边加注释。</p></li><li><p>覆盖基类的方法可以加：<code>See base class</code></p></li></ul></li><li><p>在文档字符串中，应该根据不同的内容进行分组。文档字符串常用的分组：</p><ul><li><p><code>Args</code>：</p><ul><li><p>列出每个参数的名字，并在名字后使用一个冒号和一个空格，分隔对该参数的描述。</p></li><li><p>如果描述太长超过了单行 <code>80</code> 字符，使用 <code>2</code> 或 <code>4</code> 个空格的悬挂缩进（与文件其他部分保持一致）。</p></li><li><p>描述应该包括所需的类型和含义，如果一个函数接受 <code>*args</code>（元组可变长参数列表）或 <code>**bar</code>（字典可变长参数列表），应该详细列出 <code>*foo</code> 和 <code>**bar</code>。</p></li></ul></li><li><p><code>Returns</code>：（或 <code>Yields</code>：用于生成器）</p><ul><li>描述返回值的类型和含义。如果函数返回 <code>None</code>，这一部分可以省略。</li></ul></li><li><p><code>Raises</code>：</p><ul><li>列出与接口有关的所有异常。</li></ul></li></ul></li><li><p>通过调用 <code>Python</code> 的 <code>help()</code> <strong>内置函数</strong> 或 <code>__doc__</code> <strong>属性</strong>，我们可以查看某个函数的使用说明文档。</p><ul><li>示例：<code>help(rectangleArea)</code> 或 <code>rectangleArea.__doc__</code></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Determine whether the input is a non-negative integer</span></span><br><span class="line"><span class="string">    :return: Match input</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> (str_num := <span class="built_in">input</span>(<span class="string">&quot;请输入一个非负整数：&quot;</span>)).isdigit():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您的输入有误&quot;</span>, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str_num</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-4-类型标注">1.4 类型标注</h2><h3 id="1-4-1-概述">1.4.1 概述</h3><ul><li><p><code>Python</code> 属于动态类型语言，在创建数据时并不强制标注函数和变量类型，所以只有在运行代码的时候才能够知道变量类型。这通常会让我们在使用他人代码时传入错误的变量类型。为了解决这些问题，在 <code>Python 3.5</code> 中，<code>Python PEP 484</code> 引入了类型注解（<code>Type Hints</code>），在 <code>Python 3.6</code> 中，<code>PEP 526</code> 又进一步引入了变量注解（<code>Variable Annotations</code>）。</p><ul><li><code>PEP</code> 是 <code>Python Enhancement Proposals</code> 的缩写。一个 <code>PEP</code> 是一份为 <code>Python</code> 社区提供各种增强功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。</li></ul></li><li><p>基本内置类型的表述能力有限，不能说明复杂的类型组成情况，因此 <code>Python</code> 自 <code>3.5</code> 开始发布了 <code>typing</code> 包，为类型标注提供了支持，让我们能够更好的标注变量类型。</p></li><li><p>类型标注可被用于第三方工具，例：类型检查器、集成开发环境、静态检查器等。</p></li><li><p><code>Python</code> 对类型标注并 <strong>不强制</strong>，不按照类型标注传入变量也不会报错，仅会 <strong>警告</strong>，<code>PyCharm</code> 支持 <code>typing</code> 检查，错误时会出现黄色波浪线警告。</p></li><li><p>类型标注会以 <strong>字典</strong> 的形式存放在函数的 <code>__annotations__</code> 属性中。</p></li></ul><h3 id="1-4-2-语法格式">1.4.2 语法格式</h3><ul><li><p>变量类型：在变量名后加一个冒号 <code>:</code>，冒号后加变量的数据类型（例：<code>int</code>、<code>float</code>、<code>list</code>、<code>dict</code> 等）。</p></li><li><p>函数参数：和普通变量类型标注的语法格式没区别，都是冒号后加参数的数据类型。</p></li><li><p>函数返回类型：在形参列表的括号后加一个箭头 <code>-&gt;</code>，箭头后加返回值的类型，类型标注完成后加函数的冒号 <code>:</code>。</p></li><li><p>格式要求（<code>PEP 8</code>，非强制）：变量名和冒号之间无空格，冒号和数据类型之间加一个空格，箭头左右均有一个空格。</p></li></ul><h3 id="1-4-3-常用类型标注">1.4.3 常用类型标注</h3><h4 id="1-基本内置类型">1）基本内置类型</h4><ul><li><p><strong>常用</strong>：<code>int</code> 整型、<code>float</code> 浮点型、<code>bool</code> 布尔型、<code>str</code> 字符串类型。</p></li><li><p><code>Python</code> 中的内置类型（存放于 <code>builtins</code> <strong>模块</strong> 中）都可以用于类型标注。例：<code>int</code>、<code>float</code>、<code>bool</code>、<code>complex</code>、<code>str</code>、<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>range</code>、<code>reversed</code>、<code>zip</code> 等。</p></li></ul><h4 id="2-typing-模块提供的类型">2）typing 模块提供的类型</h4><ul><li><p>除了内置在 <code>builtins</code> 模块中的类型，<code>typing</code> 模块提供了更强大的类型支持。使用 <code>print(dir(typing))</code> 即可查看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typing</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(typing))</span><br></pre></td></tr></table></figure></li><li><p><code>typing</code> 模块中常用的类型：<code>List</code> 列表、<code>Tuple</code> 元组、<code>Dict</code> 字典、<code>Set</code> 集合、<code>Iterable</code> 可迭代类型、<code>Iterator</code> 迭代器类型、<code>Generator</code> 生成器类型。</p><ul><li><p><strong>注</strong>：使用 <code>typing</code> 模块中的类型，需要提前导入。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Dict</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="1-容器类型">（1）容器类型</h5><ul><li><p><code>Python</code> 中，可包含其他对象的对象，称之为 “容器”。容器是一种 <strong>数据结构</strong>。常用的容器主要划分为两种：<strong>序列</strong>（例：列表、元祖等）和 <strong>映射</strong>（例：字典）。</p></li><li><p>列表、元组、字典和集合等包含元素的容器，用简单的 <code>list</code>，<code>dict</code>，<code>tuple</code>和 <code>set</code> 不能够明确说明内部元素的具体类型。</p></li><li><p><code>List</code> <strong>列表</strong> 是 <code>list</code> 的泛型，其后紧跟一个方括号 <code>[]</code>，方括号中是构成这个列表的元素类型。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line">lst1: <span class="type">List</span>[<span class="built_in">int</span>] = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">lst2: <span class="type">List</span>[<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">float</span> <span class="keyword">or</span> <span class="built_in">str</span>] = [<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;dong&quot;</span>]  <span class="comment"># 使用 or 关键字表示列表可以接收多种类型</span></span><br></pre></td></tr></table></figure></li><li><p><code>Tuple</code> <strong>元组</strong> 是 <code>tuple</code> 的泛型，其后紧跟一个方括号 <code>[]</code>，方括号中按顺序声明了构成本元组的元素类型。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line">tup1: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>] = (<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;dong&quot;</span>)  <span class="comment"># 表示构成元组的三个元素的类型按顺序是 int、float 和 str</span></span><br><span class="line">tup2: <span class="type">Tuple</span>[<span class="built_in">int</span>, ...] = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)  <span class="comment"># 表示元组由多个 int 类型的元素构成</span></span><br><span class="line">tup3: <span class="type">Tuple</span>[<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">float</span> <span class="keyword">or</span> <span class="built_in">str</span>, ...] = (<span class="number">3.14</span>, <span class="string">&quot;dong&quot;</span>, <span class="number">7</span>)  <span class="comment"># 表示由多个 int、float 或 str 类型的元素构成</span></span><br></pre></td></tr></table></figure></li><li><p><code>Set</code> <strong>集合</strong> 是 <code>set</code> 的泛型，<code>AbstractSet</code> 是 <code>collections.abc.Set</code> 的泛型，其后紧跟一个方括号 <code>[]</code>，方括号中是构成这个集合的元素类型。<code>Set</code> 推荐用于标注函数返回类型，<code>AbstractSet</code> 用于标注参数。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Set</span></span><br><span class="line">set1: <span class="type">Set</span>[<span class="built_in">int</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">set2: <span class="type">Set</span>[<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">float</span> <span class="keyword">or</span> <span class="built_in">str</span>] = &#123;<span class="number">3.14</span>, <span class="string">&quot;dong&quot;</span>, <span class="number">7</span>&#125;  <span class="comment"># 使用 or 关键字表示集合可以接收多种类型</span></span><br></pre></td></tr></table></figure></li><li><p>由于 <strong>字典</strong> 是有 <code>key</code> 和 <code>value</code> 的，因此需要在方括号 <code>[]</code> 中同时对两者进行类型标注，中间使用用逗号 <code>,</code> 分隔。</p><ul><li><p>字典 <code>Dict</code> 是 <code>dict</code> 的泛型，主要用于标注返回类型。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line">    </span><br><span class="line">    stu = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;sid&quot;</span>: <span class="number">88888</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_person</span>(<span class="params">sid: <span class="built_in">int</span></span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> sid == stu.get(<span class="string">&quot;sid&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: stu.get(<span class="string">&quot;name&quot;</span>), <span class="string">&quot;age&quot;</span>: stu.get(<span class="string">&quot;age&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line">  - 映射 `Mapping` 是 `collections.abc.Mapping` 的泛型，主要用于注解参数。例：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    <span class="keyword">from</span> typing <span class="keyword">import</span> Mapping</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_person</span>(<span class="params">person: Mapping[<span class="built_in">str</span>, <span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        person_88 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> person.items():</span><br><span class="line">            person_88[k] = v</span><br><span class="line">        <span class="keyword">return</span> <span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### （2）Any 类型</span></span><br><span class="line"></span><br><span class="line">- `<span class="type">Any</span>` 是一种特殊的类型，它可以表示 **所有类型**，类型检查器认为所有类型均与 `<span class="type">Any</span>` 兼容，`Python` 中所有无明显类型标注的地方，都默认是 `<span class="type">Any</span>` 类型。例：`num = <span class="number">7</span>` 与 `num: <span class="type">Any</span> = <span class="number">7</span>` 等价。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （3）Union 类型</span></span><br><span class="line"></span><br><span class="line">- `<span class="type">Union</span>` 联合类型的语法格式：`<span class="type">Union</span>[X, Y]`，相当于 `X | Y`，即并集，意思是类型是 `X` 或 `Y`，效果与关键字 `<span class="keyword">or</span>` 等同。例：`lst: <span class="type">List</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>]] = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="string">&quot;xin&quot;</span>, <span class="number">6.25</span>]`</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （4）Optional 类型</span></span><br><span class="line"></span><br><span class="line">- `<span class="type">Optional</span>` 是指这个参数可以为空或是已经声明的类型，即 `<span class="type">Optional</span>[X]` 等价于 `<span class="type">Union</span>[X, <span class="literal">None</span>]`。</span><br><span class="line"></span><br><span class="line">- `<span class="type">Optional</span>` 并不等价于可选参数，当它作为参数类型标注的时候，不意味着这个参数可以不传递了，而是说这个参数可以传为 `<span class="literal">None</span>`。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （5）Sequence 类型</span></span><br><span class="line"></span><br><span class="line">- `<span class="type">Sequence</span>` 是 `collections.abc.<span class="type">Sequence</span>` 的泛型，在某些情况下，我们可能并不需要严格区分一个变量或参数到底是列表 `<span class="built_in">list</span>` 类型还是元组 `<span class="built_in">tuple</span>` 类型，我们可以使用一个更为泛化的类型，叫做 `<span class="type">Sequence</span>`。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （6）Callable 类型</span></span><br><span class="line"></span><br><span class="line">- `<span class="type">Callable</span>` 表示可调用类型，格式：`<span class="type">Callable</span>[[ArgsType], ReturnType]`，如果只指定可调用类型的返回值类型，则可以使用 `<span class="type">Callable</span>[..., ReturnType]` 的形式。</span><br><span class="line"></span><br><span class="line">  - `Python` 中有 `<span class="number">7</span>` 种可调用对象：内置函数（例：`<span class="built_in">isinstance</span>()`）、内置方法（例：`<span class="built_in">list</span>.append()`）、自定义函数、生成器函数、类的方法、类本身、类的实例。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （7）Iterator 类型</span></span><br><span class="line"></span><br><span class="line">- `Iterator` 表示迭代器类型，迭代器属于可迭代对象，可迭代对象都构建了 `__iter__` 方法，迭代器还需构建 `__next__` 方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （8）Generator 类型</span></span><br><span class="line"></span><br><span class="line">- `Generator` 表示生成器类型，Generator[YieldType、SendType、ReturnType]</span><br><span class="line"></span><br><span class="line">- 生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义 `__iter__` 方法和 `__next__` 方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （9）Iterable 类型</span></span><br><span class="line"></span><br><span class="line">- `Iterable` 表示可迭代类型，`collections.abc.Iterator` 的泛型版本，例：字符串、列表、元组、集合、字典等都属于可迭代对象。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.1 函数调用</span></span><br><span class="line"></span><br><span class="line">- 函数在定义时，不会执行函数体，函数调用也就是执行函数体，可以在一个函数中调用其他函数。</span><br><span class="line"></span><br><span class="line">- 函数只需要定义一次，可以被多次调用。</span><br><span class="line"></span><br><span class="line">- 函数调用的基本语法格式：`[返回值] = 函数名([实参列表])`</span><br><span class="line"></span><br><span class="line">  - 返回值：如果调用的函数存在返回值，我们可以通过一个变量来接收，也可以不接收。</span><br><span class="line">  </span><br><span class="line">  - 函数名：要调用的函数的名称。</span><br><span class="line">  </span><br><span class="line">  - 实参列表：创建函数时要求传入的各个形参的值。实参数量与形参数量要保持一致。</span><br><span class="line">  </span><br><span class="line">- 示例：`area = rectangleArea(<span class="number">6</span>, <span class="number">8</span>)`</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.2 参数传递</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.1 形参 VS 实参</span></span><br><span class="line"></span><br><span class="line">- 形参（形式参数）：在定义函数时，函数名后面括号中的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。</span><br><span class="line"></span><br><span class="line">- 实参（实际参数）：在调用函数时，函数名后面括号中的参数包含了真实存在的数据，会被函数内部的函数体使用，所以称为实际参数，简称实参。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.2 可变类型 VS 不可变类型</span></span><br><span class="line"></span><br><span class="line">- 可变类型（可变数据类型）：当该数据类型对应的变量的 **值发生变化** 时，如果变量的 **内存地址不发生改变**，那么这个变量对应的数据类型就是 **可变数据类型**。</span><br><span class="line"></span><br><span class="line">  - `<span class="built_in">list</span>`（列表）、`<span class="built_in">dict</span>`（字典）、`<span class="built_in">set</span>`（集合）</span><br><span class="line">  </span><br><span class="line">- 不可变类型（不可变数据类型）：当该数据类型对应的变量的 **值发生变化** 时，如果变量的 **内存地址发生改变**，那么这个变量对应的数据类型就是 **不可变数据类型**。</span><br><span class="line"></span><br><span class="line">  - `numbers` （数值类型）、`string`（字符串）、`<span class="built_in">tuple</span>`（元组）。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.3 传递方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### （1）值传递</span></span><br><span class="line"></span><br><span class="line">- 在调用函数时将实参的 **值** 复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实参。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （2）引用传递</span></span><br><span class="line"></span><br><span class="line">- 在调用函数时将实参的 **地址** 传递到函数中，那么在函数中对参数所进行的修改，将影响到实参。</span><br><span class="line"></span><br><span class="line">  - **函数** 的 **引用** 表示函数存储在内存中的地址。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （3）python 参数传递方式</span></span><br><span class="line"></span><br><span class="line">- 在 `python` 中，**一切皆对象**，数字、字符串、元组、列表、字典、函数、方法、类、模块等都是对象，所以参数传递时，只是让新变量与原变量 **指向相同的对象** 而已，并不存在值传递或是引用传递一说。准确地说，`Python` 的参数传递是 **赋值传递**，或者叫作 **对象的引用传递**。</span><br><span class="line"></span><br><span class="line">  - 如果函数收到的是一个 **可变对象**（例：列表、字典、集合等）的引用，就能修改对象的原始值，相当于 “引用传递”。</span><br><span class="line"></span><br><span class="line">  - 如果函数收到的是一个 **不可变对象**（例：数字、字符串、元组等）的引用，就不能直接修改原始对象，相当于 “值传递”。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2.4 参数类别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### （1）位置参数（必需参数）</span></span><br><span class="line"></span><br><span class="line">- 调用函数时，按照传递的实际参数的 **位置** 识别对应的形式参数。</span><br><span class="line"></span><br><span class="line">  - 在调用函数时，传递的实际参数的数量必须和形式参数的 **数量** 一致，否则会抛出 `TypeError` 异常。</span><br><span class="line"></span><br><span class="line">  - 在调用函数时，传递的实际参数的位置必须和形式参数的 **位置** 一致，否则会抛出 `TypeError` 异常（数据类型不一致）或得到错误的结果。</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x, y</span>):</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">  total = fun(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(total)<span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-关键字参数">（2）关键字参数</h4><ul><li><p>调用函数时，按照传递的实际参数的 <strong>名字</strong> 识别 <strong>同名</strong> 的形式参数。</p><ul><li>通过此方式指定函数实参时，不再需要与形参的位置完全一致，只需 <strong>参数名对应</strong> 即可。</li><li>在调用函数时，可以同时使用位置参数和关键字参数，但是 <strong>位置参数必须放在关键字参数之前</strong>。</li></ul></li><li><p><strong>关键字参数针对实参</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">total = fun(y=<span class="number">1</span>, x=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(total)<span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-默认参数">（3）默认参数</h4><ul><li><p><code>Python</code> 允许为形式参数设置默认值，即在定义函数时，直接为形式参数指定一个默认值。</p><ul><li><p>语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">..., 形参名, 形参名 = 默认值</span>):</span><br><span class="line">  函数体 或 <span class="keyword">pass</span></span><br><span class="line">  [<span class="keyword">return</span> 返回值]</span><br></pre></td></tr></table></figure></li><li><p>默认参数不能写在位置参数之前，也不能写在 <code>**kwargs</code> 之后。</p></li><li><p>使用 “<code>函数名.__defaults__</code>” 可以查看函数的默认参数所具有的默认值。</p><ul><li>注：<code>函数名.__defaults__</code> 返回的是一个元组。</li></ul></li></ul></li><li><p><strong>默认参数针对形参</strong>。</p></li><li><p><strong>注</strong>：<strong>不建议使用可变数据作为默认参数</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x=<span class="number">10</span>, y=<span class="number">20</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">total = fun()</span><br><span class="line"><span class="built_in">print</span>(total)<span class="comment"># 30</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-不定长参数">（4）不定长参数</h4><ul><li><p><code>*args</code>：可以接收 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, +\infty]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">]</span></span></span></span> 个 <strong>位置参数</strong>，将参数打包成 <strong>元组</strong> 给函数体调用，没有值传给它，就是个空元组 <code>()</code>。</p><ul><li><strong>注</strong>：<code>*args</code> 不能放到位置参数之前。</li></ul></li><li><p><code>**kwargs</code>：可以接收 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, +\infty]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">]</span></span></span></span> 个 <strong>关键字参数</strong>，将参数打包成 <strong>字典</strong> 给函数体调用，没有值传给它，就是个空字典 <code>&#123;&#125;</code>。</p><ul><li><strong>注</strong>：<code>**kwargs</code> 要放到形参列表的最后末尾。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">10</span>, *c, **d</span>):</span><br><span class="line">      <span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line">      <span class="built_in">print</span>(b)  <span class="comment"># 2</span></span><br><span class="line">      <span class="built_in">print</span>(c)  <span class="comment"># (3, 4, 5)</span></span><br><span class="line">      <span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;k1&#x27;: 6, &#x27;k2&#x27;: 7, &#x27;k3&#x27;: 8&#125;</span></span><br><span class="line">  </span><br><span class="line">  func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, k1=<span class="number">6</span>, k2=<span class="number">7</span>, k3=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### （5）特殊参数</span></span><br><span class="line"></span><br><span class="line">- 默认情况下，函数的参数传递形式可以是位置参数或显式的关键字参数。</span><br><span class="line"></span><br><span class="line">- 在 `python3<span class="number">.8</span>` 之后函数参数中允许出现 `/` 和 `*` 号。</span><br><span class="line"></span><br><span class="line">  - `/` 用来指明在它 **之前** 的参数必须以 **位置参数** 的形式传入。</span><br><span class="line">  </span><br><span class="line">  - `*` 用来指明在它 **之后** 的参数必须以 **关键字参数** 的形式传入。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三、lambda 表达式（匿名函数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.1 概述</span></span><br><span class="line"></span><br><span class="line">- `<span class="keyword">lambda</span>` 表达式，又称匿名函数，常用来表示内部仅包含 `<span class="number">1</span>` 行表达式的函数。</span><br><span class="line"></span><br><span class="line">- `<span class="keyword">lambda</span>` 表达式的语法格式：`<span class="keyword">lambda</span> [arg1[, arg2, ..., argN]] : expression`。</span><br><span class="line">  - 定义 `<span class="keyword">lambda</span>` 表达式，必须使用 `<span class="keyword">lambda</span>` 关键字。</span><br><span class="line"></span><br><span class="line">  - 参数 `[arg1[, arg2, ..., argN]]` 可以有 `<span class="number">0</span>` 或多个, 但是后面的 `expression` 只能有一个。</span><br><span class="line"></span><br><span class="line">  - `<span class="keyword">lambda</span>` 表达式的 **返回值** 就是 `expression` 的结果，而不需要 `<span class="keyword">return</span>` 语句。</span><br><span class="line"></span><br><span class="line">- 匿名函数的调用格式：`(<span class="keyword">lambda</span> [arg1[, arg2, ..., argN]] : expression)([实参<span class="number">1</span>[, 实参<span class="number">2</span>, ..., 实参N])`。</span><br><span class="line">- 匿名函数可以在需要函数对象的任何地方使用（例：赋值给变量、作为参数传入其他函数等），因为匿名函数可以作为一个表达式，而不是一个结构化的代码块。</span><br><span class="line"></span><br><span class="line">- 不推荐把 `<span class="keyword">lambda</span>` 表达式赋给另一个变量，再通过变量调用函数这种方式。因为 `<span class="keyword">lambda</span>` 表达式本就是一个匿名的函数，赋值给变量再调用就失去了匿名的意义。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.2 应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 3.2.1 lambda 作为一个参数传递</span></span><br><span class="line"></span><br><span class="line">- 可以把 `<span class="keyword">lambda</span>` 表达式作为参数传递给自定义函数。例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">lam_f, x, y, z</span>):</span><br><span class="line">      num = <span class="built_in">pow</span>(x, y)</span><br><span class="line">      <span class="keyword">return</span> lam_f(num, z)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(func(<span class="keyword">lambda</span> a, b: <span class="built_in">divmod</span>(a, b), <span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>))  <span class="comment"># (25, 6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 3.2.2 lambda 与 Python 内置函数配合使用</span></span><br><span class="line"></span><br><span class="line">- 可以把 `<span class="keyword">lambda</span>` 表达式作为参数传入其他内置函数。例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  member_list = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;height&quot;</span>: <span class="number">177</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xin&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;height&quot;</span>: <span class="number">168</span>&#125;,</span><br><span class="line">                 &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;man&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;height&quot;</span>: <span class="number">179</span>&#125;]</span><br><span class="line">  new_list = <span class="built_in">sorted</span>(member_list, key=<span class="keyword">lambda</span> mem_d: mem_d[<span class="string">&quot;height&quot;</span>])</span><br><span class="line">  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;xin&#x27;, &#x27;age&#x27;: 18, &#x27;height&#x27;: 168&#125;,</span></span><br><span class="line">  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 19, &#x27;height&#x27;: 177&#125;,</span></span><br><span class="line">  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;man&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 179&#125;]</span></span><br><span class="line">  <span class="built_in">print</span>(new_list)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-3-lambda-作为函数的返回值">3.2.3 lambda 作为函数的返回值</h3><ul><li><p><code>lambda</code> 表达式可以作为一个函数的返回值。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> c: <span class="built_in">divmod</span>(a ** b, c)</span><br><span class="line"></span><br><span class="line">fc = func(<span class="number">2</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(fc(<span class="number">5</span>))  <span class="comment"># (25, 3)</span></span><br></pre></td></tr></table></figure><ul><li><code>func</code> 返回的是一个匿名函数，使用 <code>fc</code> 接收函数对象，当我们执行匿名函数对象 <code>fc</code> 时，可以得到 <code>lambda</code> 的结果。</li></ul></li></ul><h1>四、常用内置函数</h1><h2 id="4-1-help">4.1 help</h2><ul><li><p>格式：<code>help([object])</code>，用于 <strong>打印</strong> 指定对象 <code>object</code> 的 <strong>帮助文档</strong>。如果不指定任何参数，则进入交互式帮助模式。</p><ul><li><p>在交互式帮助模式下，可以输入任何 <code>Python</code> 语句或表达式，程序会返回它们的帮助信息。使用 <code>quit</code> 命令可以退出交互式帮助模式。</p></li><li><p>如果实参是一个字符串，则在 <code>Python</code> 系统中搜索该字符串内容所对应的对象，并在控制台上打印帮助信息。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">help</span>(<span class="built_in">abs</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 4.2 abs</span></span><br><span class="line"></span><br><span class="line">- 格式：`<span class="built_in">abs</span>(x)`，用于返回一个数 `x` 的绝对值。`x` 可以是 `<span class="built_in">int</span>`，`<span class="built_in">float</span>`，`<span class="built_in">complex</span>` 或实现了 `__abs__` 方法的对象。</span><br><span class="line"></span><br><span class="line">  - 如果 `x` 是一个复数，则返回它的模，即实部与虚部平方和的正平方根。</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">1</span>))  <span class="comment"># 1</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">abs</span>(<span class="number">6</span> + <span class="number">8j</span>))  <span class="comment"># 10.0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-divmod">4.3 divmod</h2><ul><li><p>格式：<code>divmod(divident, divisor)</code>，用于返回包含参数 <code>divident</code> 除以参数 <code>divisor</code> 的商和余数的元组，即 <code>(divident // divisor, divident % divisor)</code>。</p><ul><li><code>divident</code>，<code>divisor</code> 可以为 <code>int</code> 或 <code>float</code> 类型。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quo, rem = <span class="built_in">divmod</span>(<span class="number">79</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;商：<span class="subst">&#123;quo&#125;</span>，余：<span class="subst">&#123;rem&#125;</span>&quot;</span>)  <span class="comment"># 商：3，余：19</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-4-max">4.4 max</h2><ul><li><p>格式：<code>max(iterable, *[, default=obj, key=func])</code> 或 <code>max(arg1, arg2, *args[, key])</code>，返回可迭代对象中最大的元素或者返回多个实参中的最大值。</p><ul><li><p>如果 <code>max</code> 函数只传入了一个位置参数，那么使用的是 <code>max(iterable, *[, default=obj, key=func])</code> 这个函数，因此实参必须是可迭代对象，<code>max</code> 函数返回可迭代对象中最大的元素。</p><ul><li><p>当可迭代对象为空时，如果没有指定 <code>default</code> 默认值，则抛出异常 <code>ValueError: max() arg is an empty sequence</code>。</p></li><li><p>如果传入了多个位置参数，则使用的是 <code>max(arg1, arg2, *args[, key])</code> 这个函数，返回多个实参中的最大值。</p></li><li><p>当传入的参数为数据类型不一致时，传入的所有参数将进行隐式数据类型转换后再比较，如果不能进行隐式数据类型转换，则会报错。</p></li><li><p>关键字参数 <code>key</code> 可以接收一个函数，用来指定获取最大值的方法。</p></li></ul></li></ul></li><li><p><code>Python</code> 中比较大小通常指的是元素的大小比较：</p><ul><li><p>数字类型（<code>int</code>、<code>float</code> 等）：按 <strong>数值</strong> 大小比较。</p></li><li><p>字符串类型（<code>str</code>）：按 <strong>字典序</strong> 比较，即从左到右依次比较每个字符的 <code>ASCII</code> 码值大小。</p></li><li><p>序列类型（<code>list</code>、<code>tuple</code>）：从左到右依次比较 <strong>每个元素</strong> 的大小，如果有一个元素不相等，则返回比较结果，否则继续比较后面的元素。</p><ul><li>如果 <strong>序列长度</strong> 不同，而且短序列和长序列的前几项对应相等，则 <strong>默认长序列大于短序列</strong>，与长序列剩余项的值无关。</li></ul></li><li><p>映射类型（<code>dict</code>）：无法进行大小比较。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    lst.append(random.randint(-<span class="number">50</span>, <span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [34, -43, -6, 36, 33, -50, 27, -6, -29, -30]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(lst, default=<span class="number">0</span>, key=<span class="built_in">abs</span>))  <span class="comment"># -50</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-5-min">4.5 min</h2><ul><li><code>min</code> 函数的格式与用法与 <code>max</code> 函数相同，只是 <code>min</code> 函数返回的是最小值。</li></ul><h2 id="4-6-pow">4.6 pow</h2><ul><li><p>格式：<code>pow(base, exp[, mod])</code>，返回一个数 <code>base</code> 的 <code>exp</code> 次幂，即 <code>base ** exp</code>。如果指定了 <code>mod</code> 参数，则先进行幂运算，然后对 <code>mod</code> 取模，即 <code>(base ** exp) % mod</code>。</p><ul><li><code>base</code> 和 <code>exp</code> 可以为 <code>int</code> 或 <code>float</code> 类型，但是 <code>mod</code> 必须为 <code>int</code> 类型。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">5</span>))  <span class="comment"># 32.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">5.0</span>))  <span class="comment"># 32.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-7-round">4.7 round</h2><ul><li><p>格式：<code>round(number, ndigits=none)</code>，返回 <code>number</code> 舍入到小数点后 <code>ndigits</code> 位精度的值，通常用于 <code>float</code> 类型数据，保留指定位数。</p><ul><li><p><code>ndigits</code> 只能为 <code>int</code> 类型，如果 <code>ndigits</code> 被省略或为 <code>None</code>，则返回最接近输入值的整数。例：<code>round(2.675)</code> 返回的是 <code>3</code>，<code>round(3.14)</code> 返回的也是 <code>3</code>。</p><ul><li><p>当小数点后仅一位为 <code>0.5</code> 时，遵循 <strong>从偶原则</strong>，即向着整数为偶数的方向取整。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">5.5</span>))  <span class="comment"># 6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">6.5</span>))  <span class="comment"># 6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">7.5</span>))  <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">8.5</span>))  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>由于大多数十进制小数实际上都不能以浮点数精确地表示，因此 <code>round</code> 函数的返回值有时并不能符合预期，例：<code>round(2.675, 2)</code> 返回的是 <code>2.67</code>，而非 <code>2.68</code>。</p></li></ul></li></ul><h2 id="4-8-sum">4.8 sum</h2><ul><li><p>格式：<code>sum(iterable, /, start=0)</code> 返回可迭代对象中所有元素的总和与 <code>start</code>（默认 <code>0</code>）相加之后的结果。</p><ul><li><code>iterable</code> 元素必需为数字类型。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(lst))  <span class="comment"># 80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(lst, start=<span class="number">100</span>))  <span class="comment"># 180</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 推导式 &amp; random 模块</title>
      <link href="/posts/python/python3/09.html"/>
      <url>/posts/python/python3/09.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、推导式</h1><ul><li><p>推导式 <code>comprehensions</code>（又称解析式），是 <code>Python</code> 的一种 <strong>独有特性</strong>，是一种可以从一个序列构建另一个新的序列的结构体。</p></li><li><p>共有 <code>3</code> 种推导式：<strong>列表推导式</strong>、<strong>字典推导式</strong> 和 <strong>集合推导式</strong>，这三种都是 <strong>可变数据类型</strong>。</p></li></ul><h2 id="1-1-列表推导式">1.1 列表推导式</h2><ul><li><p>格式：</p><ul><li><pre><code class="language-python">[表达式 for 变量 in 列表] [expression for var in list]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `expression`：列表生成元素表达式，可以是有返回值的函数。</span><br><span class="line">  - `for var in list`：从列表 `list` 中迭代出元素 `var`，传入到 `expression` 表达式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  [表达式 for 变量 in 列表 if 条件]</span><br><span class="line">  [expression for var in list if condition]</span><br></pre></td></tr></table></figure>- `if condition`：条件语句，可以过滤列表中不符合条件的值。</code></pre></li><li><p><code>[expression for var in list 更多的 for 循环或 if 语句]</code>。</p><ul><li>注：更多的 <code>for</code> 循环或 <code>if</code> 语句表示 <code>for</code> 循环嵌套或 <code>if</code> 语句嵌套。</li></ul></li></ul></li><li><p>示例 <code>1</code>：常规列表推导式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br></pre></td></tr></table></figure></li><li><p>示例 <code>2</code>：<code>for</code> 循环嵌套。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst = [(x + y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] <span class="keyword">if</span> y % <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [11, 21, 12, 22, 13, 23]</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]:</span><br><span class="line">        <span class="keyword">if</span> y % <span class="number">6</span>:</span><br><span class="line">            lst.append((x + y))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [11, 21, 12, 22, 13, 23]</span></span><br></pre></td></tr></table></figure></li><li><p>示例 <code>3</code>：列表推导式嵌套。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">          [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">          [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">result = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [row[i] for row in matrix] 等同于</span></span><br><span class="line"><span class="comment"># temp = []</span></span><br><span class="line"><span class="comment"># for row in matrix:</span></span><br><span class="line"><span class="comment">#     temp.append(row[i])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[row[i] for row in matrix] for i in range(4)] 等同于</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    result.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-字典推导式">1.2 字典推导式</h2><ul><li><p>格式：</p><ul><li><p><code>&#123;key_exp: value_exp for value in iterable&#125;</code></p></li><li><p><code>&#123;key_exp: value_exp for value in iterable if condition&#125;</code>。</p></li></ul></li><li><p>注：字典推导式只能在 <code>value</code> 中嵌套，因为 <code>key</code> 不可变。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">dict1 = &#123;key: value <span class="keyword">for</span> key <span class="keyword">in</span> random.sample(<span class="built_in">range</span>(<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line">         <span class="keyword">for</span> value <span class="keyword">in</span> random.sample(<span class="built_in">range</span>(<span class="number">10</span>), <span class="number">3</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1)    <span class="comment"># &#123;6: 4, 3: 8, 5: 2&#125;</span></span><br><span class="line">dict2 = &#123;key: dict1[key] ** <span class="number">2</span> <span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(dict2)    <span class="comment"># &#123;6: 16, 3: 64, 5: 4&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-集合推导式">1.3 集合推导式</h2><ul><li><p>格式：</p><ul><li><p><code>&#123;exp for var in iterable&#125;</code></p></li><li><p><code>&#123;exp for var in iterable 更多的 for 循环或 if 语句&#125;</code>。</p></li></ul></li><li><p>注：集合去重，集合推导式不能嵌套可变数据类型（集合、列表、字典）。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;x * y <span class="keyword">for</span> x <span class="keyword">in</span> random.sample(<span class="built_in">range</span>(<span class="number">10</span>), <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> random.sample(<span class="built_in">range</span>(<span class="number">10</span>), <span class="number">5</span>)&#125;</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">d = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> random.sample(<span class="built_in">range</span>(<span class="number">10</span>), <span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> random.sample(<span class="built_in">range</span>(<span class="number">10</span>), <span class="number">5</span>):</span><br><span class="line">        d.add(x * y)</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-4-元组推导式-生成器表达式">1.4 元组推导式（生成器表达式）</h2><ul><li><p>格式：</p><ul><li><code>(expression for item in Sequence)</code></li><li><code>(expression for item in Sequence if conditional)</code></li></ul></li><li><p>元组推导式可以利用 <code>range</code> 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p></li><li><p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <code>()</code> 圆括号将各部分括起来，而列表推导式使用的是中括号 <code>[]</code>，另外元组推导式返回的结果是一个生成器对象。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x00000266A4200040&gt;</span></span><br><span class="line"><span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a))</span><br></pre></td></tr></table></figure></li></ul><h1>二、random 模块</h1><ul><li><p><code>random</code> 模块实现了各种分布的 <strong>伪随机数</strong> 生成器。</p></li><li><p>随机数生成器生成的随机数都不是真正的随机数，而是 <strong>伪随机数</strong>。随机数生成器都是在一个封闭的系统内，使用 <strong>固定的算法</strong>（通常是线性同余或平方取中），通过一个 <strong>种子</strong>（通常用时钟代替）生成随机数。这意味着，如果知道了种子和已经产生的随机数，就可能获得接下来随机数序列的信息，这就是伪随机数的 <strong>可预测性</strong>。</p></li><li><p>要使用 <code>random</code> 模块中的函数必须先导入：<code>import random</code>。</p></li><li><p><code>random</code> 模块常用函数：</p><ul><li><p><code>random.random()</code> 返回 <code>[0.0, 1.0)</code> 范围内的 <strong>随机浮点数</strong>。</p></li><li><p><code>random.randint(a, b)</code> 返回 <code>[a, b]</code> 范围内的 <strong>随机整数</strong>。</p></li><li><p><code>random.uniform(a, b)</code> 返回 <code>[a, b]</code> 或 <code>[b, a]</code> 范围内的 <strong>随机浮点数</strong>，<code>a</code> 和 <code>b</code> 的大小关系无所谓。</p></li><li><p><code>random.choice(seq)</code> 从 <strong>非空序列</strong>（列表、元组、字符串）<code>seq</code> 返回一个 <strong>随机元素</strong>。 如果 <code>seq</code> 为空，则抛出 <code>IndexError</code> 异常。</p><ul><li>原理：随机索引，通过 <code>seq[i]</code> 获取序列元素。</li></ul></li><li><p><code>random.sample(population, k)</code> 从序列或集合中随机获取 <code>k</code> 个不同元素，以列表形式返回。（<code>Python3.9</code> 版本，集合中采样已弃用）</p></li><li><p><code>random.shuffle(x)</code> 将可变序列（列表）<code>x</code> <strong>随机打乱位置</strong>，无返回值（原地操作）。</p></li><li><p><code>random.randrange([start,] stop [,step])</code> 等价于从 <code>range(start, stop, step)</code> 中随机返回一个元素。</p></li><li><p><code>random.seed ([x])</code> 起固定随机数的作用，<code>x</code> 可以是任意数字（<code>x</code> 可<br>以理解为种子的名字）。</p><ul><li>使用 <code>seed</code> 函数之后的 <code>random</code> 语句都返回 <strong>固定</strong> 的 “随机数”。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 迭代问题</title>
      <link href="/posts/python/python3/08.html"/>
      <url>/posts/python/python3/08.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、列表迭代问题</h1><h2 id="1-1-漏删元素-索引越界">1.1 漏删元素、索引越界</h2><h3 id="1-1-1-问题说明">1.1.1 问题说明</h3><ul><li><p>在 <code>Python</code> 中，如果使用 <code>for</code> 循环遍历删除列表的元素，会导致一些元素被 <strong>漏删</strong>。如果使用索引遍历删除列表的元素，还会发生 <strong>索引越界</strong> 问题。这都是因为在删除元素后，列表的长度会 <strong>自动缩短</strong>（列表内存自动管理），被删除元素后面的元素会自动向前补进，索引也会相应地改变。</p></li><li><p>主因：列表长度自动缩短，导致迭代器超出索引边界。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 1 次循环：i = lst[0]，执行 lst.remove(i) 后 lst = [6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># 第 2 次循环：i = lst[1]，执行 lst.remove(i) 后 lst = [6, 8, 9]</span></span><br><span class="line"><span class="comment"># 第 3 次循环：i = lst[2]，执行 lst.remove(i) 后 lst = [6, 8]</span></span><br><span class="line"><span class="comment"># 第 4 次循环：i = lst[3]，迭代器索引超过列表边界，循环停止</span></span><br><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    lst.remove(i)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行下面的代码抛出异常 IndexError: list index out of range</span></span><br><span class="line"><span class="comment"># 第 1 次循环：i = 0，执行 lst.remove(lst[0]) 后 lst = [6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># 第 2 次循环：i = 1，执行 lst.remove(lst[1]) 后 lst = [6, 8, 9]</span></span><br><span class="line"><span class="comment"># 第 3 次循环：i = 2，执行 lst.remove(lst[2]) 后 lst = [6, 8]</span></span><br><span class="line"><span class="comment"># 第 4 次循环：i = 3，此时 lst 的长度仅为 2，索引最大为 1，抛出异常</span></span><br><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst)):</span><br><span class="line">    lst.remove(lst[i])</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-2-解决方案">1.1.2 解决方案</h3><h4 id="1-方案-1：删除固定次数首元素">（1）方案 1：删除固定次数首元素</h4><ul><li><p>虽然列表自动缩短，但是列表首元素在列表被清空之前始终都存在，因此，可以删除固定次数（列表长度）的首元素。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst)):</span><br><span class="line">    lst.remove(lst[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># []</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-方案-2：倒序删除">（2）方案 2：倒序删除</h4><ul><li><p>倒序删除就不会发生元素递补，因此可以直接删除元素。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> lst[::-<span class="number">1</span>]:</span><br><span class="line">    lst.remove(ele)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># []</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-方案-3：遍历拷贝的-list-操作原始的-list">（3）方案 3：遍历拷贝的 list，操作原始的 list</h4><ul><li><p>先将原始列表拷贝一份，然后进行遍历，到原始列表中找到对应的元素删除，遍历拷贝的列表之后，原始的列表也被清空。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">copy_lst = lst.copy()</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> copy_lst:</span><br><span class="line">    lst.remove(ele)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># []</span></span><br></pre></td></tr></table></figure></li></ul><h1>二、字典迭代问题</h1><h2 id="2-1-问题说明">2.1 问题说明</h2><ul><li><p><strong>字典在迭代期间不允许改变长度</strong>，否则会抛出异常 <code>RuntimeError: dictionary changed size during iteration</code>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面代码会抛出异常：</span></span><br><span class="line"><span class="comment">#   RuntimeError: dictionary changed size during iteration</span></span><br><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    d.pop(key)</span><br></pre></td></tr></table></figure></li><li><p>删除一个键值对后立刻填充一个，则不会抛出异常，因为字典长度未被改变。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    d.pop(key)</span><br><span class="line">    d.update(&#123;key: <span class="string">&quot;update&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;update&#x27;, &#x27;age&#x27;: &#x27;update&#x27;, &#x27;gender&#x27;: &#x27;update&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-解决方案">2.2 解决方案</h2><h3 id="2-2-1-方案-1：遍历拷贝的-dict-操作原始的-dict">2.2.1 方案 1：遍历拷贝的 dict，操作原始的 dict</h3><ul><li><p>遍历拷贝的 <code>dict</code>，这样被迭代的 <code>dict</code> 在迭代期间并没有改变长度，然后操作原始的 <code>dict</code>，进行删除操作。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">copy_dict = d.copy()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> copy_dict:</span><br><span class="line">    d.pop(key)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-方案-2：直接遍历键组成的列表">2.2.2 方案 2：直接遍历键组成的列表</h3><ul><li><p>将字典的键转变成一个列表，然后直接遍历列表删除对应的键值对。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">keys = <span class="built_in">list</span>(d)  <span class="comment"># 等同于 keys = list(d.keys())</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    d.pop(key)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1>三、集合迭代问题</h1><h2 id="3-1-问题说明">3.1 问题说明</h2><ul><li><p><strong>集合在迭代期间不允许改变长度</strong>，否则会抛出异常 <code>RuntimeError: Set changed size during iteration</code>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面代码会抛出异常：</span></span><br><span class="line"><span class="comment">#   RuntimeError: Set changed size during iteration</span></span><br><span class="line">s = &#123;<span class="string">&quot;HELLO&quot;</span>, <span class="number">527</span>, <span class="string">&quot;dong&quot;</span>, (<span class="number">6</span>, <span class="number">8</span>), <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> s:</span><br><span class="line">    s.remove(ele)</span><br></pre></td></tr></table></figure></li><li><p>删除一个值后立刻填充一个与集合中现有元素都不同的值（避免被去重），则不会抛出异常，因为集合长度未被改变。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">&quot;HELLO&quot;</span>, <span class="number">527</span>, <span class="string">&quot;dong&quot;</span>, (<span class="number">6</span>, <span class="number">8</span>), <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> s:</span><br><span class="line">    s.remove(ele)</span><br><span class="line">    s.add(ele)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;HELLO&#x27;, &#x27;dong&#x27;, (6, 8), 527, &#x27;python&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-解决方案">3.2 解决方案</h2><h3 id="3-2-1-方案-1：遍历拷贝的-set-操作原始的-set">3.2.1 方案 1：遍历拷贝的 set，操作原始的 set</h3><ul><li><p>遍历拷贝的 <code>set</code>，这样被迭代的 <code>set</code> 在迭代期间并没有改变长度，然后操作原始的 <code>set</code>，进行删除操作。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">&quot;HELLO&quot;</span>, <span class="number">527</span>, <span class="string">&quot;dong&quot;</span>, (<span class="number">6</span>, <span class="number">8</span>), <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line">copy_s = s.copy()</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> copy_s:</span><br><span class="line">    s.remove(ele)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># set()</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 流程控制</title>
      <link href="/posts/python/python3/07.html"/>
      <url>/posts/python/python3/07.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、顺序结构</h1><ul><li>顺序结构就是让程序按照从头到尾的顺序依次执行每一条 <code>Python</code> 代码，不重复执行任何代码，也不跳过任何代码。</li></ul><h1>二、分支结构</h1><ul><li><p>分支结构就是构造合适的分支条件和分析程序流程，根据分析程序流程选择适当的分支语句。</p></li><li><p>在 <code>Python</code> 中，可以使用 <code>if else</code> 语句对条件进行判断，然后根据不同的结果执行不同的代码，这被称为 <strong>选择结构</strong> 或 <strong>分支结构</strong>。</p></li></ul><h2 id="2-1-if-else-语句的语法格式">2.1 if else 语句的语法格式</h2><h3 id="2-1-1-语法格式">2.1.1 语法格式</h3><ul><li><p><code>Python</code> 中的 <code>if else</code> 语句的语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line">......</span><br><span class="line"><span class="keyword">elif</span> condition_n:</span><br><span class="line">    statement_block_n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block</span><br></pre></td></tr></table></figure><ul><li><p>如果 <code>condition_1</code> 为 <code>True</code>，将执行 <code>statement_block_1</code> <strong>代码块</strong>，执行完成后 <strong>跳出</strong> <code>if else</code> <strong>代码块</strong>；否则将向后运行到 <code>elif</code> 判断 “<code>condition_2</code>”。</p></li><li><p>如果 <code>condition_2</code> 为 <code>True</code>，将执行 <code>statement_block_2</code> <strong>代码块</strong>，执行完成后 <strong>跳出</strong> <code>if else</code> <strong>代码块</strong>；否则将向后运行到 <code>elif</code> 判断 “<code>condition_3</code>”。</p></li><li><p>以此类推直到 <code>elif condition_n</code>。</p></li><li><p>如果 <code>condition_n</code> 为 <code>True</code>，将执行 <code>statement_block_n</code> <strong>代码块</strong>，执行完成后 <strong>跳出</strong> <code>if else</code> <strong>代码块</strong>。</p></li><li><p>如果 “<code>condition_n</code>” 为 <code>False</code>，将向后运行到 <code>else</code> 语句，执行 “<code>statement_block</code>” <strong>代码块</strong>。</p></li></ul></li></ul><h3 id="2-1-2-注意事项">2.1.2 注意事项</h3><ul><li><p>表达式（<code>condition</code>）可以是一个单一的值或变量，也可以是由运算符组成的复杂语句，形式不限，<strong>只要它的结果能执行布尔判定即可</strong>。</p><ul><li><p>对于数字，<code>Python</code> 会把 <code>0</code> 和 <code>0.0</code> 当做 <code>False</code>，把其它值当做 <code>True</code>。</p></li><li><p>对于其它类型，当值为空或 <code>None</code> 时，<code>Python</code> 会当做 <code>False</code>，其它值当做 “<code>True</code>”。</p></li></ul></li><li><p><code>if</code>、<code>elif</code>、<code>else</code> 语句的最后要使用 <strong>冒号</strong> <code>:</code>，表示接下来是满足条件后要执行的 <strong>代码块</strong>。</p><ul><li><p><strong>代码块</strong> 由具有 <strong>相同缩进量</strong> 的若干条语句组成。</p><ul><li><p><code>Python</code> 是以缩进来标记代码块的，代码块一定要有缩进。</p></li><li><p>同一个代码块的缩进量要相同，缩进量不同的代码不属于同一个代码块。</p></li></ul></li></ul></li><li><p>一旦 <code>if</code> 或 <code>elif</code> 后面的表达式（<code>condition</code>）成立，<code>Python</code> 就会执行它后面对应的代码块；如果所有表达式都不成立，就执行 <code>else</code> 后面的代码块；如果没有 <code>else</code> 部分，就什么也不执行。</p></li><li><p>每个分支结构最多只会满足一次结果，即只会有一个 <code>if</code> 语句被执行，或只有 <code>else</code> 被执行，或都不被执行。</p></li><li><p>如果 <code>if</code> 语句结构体中只有一条语句，可以将该语句与 <code>if</code> 语句写在同一行。<strong>不建议</strong> 这么书写，不符合 <code>PEP 8</code> 规范。</p></li></ul><h2 id="2-2-三种形式的-if-else-语句">2.2 三种形式的 if else 语句</h2><ul><li><code>Python</code> 中的 <code>if else</code> 语句可以分为 <strong>三种形式</strong>：<ul><li><code>if</code> 语句。</li><li><code>if else</code> 语句。</li><li><code>if elif else</code> 语句。</li></ul></li></ul><h3 id="2-2-1-if-语句">2.2.1 if 语句</h3><ul><li><p>如果表达式（<code>condition</code>）成立（<code>True</code>），执行后面的代码块；如果表达式（<code>condition</code>）不成立（<code>False</code>），则什么也不执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    statement_block</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入这次考试的成绩：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你，考试通过！&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-if-else-语句">2.2.2 if else 语句</h3><ul><li><p>如果表达式（<code>condition</code>）成立（<code>True</code>），执行 <code>if</code> 后面紧跟的代码块 <code>1</code>；如果表达式（<code>condition</code>）不成立（<code>False</code>），执行 <code>else</code> 后面紧跟的代码块 <code>2</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_2</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入这次考试的成绩：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你，考试通过！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;考试未通过，下次努力！&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-3-if-elif-else-语句">2.2.3 if elif else 语句</h3><ul><li><p><code>Python</code> <strong>从上到下逐个判断</strong> 表达式（<code>condition</code>）是否成立，如果遇到某个表达式成立（<code>True</code>），就执行后面紧跟的代码块，不再执行其余代码。如果所有的表达式都不成立，就执行 <code>else</code> 后面的代码块。如果没有 <code>else</code> 部分，那就什么也不执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line">······</span><br><span class="line"><span class="keyword">elif</span> condition_n:</span><br><span class="line">    statement_block_n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block</span><br></pre></td></tr></table></figure><ul><li>不论有多少个 <code>elif</code> 分支，只能执行其中一个分支（<code>if</code> 判断都不符合则执行 <code>else</code> 分支），不能同时执行多个分支。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入这次考试的成绩：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt; <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你，考试成绩优秀，请继续保持！&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你，考试通过！&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">50</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;考试未通过，可以参加补考！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;考试未通过，下次努力！&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-if-else-嵌套语句">2.3 if else 嵌套语句</h2><ul><li><p><code>Python</code> 中，<code>if</code> 语句、<code>if else</code> 语句和 <code>if elif else</code> 语句之间可以 <strong>相互嵌套</strong>。</p></li><li><p>在最简单的 <code>if</code> 语句中嵌套 <code>if else</code> 语句，形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1：</span><br><span class="line">    <span class="keyword">if</span> condition_2：</span><br><span class="line">        statement_block_1</span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        statement_block_2</span><br></pre></td></tr></table></figure></li><li><p>在 <code>if else</code> 语句中嵌套 <code>if else</code> 语句，形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1：</span><br><span class="line">    <span class="keyword">if</span> condition_2：</span><br><span class="line">        statement_block_1</span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        statement_block_2</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    <span class="keyword">if</span> condition_3：</span><br><span class="line">        statement_block_3</span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        statement_block_4</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-pass-语句-pass-关键字">2.4 pass 语句（pass 关键字）</h2><ul><li><p>当 <code>if else</code> 条件语句中不进行任何操作时，可以使用 <strong>空语句</strong> <code>pass</code> 当作占位语句，表示不做任何事情，可以保证程序结构的完整性。</p></li><li><p><code>pass</code> 是 <code>Python</code> 中的 <strong>关键字</strong>，用来让解释器跳过此处，什么都不做。</p></li><li><p><code>Python</code> 中的省略号 <code>...</code> 与 <code>pass</code> 实现的功能相同。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入考试成绩：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> score == <span class="number">0</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;报班！&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-5-assert-语句">2.5 assert 语句</h2><ul><li><p><code>assert</code> 语句，又称 <strong>断言语句</strong>，可以看做是简配版 <code>if</code> 语句，它用于判断某个表达式的值是否为真，如果为真，则程序可以继续往下执行；反之，<code>Python</code> 解释器会抛出 <code>AssertionError</code> 异常。格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 表达式</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-6-三元表达式">2.6 三元表达式</h2><ul><li><p><code>Python</code> 中没有引入 <code>? :</code> 这个三目运算符，而是使用已有的 <code>if else</code> 语句来实现相同的功能。</p></li><li><p>三元表达式语法格式：<code>exp1 if contion else exp2</code></p><ul><li><p><code>condition</code> 是判断条件，<code>exp1</code> 和 <code>exp2</code> 是两个表达式。</p></li><li><p>如果 <code>condition</code> 成立（结果为真），就执行 <code>exp1</code>，并把 <code>exp1</code> 的结果作为整个表达式的结果；如果 <code>condition</code> 不成立（结果为假），就执行 <code>exp2</code>，并把 <code>exp2</code> 的结果作为整个表达式的结果。</p></li></ul></li><li><p><code>Python</code> 的三元表达式支持 <strong>嵌套</strong>，如此可以构成更加复杂的表达式。在嵌套时需要注意 <code>if</code> 和 <code>else</code> 的配对。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;perfect&quot;</span>) <span class="keyword">if</span> (score := <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入考试成绩：&quot;</span>))) &gt; <span class="number">90</span> <span class="keyword">else</span> \</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;good&quot;</span>) <span class="keyword">if</span> score &gt; <span class="number">80</span> <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&quot;pass&quot;</span>) <span class="keyword">if</span> score &gt; <span class="number">60</span> <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&quot;failed&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>三元表达式可以 <strong>赋值给变量</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">&quot;perfect&quot;</span> <span class="keyword">if</span> (score := <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入考试成绩：&quot;</span>))) &gt; <span class="number">90</span> <span class="keyword">else</span> \</span><br><span class="line">  <span class="string">&quot;good&quot;</span> <span class="keyword">if</span> score &gt; <span class="number">80</span> <span class="keyword">else</span> <span class="string">&quot;pass&quot;</span> <span class="keyword">if</span> score &gt; <span class="number">60</span> <span class="keyword">else</span> <span class="string">&quot;failed&quot;</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-7-match-case-语句">2.7 match … case 语句</h2><ul><li><p><strong>在</strong> <code>Python</code> <strong>中没有</strong> <code>switch</code> <strong>语句</strong>，但是在 <code>Python 3.10</code> 中新增了 <code>match...case</code> 条件判断，不需要再使用一连串的 <code>if-else</code>。</p></li><li><p>语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">  <span class="keyword">case</span> &lt;pattern_1&gt;:</span><br><span class="line">    &lt;action_1&gt;</span><br><span class="line">  <span class="keyword">case</span> &lt;pattern_2&gt;:</span><br><span class="line">    &lt;action_2&gt;</span><br><span class="line">  <span class="keyword">case</span> &lt;pattern_3&gt;:</span><br><span class="line">    &lt;action_3&gt;</span><br><span class="line">  <span class="keyword">case</span> _:</span><br><span class="line">    &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>match</code> 后的对象会依次与 <code>case</code> 后的表达式进行匹配，如果匹配成功，则执行匹配成功的表达式后面的代码块，否则直接跳过。<code>_</code> 可以匹配一切，当其他 <code>case</code> 都无法匹配时，执行 <code>case _</code> 后面的代码块。</p></li><li><p>可以使用 <code>if</code> 关键字在 <code>case</code> 中添加条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> expression:</span><br><span class="line">    <span class="keyword">case</span> pattern1:</span><br><span class="line">        <span class="comment"># 处理 pattern1 的逻辑</span></span><br><span class="line">    <span class="keyword">case</span> pattern2 <span class="keyword">if</span> condition:</span><br><span class="line">        <span class="comment"># 处理 pattern2 并且满足 condition 的逻辑</span></span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="comment"># 处理其他情况的逻辑</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">status</span>):</span><br><span class="line">    <span class="keyword">match</span> status:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Bad request&#x27;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Unauthorized&#x27;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Forbidden&#x27;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Not found&#x27;</span></span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Unknown status code&#x27;</span></span><br><span class="line">s = func(<span class="number">404</span>)</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># Not found</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-8-案例：石头剪子布">2.8 案例：石头剪子布</h2><ul><li><p>使用 <code>if else</code> 语句实现石头剪子布游戏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">num_mora = &#123;<span class="number">0</span>: <span class="string">&quot;石头&quot;</span>, <span class="number">1</span>: <span class="string">&quot;剪子&quot;</span>, <span class="number">2</span>: <span class="string">&quot;布&quot;</span>&#125;</span><br><span class="line">player = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请玩家出拳（0石头; 1剪子; 2布）：&quot;</span>))</span><br><span class="line">computer = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;玩家出拳：<span class="subst">&#123;num_mora[player]&#125;</span>，电脑出拳：<span class="subst">&#123;num_mora[computer]&#125;</span>，&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> computer - player <span class="keyword">in</span> (-<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑胜！&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> computer - player <span class="keyword">in</span> (-<span class="number">2</span>, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;玩家胜！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;平局！&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h1>三、循环结构</h1><h2 id="3-1-while-循环">3.1 while 循环</h2><ul><li>未知循环次数，但是已知循环的停止条件，常用 <code>while</code> 循环。</li></ul><h3 id="3-1-1-while-循环">3.1.1 while 循环</h3><ul><li><p><code>while</code> 循环的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化</span><br><span class="line"><span class="keyword">while</span> 条件表达式：</span><br><span class="line">    代码块（循环体）</span><br></pre></td></tr></table></figure></li><li><p><code>while</code> 循环的执行流程：</p><ul><li><p>初始化循环变量。</p></li><li><p>判断条件表达式的值，值为真（<code>True</code>）时执行代码块中的语句，否则跳出循环。</p></li><li><p>当循环体执行完毕后，重新判断条件表达式的值是否为真，若仍为真，则再次执行代码块。</p><ul><li>循环变量实现自增或自减。</li></ul></li><li><p>重复上述操作，直到条件表达式的值为假（<code>False</code>），终止循环。</p></li></ul></li><li><p>示例：输出 <code>1 ~ 100</code> 之间带有 <code>6</code> 和 <code>8</code> 的整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="comment"># 方式 1：</span></span><br><span class="line">    s_num = <span class="built_in">str</span>(num)</span><br><span class="line">    <span class="keyword">if</span> s_num.count(<span class="string">&quot;6&quot;</span>) <span class="keyword">or</span> s_num.count(<span class="string">&quot;8&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式 2：</span></span><br><span class="line">    <span class="comment"># if num % 10 in (6, 8) or num // 10 in (6, 8):</span></span><br><span class="line">    <span class="comment">#     print(num)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式 3：</span></span><br><span class="line">    <span class="comment"># s_num = str(num)</span></span><br><span class="line">    <span class="comment"># if &quot;6&quot; in s_num or &quot;8&quot; in s_num:</span></span><br><span class="line">    <span class="comment">#     print(num)</span></span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>如果 <code>while</code> 循环体中只有一条语句，可以将该语句与 <code>while</code> 语句写在同一行。<strong>不建议</strong> 这么书写，不符合 <code>PEP 8</code> 规范。</p></li></ul><h3 id="3-1-2-while-true">3.1.2 while True</h3><ul><li><p>可以通过设置条件表达式永远为 <code>True</code> 来实现 <strong>无限循环</strong>（死循环），即 <code>While True</code> 为无限循环。</p></li><li><p>无限循环通常要配合 <strong>循环控制语句</strong>（<code>break</code>、<code>continue</code>）去限制循环次数。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(a, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    a *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-1-2-while-else">3.1.2 while else</h3><ul><li><p>可以将 <code>while</code> 循环与 <code>else</code> 语句配合使用，当 <code>while</code> 后面的条件表达式（<code>condition</code>）为 <code>false</code> 时，执行 <code>else</code> 后面的语句块，然后结束循环。</p></li><li><p>语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_2</span><br></pre></td></tr></table></figure><ul><li><code>condition</code> 语句为 <code>true</code> 则执行 <code>statement_block_1</code> 代码块，否则执行 <code>statement_block_2</code> 代码块。</li></ul></li><li><p>当 <code>while else</code> 语句的 <code>while</code> 中使用 <code>break</code> 时，<code>while else</code> 语句整体都被终止，<code>else</code> 语句不会被执行。</p></li><li><p>示例 <code>1</code>：<code>while</code> 循环执行完成后，执行 <code>else</code> 语句，打印 “结束循环，<code>21</code> 大于 <code>20</code>”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="comment"># 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, </span></span><br><span class="line"><span class="comment"># 结束循环，21 大于 20</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n结束循环，<span class="subst">&#123;num&#125;</span> 大于 20&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>示例 <code>2</code>：<code>while</code> 循环中使用 <code>break</code>，<code>else</code> 语句会执行不到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="comment"># 1, 2, 3, 4, 5, 6, 7, 8, 9, </span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n结束循环，<span class="subst">&#123;num&#125;</span> 大于 20&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-for-循环">3.2 for 循环</h2><ul><li>已知循环次数或想遍历可迭代对象时，常用 <code>for</code> 循环。</li></ul><h3 id="3-2-1-for-循环格式">3.2.1 for 循环格式</h3><ul><li><p><code>for</code> 循环的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>for</code> 循环可以遍历任何 <strong>可迭代对象</strong>。</p></li><li><p>当程序中不使用 <code>&lt;variable&gt;</code>，而我们又不想为变量命名时，我们可以使用下划线 <code>_</code> 来接受遍历出的变量。</p></li></ul></li></ul><h3 id="3-2-2-for-循环的内部机制">3.2.2 for 循环的内部机制</h3><ul><li><p>先判断对象是否为可迭代对象，即是否存在 <code>__iter__</code> 方法，如果存在则调用<code>__iter__</code> 方法，返回一个 <strong>迭代器</strong>；否则，直接抛出 <code>TypeError</code> 异常。</p></li><li><p>不断地调用迭代器的 <code>__next__</code> 方法，每次调用按顺序迭代获取当前的值。</p></li><li><p>迭代完所有元素，就抛出异常 <code>StopIteration</code>，这个异常 <code>python</code> 解释器自己会处理。</p></li></ul><h3 id="3-2-3-for-循环遍历可迭代对象">3.2.3 for 循环遍历可迭代对象</h3><h4 id="1-字符串-列表-元组-和-集合">（1）字符串、列表、元组 和 集合</h4><ul><li><p>当使用 <code>for</code> 循环遍历 <code>String</code>、<code>list</code>、<code>tuple</code>、<code>Set</code> 时，迭代变量 <code>variable</code> 会先后被赋值为可迭代对象中的每个元素并执行一次循环体。其中 <code>Set</code> 是无序的。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="string">&quot;world&quot;</span>, (<span class="number">6</span>, <span class="number">8</span>), <span class="string">&quot;dong&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># 5, 2, 7, world, (6, 8), dong, </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-字典">（2）字典</h4><ul><li><p>当使用 <code>for</code> 循环遍历 <code>dict</code> 字典时，会经常用到和字典相关的 <code>3</code> 个方法 <code>keys()</code>、<code>values()</code> 和 <code>items()</code>，分别用于返回字典中的 <strong>键</strong>、<strong>值</strong> 和 <strong>键值对</strong> 组成的可迭代对象（视图对象）。</p></li><li><p>如果使用 <code>for</code> 循环直接遍历字典，则迭代变量 <code>variable</code> 会先后被赋值为每个键值对中的 <strong>键</strong>，和遍历字典 <code>keys()</code> 方法的返回值是相同的。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> person_dict:</span><br><span class="line">    <span class="built_in">print</span>(key, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># name, age, gender,</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> person_dict.keys():</span><br><span class="line">    <span class="built_in">print</span>(key, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># name, age, gender,</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> person_dict.values():</span><br><span class="line">    <span class="built_in">print</span>(value, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># dong, 18, male,</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> person_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># (&#x27;name&#x27;, &#x27;dong&#x27;), (&#x27;age&#x27;, 18), (&#x27;gender&#x27;, &#x27;male&#x27;),</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-range-对象">（3）range 对象</h4><ul><li><p><code>range</code> 对象是 <code>Python</code> 内置的对象，它可以认为是一个 <strong>不可变的数字序列</strong>，通常用于在 <code>for</code> 循环中指定循环的次数。</p></li><li><p>格式：<code>range([start,] stop[, step])</code>，<strong>返回</strong> 一个从 <code>start</code>（默认 <code>0</code>，包含）开始到 <code>stop</code>（不包含）结束，步长为 <code>step</code>（默认 <code>1</code>）的 <code>range</code> <strong>对象</strong>。</p><ul><li><p><code>range</code> 对象是一个不可变的 <strong>序列</strong>，是一个可迭代对象 <code>iterable</code>。</p></li><li><p><code>range</code> 类型相比常规 <code>list</code> 或 <code>tuple</code> 的优势在于一个 <code>range</code> 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大，它只保存 <code>start</code>, <code>stop</code> 和 <code>step</code> 值。</p></li></ul></li><li><p><code>range</code> 虽然被称为函数，但 <code>range</code> 实际上是一个不可变的序列类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">range</span>(<span class="number">10</span>), abc.<span class="type">Sequence</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># 1, 2, 3, 4, 5, 6, 7, 8, 9, </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-enumerate-枚举对象">（4）enumerate 枚举对象</h4><ul><li><p><code>enumerate</code> <strong>枚举对象</strong> 是 <code>Python</code> 内置的对象，<strong>内部的每个元素都是包含索引和值的元组</strong>。</p></li><li><p>格式：<code>enumerate(iterable[, start=0])</code>，用于将一个可迭代对象组合成一个 <code>enumerate</code> 对象（<strong>迭代器</strong>），其中的每个元素都是一个元组，每个元组都是由索引（从 <code>start</code> 开始，默认为 <code>0</code>）和索引对应的 <code>iterable</code> 值组成，多用于 <code>for</code> 循环。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum = <span class="built_in">enumerate</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   (0, &#x27;a&#x27;), 0, a</span></span><br><span class="line"><span class="comment">#   (1, &#x27;b&#x27;), 1, b</span></span><br><span class="line"><span class="comment">#   (2, &#x27;c&#x27;), 2, c</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enum:</span><br><span class="line">    <span class="built_in">print</span>(e, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e[<span class="number">0</span>], end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line">enum = <span class="built_in">enumerate</span>([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;dong&quot;</span>], start=<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   6, hello</span></span><br><span class="line"><span class="comment">#   7, world</span></span><br><span class="line"><span class="comment">#   8, dong</span></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enum:</span><br><span class="line">    <span class="built_in">print</span>(index, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-4-for-else-语句">3.2.4 for else 语句</h3><ul><li><p>可以将 <code>for</code> 循环与 <code>else</code> 语句配合使用，当 <code>for</code> 循环执行完成，即穷尽可迭代对象后，执行 <code>else</code> 后面的语句块，然后结束循环。</p></li><li><p>语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li><li><p>当 <code>for else</code> 语句的 <code>for</code> 中使用 <code>break</code> 时，<code>for else</code> 语句整体都被终止，<code>else</code> 语句不会被执行。</p></li><li><p>示例 <code>1</code>：<code>for</code> 循环执行完成后，执行 <code>else</code> 语句，打印 “结束循环”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, </span></span><br><span class="line"><span class="comment">#   结束循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n结束循环&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>示例 <code>2</code>：<code>for</code> 循环中使用 <code>break</code>，<code>else</code> 语句会执行不到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n结束循环&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-循环控制语句">3.3 循环控制语句</h2><ul><li><p><code>Python</code> 提供了循环控制语句（<code>break</code>、<code>continue</code>）配合循环结构的使用。</p><ul><li><p><code>break</code> 用于 <strong>终止</strong> <code>break</code> 本身所在的循环，即使循环条件没有 <code>False</code> 或可迭代对象还没被完全遍历，也会停止执行循环语句，对应的 <code>else</code> 代码块也将不执行。</p><ul><li>当 <code>break</code> 用于嵌套循环时，<code>break</code> 会 <strong>跳出</strong> 当前循环，然后执行 <strong>外层循环</strong> 的剩余代码或继续执行 <strong>外层循环</strong> 的下一轮循环。</li></ul></li><li><p><code>continue</code> 语句用来告诉 <code>Python</code> <strong>跳过</strong> 当前循环的剩余语句，然后继续执行 <strong>当前循环</strong> 的下一轮循环。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># 5, 6, 8, 9,</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;, &quot;</span>)  <span class="comment"># 5, 6, </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4-循环嵌套">3.4 循环嵌套</h2><ul><li><p>可以在循环体内嵌入其他的循环体，例：<code>while</code> 循环中可以嵌入 <code>for</code> 循环或 <code>while</code> 循环，<code>for</code> 循环中也可以嵌入 <code>while</code> 循环或 <code>for</code> 循环。</p></li><li><p>当 <code>2</code> 个或多个循环结构相互嵌套时，位于外层的循环结构常被称为 <strong>外层循环</strong>或 <strong>外循环</strong>，位于内层的循环结构常被称为 <strong>内层循环</strong> 或 <strong>内循环</strong>。</p></li><li><p>嵌套循环执行的总次数 = 外循环执行次数 * 内循环执行次数</p></li></ul><h3 id="3-4-1-while-嵌套-while">3.4.1 while 嵌套 while</h3><ul><li><p><code>while</code> 循环嵌套 <code>while</code> 循环的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">    statement_1</span><br><span class="line">    <span class="keyword">while</span> expression:</span><br><span class="line">        statement_2</span><br><span class="line">    statement_3</span><br></pre></td></tr></table></figure></li><li><p>示例：输出九九乘法表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">right_num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> right_num &lt; <span class="number">10</span>:</span><br><span class="line">    left_num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left_num &lt;= right_num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;left_num&#125;</span> * <span class="subst">&#123;right_num&#125;</span> = <span class="subst">&#123;left_num * right_num&#125;</span>&quot;</span>, end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        left_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    right_num += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-2-for-嵌套-for">3.4.2 for 嵌套 for</h3><ul><li><p><code>for</code> 循环嵌套 <code>for</code> 循环的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    <span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">        &lt;statements&gt;</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li><li><p>示例：输出九九乘法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> right_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">  <span class="keyword">for</span> left_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, right_num + <span class="number">1</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;left_num&#125;</span> * <span class="subst">&#123;right_num&#125;</span> = <span class="subst">&#123;left_num * right_num&#125;</span>&quot;</span>, end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-3-for-嵌套-while">3.4.3 for 嵌套 while</h3><ul><li><p><code>for</code> 循环嵌套 <code>while</code> 循环的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">    <span class="keyword">while</span> expression:</span><br><span class="line">        statement</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-4-while-嵌套-for">3.4.4 while 嵌套 for</h3><ul><li><p><code>while</code> 循环嵌套 <code>for</code> 循环的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">    statement</span><br><span class="line">    <span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">      &lt;statements&gt;</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-5-案例优化：石头剪子布">3.5 案例优化：石头剪子布</h2><ul><li><p>优化石头剪子布程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">num_mora = &#123;<span class="number">1</span>: <span class="string">&quot;石头&quot;</span>, <span class="number">2</span>: <span class="string">&quot;剪子&quot;</span>, <span class="number">3</span>: <span class="string">&quot;布&quot;</span>&#125;</span><br><span class="line">epoch = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    epoch += <span class="number">1</span></span><br><span class="line">    player_victory = <span class="number">0</span></span><br><span class="line">    computer_victory = <span class="number">0</span></span><br><span class="line">    times = random.choice([<span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第 <span class="subst">&#123;epoch&#125;</span> 轮游戏：<span class="subst">&#123;times&#125;</span> 局 <span class="subst">&#123;times // <span class="number">2</span> + <span class="number">1</span>&#125;</span> 胜&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, times + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第 <span class="subst">&#123;i&#125;</span> 局：&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            player = <span class="built_in">input</span>(<span class="string">&quot;请玩家出拳（1石头; 2剪子; 3布）：&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> player.isdecimal()) <span class="keyword">or</span> ((player := <span class="built_in">int</span>(player)) <span class="keyword">not</span> <span class="keyword">in</span> num_mora):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\t您的输入有误！&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> (computer := random.randint(<span class="number">1</span>, <span class="number">3</span>)) == player:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\t玩家出拳：<span class="subst">&#123;num_mora[player]&#125;</span>\n\t电脑出拳：<span class="subst">&#123;num_mora[computer]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> computer - player <span class="keyword">in</span> (-<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;\t第 <span class="subst">&#123;i&#125;</span> 局，电脑胜！&quot;</span>)</span><br><span class="line">            computer_victory += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> computer - player <span class="keyword">in</span> (-<span class="number">2</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;\t第 <span class="subst">&#123;i&#125;</span> 局，玩家胜！&quot;</span>)</span><br><span class="line">            player_victory += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> <span class="keyword">in</span> (player_victory, computer_victory)) <span class="keyword">and</span> times == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> (<span class="number">3</span> <span class="keyword">in</span> (player_victory, computer_victory)) <span class="keyword">and</span> times == <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> player_victory &gt; computer_victory:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n第 <span class="subst">&#123;epoch&#125;</span> 轮游戏最后的赢家是：玩家！恭喜你！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n第 <span class="subst">&#123;epoch&#125;</span> 轮游戏最后的赢家是：电脑！很遗憾！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> (isContinue := <span class="built_in">input</span>(<span class="string">&quot;请问您是否继续游戏？(Y/N)&quot;</span>).lower()) <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;y&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您的输入有误，请重新输入！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isContinue <span class="keyword">in</span> (<span class="string">&quot;n&quot;</span>, <span class="string">&quot;no&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;游戏结束，欢迎下次光临！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 浅拷贝和深拷贝</title>
      <link href="/posts/python/python3/06.html"/>
      <url>/posts/python/python3/06.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、赋值</h1><h2 id="1-1-id-函数">1.1 id() 函数</h2><ul><li><p>格式：<code>id([object])</code>，内置函数，返回 <code>object</code> 对象的唯一标识符（内存地址），是一个整数。</p><ul><li><strong>注</strong>：每次程序运行返回的内存地址都会不同。</li></ul></li><li><p>变量名存储的只是一种引用关系，所以通过 <code>id</code> 函数获取变量地址时，实际是返回了值的地址。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(num))  <span class="comment"># 2115635571152</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-小整数对象池">1.2 小整数对象池</h2><ul><li><p>整数在程序中的使用非常广泛，<code>Python</code> 为了优化速度，避免为整数频繁申请和销毁内存空间，使有了小整数对象池。</p></li><li><p><code>Python</code> 对小整数的定义是 <code>[-5, 256]</code>，这个范围内的整数对象都是 <strong>提前建立好的</strong>（地址固定），不会被垃圾回收。在一个 <code>Python</code> 的程序中，所有位于这个范围内的整数使用的都是 <strong>同一个对象</strong>。</p></li><li><p>为了节省内存空间，解释器（例：<code>PyCharm</code>）做了优化，如果直接在解释器中执行程序文件，相同值的变量（无论大整数还是小整数）都会引用自同一地址，而在交互式窗口运行则可以看到区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\DONG&gt;python</span><br><span class="line">Python 3.12.7 | packaged by Anaconda, Inc. | (main, Oct  4 2024, 13:17:27) [MSC v.1929 64 bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; snum1 = 255</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(snum1))</span><br><span class="line">140726536718712</span><br><span class="line">&gt;&gt;&gt; snum2 = 255</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(snum2))</span><br><span class="line">140726536718712</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(snum1)==<span class="built_in">id</span>(snum2))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bnum1 = 66666</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(bnum1))</span><br><span class="line">1689093976624</span><br><span class="line">&gt;&gt;&gt; bnum2 = 66666</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(bnum2))</span><br><span class="line">1689093977840</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(bnum1)==<span class="built_in">id</span>(bnum2))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">exit</span>()</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-大整数对象池">1.3 大整数对象池</h2><ul><li><p>与小整数对象不同，如果是相同值的大整数对象，在内存里面不是同一个地址，也就是说是不同的两个对象，不会让它们共享引用，而是重新开辟一个内存空间存放。<strong>但是</strong>，如果处于 <strong>相同代码块</strong> 的大整数对象，它们是 <strong>同一个内存地址</strong>（同一对象），会让其共享引用，不会再开辟一个内存空间存放。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">      num1 = <span class="number">66666</span></span><br><span class="line">      num2 = <span class="number">66666</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Exercise</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">      num1 = <span class="number">66666</span></span><br><span class="line">      num2 = <span class="number">66666</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(Test.num1) == <span class="built_in">id</span>(Test.num2))  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(Exercise.num1) == <span class="built_in">id</span>(Exercise.num2))  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(Test.num1) == <span class="built_in">id</span>(Exercise.num1))  <span class="comment"># False</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(Test.num2) == <span class="built_in">id</span>(Exercise.num2))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 1.4 字符串的 intern 机制</span></span><br><span class="line"></span><br><span class="line">- `intern` 机制： 如果两个及以上的字符串变量，它们的值 **相同** 且仅由 **数字**、**字母** 和 **下划线** 组成，并且长度不超过 `<span class="number">20</span>` 个字符；或者字符串的值仅含有 **一个字符** 时，内存空间中只创建一个对象来让这些变量都指向该内存地址（共享引用）。当字符串不满足该条件时，相同值的字符串变量在每次创建时都会申请一个新的内存地址来保存值。</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  C:\Users\DONG&gt;python</span><br><span class="line">  Python <span class="number">3.12</span><span class="number">.7</span> | packaged by Anaconda, Inc. | (main, Oct  <span class="number">4</span> <span class="number">2024</span>, <span class="number">13</span>:<span class="number">17</span>:<span class="number">27</span>) [MSC v<span class="number">.1929</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line">  <span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">  &gt;&gt;&gt; str1 = <span class="string">&quot;Helloooo wwwwwwworld!&quot;</span></span><br><span class="line">  &gt;&gt;&gt; str2 = <span class="string">&quot;Helloooo wwwwwwworld!&quot;</span></span><br><span class="line">  &gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(str1)==<span class="built_in">id</span>(str2))</span><br><span class="line">  <span class="literal">False</span></span><br><span class="line">  &gt;&gt;&gt; str1 = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">  &gt;&gt;&gt; str2 = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">  &gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(str1)==<span class="built_in">id</span>(str2))</span><br><span class="line">  <span class="literal">False</span></span><br><span class="line">  &gt;&gt;&gt; str1 = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">  &gt;&gt;&gt; str2 = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">  &gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(str1)==<span class="built_in">id</span>(str2))</span><br><span class="line">  <span class="literal">False</span></span><br><span class="line">  &gt;&gt;&gt; str1 = <span class="string">&quot;Hello_world&quot;</span></span><br><span class="line">  &gt;&gt;&gt; str2 = <span class="string">&quot;Hello_world&quot;</span></span><br><span class="line">  &gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(str1)==<span class="built_in">id</span>(str2))</span><br><span class="line">  <span class="literal">True</span></span><br><span class="line">  &gt;&gt;&gt; str1 = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span></span><br><span class="line">  &gt;&gt;&gt; str2 = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span></span><br><span class="line">  &gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">id</span>(str1)==<span class="built_in">id</span>(str2))</span><br><span class="line">  <span class="literal">True</span></span><br><span class="line">  &gt;&gt;&gt; exit()</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5-python-赋值">1.5 Python 赋值</h2><ul><li><p><code>Python</code> 中, 变量的定义和赋值必须是 <strong>同时进行</strong> 的，赋值只是将一个对象的 <strong>内存地址</strong> 赋值给了一个变量，让变量指向该地址，而不是将数据值赋给了变量。</p></li><li><p>当执行程序 <code>num = 77</code> 时，<code>Python</code> 解释器做的事情：</p><ul><li><p>创建变量 <code>num</code>。</p></li><li><p>创建一个对象（分配一块内存），来存储值 <code>77</code>。</p></li><li><p>将变量与对象连接起来，从变量到对象的连接称之为 <strong>引用</strong>（变量引用对象）。</p></li></ul></li><li><p><code>Python</code> 中的赋值语句不复制对象，只是建立 <strong>引用关联</strong>。</p></li><li><p>严格来说，变量名本身没有类型，通常我们所说的变量类型指的是值的数据类型。</p></li><li><p>当一个可变类型的数据被多个变量名引用时，如果对任意一个变量名进行修改，那么该变量名所指向的原数据就会被修改，所有引用这个原数据的变量都会发生改变。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  lst1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">  lst2 = lst1</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(lst2) == <span class="built_in">id</span>(lst1))  <span class="comment"># True</span></span><br><span class="line">  lst2.append(<span class="number">100</span>)</span><br><span class="line">  <span class="built_in">print</span>(lst1)  <span class="comment"># [1, 3, 5, 7, 9, 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、浅拷贝</span></span><br><span class="line"></span><br><span class="line">- 浅拷贝指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的 **引用**。</span><br><span class="line"></span><br><span class="line">  - 赋值不是浅拷贝，赋值来的对象就是完完全全的原始对象，只是叫的名字不同而已。</span><br><span class="line"></span><br><span class="line">- 浅拷贝有三种形式：</span><br><span class="line"></span><br><span class="line">  - 使用数据类型本身的 **构造器**，例：`<span class="built_in">list</span>()`、`<span class="built_in">tuple</span>()`、`<span class="built_in">str</span>()` 等。</span><br><span class="line">  </span><br><span class="line">  - 对于序列，可以通过 **完全切片操作 [:]** 来完成浅拷贝。</span><br><span class="line">  </span><br><span class="line">  - `Python` 还提供了 `copy` **模块** 中的 `copy.copy(obj)` **函数**，适用于任何数据类型。</span><br><span class="line">  </span><br><span class="line">    - `<span class="built_in">list</span>.copy()`、`<span class="built_in">dict</span>.copy()` 和 `<span class="built_in">set</span>.copy()` 都属于浅拷贝。</span><br><span class="line"></span><br><span class="line">- **浅拷贝之所以称为浅拷贝**，**是因为它仅仅只拷贝了一层**，**浅拷贝出来的对象就是外新内旧的对象**，浅拷贝出来的对象本身（`<span class="built_in">id</span>`）和原始对象完全不同，但是子对象和原始对象的子对象是一样的。</span><br><span class="line"></span><br><span class="line">  - 如果最外层的数据类型是 **不可变** 的（数值，字符串，元组），则 **不发生拷贝**，这种情况相当于赋值，新对象与被拷贝对象的 `<span class="built_in">id</span>` 值相同。例：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">    tup1 = (<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">    tup2 = <span class="built_in">tuple</span>(tup1)</span><br><span class="line">    tup3 = tup1[:]</span><br><span class="line">    tup4 = copy.copy(tup1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(tup1) == <span class="built_in">id</span>(tup2))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(tup1) == <span class="built_in">id</span>(tup3))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(tup1) == <span class="built_in">id</span>(tup4))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><ul><li><p>如果最外层的数据类型是 <strong>可变</strong> 的（列表、字典、集合），则（最外层）<strong>发生拷贝</strong>，创建一个 <strong>新对象</strong>，但是内部元素不发生拷贝，新的对象中保存的只是对原对象中数据的引用。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;, <span class="number">888</span>, <span class="string">&quot;hello&quot;</span>]</span><br><span class="line">lst2 = <span class="built_in">list</span>(lst1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1) == <span class="built_in">id</span>(lst2))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1[<span class="number">3</span>]) == <span class="built_in">id</span>(lst2[<span class="number">3</span>]))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1[<span class="number">4</span>]) == <span class="built_in">id</span>(lst2[<span class="number">4</span>]))  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 浅拷贝的列表是新列表，所以其中一个列表追加元素，对另一个没有影响</span></span><br><span class="line">lst1.append(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;, 888, &#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst1)</span><br><span class="line"><span class="comment"># [1, 2, 3, &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;, 888, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst2)</span><br><span class="line"><span class="comment"># 浅拷贝的内部元素不发生拷贝，所以其中一个对内部元素操作，会对另一个产生影响</span></span><br><span class="line">lst2[<span class="number">3</span>][<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line"><span class="comment"># [1, 2, 3, &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 20&#125;, 888, &#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst1)</span><br><span class="line"><span class="comment"># [1, 2, 3, &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 20&#125;, 888, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst2)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>三、深拷贝</h1><ul><li><p>深拷贝指的是重新分配一块内存，创建一个新的对象，并且将原对象中的所有元素，包括 <strong>多层嵌套</strong> 的元素，全部拷贝到新对象中。</p></li><li><p><strong>深拷贝出来的对象是一个全新的对象</strong>，<strong>修改原对象或新对象时</strong>，<strong>它们之间互不影响</strong>。</p></li><li><p>由于深拷贝需要维护一块内存用于记录已经拷贝的对象，所以深拷贝的运行速度会比浅拷贝 <strong>慢</strong>。</p></li><li><p>在 <code>Python</code> 中，深拷贝 <strong>只有一种形式</strong>：<code>copy</code> <strong>模块</strong> 中的 <code>copy.deepcopy(obj)</code> <strong>函数</strong>，适用于任何数据类型。</p></li><li><p><strong>深拷贝的原则</strong>：不管子对象多深，只要可变，都会拷贝成一份新对象。</p></li><li><p><strong>深拷贝的规则</strong>：</p><ul><li><p>如果被拷贝的对象 <strong>本身不可变</strong>（数值，字符串，元组）且 <strong>包含的所有子对象都不可变</strong>，则该对象 <strong>不发生拷贝</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>), <span class="string">&quot;world&quot;</span>)</span><br><span class="line">tup2 = copy.deepcopy(tup1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup1) == <span class="built_in">id</span>(tup2))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p>如果被拷贝的对象 <strong>本身可变</strong>（列表、字典、集合）或 <strong>本身不可变但包含有可变的子对象</strong>（例：元组包含列表），则该对象 <strong>发生拷贝</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>), <span class="string">&quot;world&quot;</span>]</span><br><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="string">&quot;world&quot;</span>)</span><br><span class="line">lst2 = copy.deepcopy(lst1)</span><br><span class="line">tup2 = copy.deepcopy(tup1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1) == <span class="built_in">id</span>(lst2))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup1) == <span class="built_in">id</span>(tup2))  <span class="comment"># False</span></span><br><span class="line">tup1[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(tup1) <span class="comment"># (1, 2, 3, &#x27;hello&#x27;, [10, 6, 7], &#x27;world&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><p>对于被拷贝的对象包含的 <strong>子对象</strong>，在拷贝时依然 <strong>遵循上两条规则</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">lst1 = [[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, ([<span class="number">7</span>, <span class="number">8</span>], <span class="number">9</span>), <span class="string">&quot;hello&quot;</span>, (<span class="number">5</span>, (<span class="number">6</span>, <span class="number">7</span>)),</span><br><span class="line">        &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;language&quot;</span>: [<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>]&#125;, &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;]</span><br><span class="line">lst2 = copy.deepcopy(lst1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1) == <span class="built_in">id</span>(lst2))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1[<span class="number">2</span>]) == <span class="built_in">id</span>(lst2[<span class="number">2</span>]))   <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1[<span class="number">4</span>]) == <span class="built_in">id</span>(lst2[<span class="number">4</span>]))   <span class="comment"># True</span></span><br></pre></td></tr></table></figure><ul><li><p>子对象 <code>[1, 2]</code> 列表本身可变，发生拷贝，内部的数字 <code>1</code> 和 <code>2</code> 不可变，不发生拷贝。</p></li><li><p>数字 <code>3</code>、字符串 <code>&quot;hello&quot;</code>、元组 <code>(5, (6, 7))</code> 本身不可变，不发生拷贝。</p></li><li><p>子对象 <code>([7, 8], 9)</code> 元组本身不可变，但包含可变的子对象 <code>[7, 8]</code> 列表，发生拷贝。</p><ul><li>元组中的子对象 <code>[7, 8]</code> 列表本身可变，发生拷贝，内部的数字 <code>7</code> 和 <code>8</code> 不可变，不发生拷贝。</li></ul></li><li><p>子对象 <code>&#123;&quot;name&quot;: &quot;dong&quot;, &quot;language&quot;: [&quot;Java&quot;, &quot;Python&quot;]&#125;</code> 字典本身可变，发生拷贝。</p><ul><li><p>字典的键都是不可变类型，因此不发生拷贝。</p></li><li><p>键 <code>&quot;name&quot;</code> 对应的值 <code>&quot;dong&quot;</code> 为字符串不可变，不发生拷贝。</p></li><li><p>键 <code>&quot;language&quot;</code> 对应的值 <code>[&quot;Java&quot;, &quot;Python&quot;]</code> 为列表可变，发生拷贝。列表中的元素都为字符串，不发生拷贝。</p></li></ul></li><li><p>子对象 <code>&#123;&quot;a&quot;, &quot;b&quot;&#125;</code> 集合本身可变，发生拷贝，内部的字符串 <code>&quot;a&quot;</code> 和 <code>&quot;b&quot;</code> 不可变，不发生拷贝。</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 字典和集合</title>
      <link href="/posts/python/python3/05.html"/>
      <url>/posts/python/python3/05.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>前言</h1><ul><li><p><strong>字典</strong>（<code>&lt;class 'dict'&gt;</code>）和 <strong>集合</strong>（<code>&lt;class 'set'&gt;</code>）不是序列，但是可迭代对象，可以使用 <code>collections</code> 库中的 <code>abc</code> 模块里面的 <code>Sequence</code> <strong>基类</strong> 来判断一个类型是不是属于序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>() <span class="comment"># 创建空列表</span></span><br><span class="line">tup = <span class="built_in">tuple</span>() <span class="comment"># 创建空元组</span></span><br><span class="line">ss = <span class="built_in">str</span>() <span class="comment"># 创建空字符串</span></span><br><span class="line">d = <span class="built_in">dict</span>() <span class="comment"># 创建空字典</span></span><br><span class="line">st = <span class="built_in">set</span>() <span class="comment"># 创建空集合</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, abc.<span class="type">Sequence</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(tup, abc.<span class="type">Sequence</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(ss, abc.<span class="type">Sequence</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(d, abc.<span class="type">Sequence</span>)) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(st, abc.<span class="type">Sequence</span>)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>字典和集合不支持索引</strong>、<strong>切片</strong>、<strong>相加和相乘操作</strong>。</p></li></ul><h1>一、dict 字典</h1><h2 id="1-1-概述">1.1 概述</h2><ul><li><p>类型 <code>&lt;class 'dict'&gt;</code>。</p></li><li><p>字典类型是 <code>Python</code> 中唯一的 <strong>映射类型</strong>，即通过一个元素，可以唯一找到另一个元素。</p></li><li><p>字典中，习惯将各元素对应的 <strong>索引</strong> 称为 <strong>键</strong>（<code>key</code>），各个键对应的 <strong>元素</strong> 称为 <strong>值</strong>（<code>value</code>），键及其关联的值称为 “<strong>键值对</strong>”。</p></li><li><p>字典的每个键值对使用冒号 <code>:</code> 隔开写成 <code>key: value</code> 的格式，每个键值对之间使用逗号 <code>,</code> 隔开，包括在花括号 <code>&#123;&#125;</code> 中。例：<code>&#123;&quot;name&quot;: &quot;dong&quot;, &quot;age&quot;: 18&#125;</code>。</p></li><li><p>字典是一种 <strong>可变数据类型</strong>。</p></li><li><p><strong>字典作为可迭代对象时</strong>，<strong>只有键参与迭代</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(tup))  <span class="comment"># [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>字典中，<strong>键</strong> 必须 <strong>唯一</strong>，但值可不唯一，即为不同键赋同一值。</p><ul><li>如果字典的键重复，会自动去重，即键保持不变（<strong>留下第一个键</strong>），留下最新的值，相当于更新键值对。</li></ul></li><li><p>字典中，值可以取任何数据类型，但是 <strong>键必须是不可变类型且内部不包含可变数据类型</strong>（例：元组中包含列表，这种也是不允许的）。</p></li><li><p>在 <code>Python</code> 中，标准的字典（<code>dict</code>）在 <code>3.7</code> 版本之前是无序的，但从 <code>3.7</code> 版本开始，字典会保留插入顺序。然而，字典的相等性比较是基于内容而不是顺序，所以仍然可以将其视为一种无序的数据结构。</p></li></ul><h2 id="1-2-创建字典的六种方式">1.2 创建字典的六种方式</h2><h3 id="1-2-1-使用-创建字典">1.2.1 使用 { } 创建字典</h3><h4 id="1-直接在空字典-里面写键值对">（1）直接在空字典 {} 里面写键值对</h4><ul><li><p>由于字典中每个元素都包含 <strong>两部分</strong>，分别是 <strong>键</strong>（<code>key</code>）和 <strong>值</strong>（<code>value</code>），因此在创建字典时，键和值之间使用 <strong>冒号</strong> <code>:</code> 分隔，相邻元素之间使用 <strong>逗号</strong> <code>,</code> 分隔，所有元素放在大括号 <code>&#123;&#125;</code> 中。</p></li><li><p>格式：<code>dictname = &#123;'key1': 'value1', 'key2': 'value2', ..., 'keyN': valueN&#125;</code>，其中 <code>dictname</code> 表示字典变量名，<code>'keyN': valueN</code> 表示各个元素的键值对。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-定义一个空字典-再向其中添加键值对">（2）定义一个空字典，再向其中添加键值对</h4><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;<span class="comment"># 定义一个空字典</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;dong&quot;</span></span><br><span class="line">d[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-2-使用-dict-内置函数创建字典">1.2.2 使用 dict 内置函数创建字典</h3><h4 id="1-方式一：使用关键字参数创建">（1）方式一：使用关键字参数创建</h4><ul><li><p>格式：<code>dict(**kwarg)</code> 用于创建字典。当不传递 <code>**kwarg</code> 参数时，创建一个空字典，即 <code>dict()</code> 创建空字典。</p><ul><li><p><code>**kwarg</code> 是 <strong>双星号参数</strong>，即 <strong>字典可变长参数</strong>，表示 <code>dict</code> 函数可以接受 <strong>0个或多个参数</strong>，并且这些传进来的参数要求以 <strong>关键字参数</strong> 的形式导入，且都被存放在字典 <code>kwarg</code> 中。</p><ul><li>形式为 <code>key=value</code> 的参数，称为关键字参数。</li></ul></li><li><p>双星号（<code>**</code>）参数与单星号（<code>*</code>）参数都是 <strong>不定长参数</strong>。</p></li><li><p>关键字参数中的 <strong>关键字</strong> 会自动变成 <strong>字符串</strong> 类型，作为字典中的 <strong>键</strong>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18, &#x27;height&#x27;: 226&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(name=<span class="string">&#x27;dong&#x27;</span>, age=<span class="number">18</span>, height=<span class="number">226</span>))</span><br></pre></td></tr></table></figure><ul><li>使用此方式创建字典时，字符串键不能带引号。</li></ul></li></ul><h4 id="2-方式二：使用映射对象创建字典">（2）方式二：使用映射对象创建字典</h4><ul><li><p>格式：<code>dict(mapping, **kwarg)</code> 用于创建字典。<code>mapping</code> 是一种关联式的容器类型，它存储了对象与对象之间的映射关系。</p></li><li><p>通过 <code>zip</code> 函数等可以直接生成 <code>mapping</code> 类型的数据。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>))</span><br><span class="line">han = [<span class="string">&quot;壹&quot;</span>, <span class="string">&quot;贰&quot;</span>, <span class="string">&quot;叁&quot;</span>, <span class="string">&quot;肆&quot;</span>, <span class="string">&quot;伍&quot;</span>, <span class="string">&quot;陆&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(num, han)))  <span class="comment"># &#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 4: &#x27;肆&#x27;, 5: &#x27;伍&#x27;, 6: &#x27;陆&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(num, han), name=<span class="string">&quot;dong&quot;</span>))  <span class="comment"># &#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 4: &#x27;肆&#x27;, 5: &#x27;伍&#x27;, 6: &#x27;陆&#x27;, &#x27;name&#x27;: &#x27;dong&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-方式三：使用可迭代对象创建字典">（3）方式三：使用可迭代对象创建字典</h4><ul><li><p>格式：<code>dict(iterable, **kwarg)</code> 用于创建字典。<code>iterable</code> 数据中每一项的长度必须为 <code>2</code>，其中第 <code>1</code> 个元素作为键，第 <code>2</code> 个元素作为值。否则抛出异常：<code>ValueError: dictionary update sequence element #0 has length 3; 2 is required</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出：&#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>)]))</span><br><span class="line"><span class="comment"># 输出：&#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, &#x27;name&#x27;: &#x27;dong&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>)], name=<span class="string">&quot;dong&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-3-使用类方法-fromkeys-创建字典">1.2.3 使用类方法 fromkeys() 创建字典</h3><ul><li><p>格式：<code>dictname = dict.fromkeys(iterable[，value=None])</code>，用于创建带有默认值的字典。其中 <code>iterable</code> 参数表示字典中的所有键，<code>value</code> 参数表示默认值，如果不写，则为空值 <code>None</code>。这种创建方式通常用于 <strong>初始化字典</strong>。</p></li><li><p><code>fromkeys</code> 是一种 <strong>类方法</strong>，直接使用字典类型 <code>dict</code> 进行调用。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.fromkeys(<span class="string">&quot;hello&quot;</span>))  <span class="comment"># &#123;&#x27;h&#x27;: None, &#x27;e&#x27;: None, &#x27;l&#x27;: None, &#x27;o&#x27;: None&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.fromkeys(<span class="string">&quot;dong&quot;</span>, <span class="string">&quot;cool&quot;</span>))  <span class="comment"># &#123;&#x27;d&#x27;: &#x27;cool&#x27;, &#x27;o&#x27;: &#x27;cool&#x27;, &#x27;n&#x27;: &#x27;cool&#x27;, &#x27;g&#x27;: &#x27;cool&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-访问字典">1.3 访问字典</h2><h3 id="1-3-1-使用键访问">1.3.1 使用键访问</h3><ul><li><p>列表和元组是通过下标来访问元素的，而字典是 <strong>通过键来访问对应的值</strong>。</p><ul><li><p>格式：<code>dictname[key]</code>，其中 <code>dictname</code> 表示字典的名称，<code>key</code> 表示键名。</p></li><li><p><strong>注</strong>：当键不存在时，会抛出 <code>KeyError</code> 异常。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;肆&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;伍&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;陆&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(han[<span class="number">6</span>]) <span class="comment"># 输出：陆</span></span><br></pre></td></tr></table></figure></li><li><p>字典中的元素是无序的，每个元素的位置都不固定，所以字典不能像列表和元组那样采用切片的方式一次性访问多个元素。</p></li></ul><h3 id="1-3-2-使用-get-方法访问">1.3.2 使用 get 方法访问</h3><ul><li><p>字典提供了 <code>get()</code> 方法来获取指定键对应的值（<strong>推荐</strong>）。当指定键不存在时，<code>get()</code> 方法不会抛出异常。</p></li><li><p>格式：<code>dictname.get(key, default=None)</code>，其中 <code>dictname</code> 表示字典的名称，<code>key</code> 表示要访问的键，<code>default</code> 表示键不存在时，此方法返回的默认值，默认为 <code>None</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;肆&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;伍&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;陆&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(han.get(<span class="number">6</span>)) <span class="comment"># 输出：陆</span></span><br><span class="line"><span class="built_in">print</span>(han.get(<span class="number">8</span>)) <span class="comment"># 输出：None</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-4-删除字典">1.4 删除字典</h2><ul><li><p>对于已经创建的字典，如果不再使用，可以使用 <code>del</code> 关键字将其删除。格式为：<code>del dictname</code>，其中 <code>dictname</code> 表示要删除字典的名称。</p><ul><li><strong>注</strong>：<code>del</code> 删除操作只是解除引用关系。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;肆&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;伍&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;陆&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># &#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 4: &#x27;肆&#x27;, 5: &#x27;伍&#x27;, 6: &#x27;陆&#x27;&#125;</span></span><br><span class="line"><span class="keyword">del</span> han</span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 抛出异常：NameError: name &#x27;han&#x27; is not defined</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5-键值对操作">1.5 键值对操作</h2><h3 id="1-5-1-添加键值对">1.5.1 添加键值对</h3><ul><li><p>添加新的键值对直接给不存在的 <code>key</code> 赋值即可，语法格式：<code>dictname[key] = value</code>，其中 <code>dictname</code> 表示字典的名称；<code>key</code> 和 <code>value</code> 表示新添加的键值对。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line">d[<span class="string">&quot;height&quot;</span>] = <span class="number">188</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18, &#x27;height&#x27;: 188&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-2-修改键值对">1.5.2 修改键值对</h3><ul><li><p>字典中的键（<code>key</code>）不能被修改，只能修改值（<code>value</code>）。当修改的键不存在时，会新增键值对。</p></li><li><p>字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line">d[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line">d[<span class="string">&quot;height&quot;</span>] = <span class="number">188</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 188&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-3-删除键值对">1.5.3 删除键值对</h3><ul><li><p>格式：<code>del dictname[key]</code>，用于删除字典中的键值对，其中 <code>dictname</code> 表示字典的名称，<code>key</code> 表示键。</p><ul><li><strong>注</strong>：当键不存在时，会抛出 <code>KeyError</code> 异常。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;dong&quot;</span></span><br><span class="line">d[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;dong&#x27;&#125;</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;height&quot;</span>]  <span class="comment"># KeyError: &#x27;height&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-4-判断字典中是否存在指定键值对">1.5.4 判断字典中是否存在指定键值对</h3><ul><li><p>如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。</p></li><li><p>判断字典是否包含指定键值对的键，可以使用 <code>in</code> 或 <code>not in</code> 运算符。通过 <code>in</code>（或 <code>not in</code>）运算符，我们可以判断字典中是否包含某个键，如果存在，可以通过键获取对应的值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;肆&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;伍&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;陆&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">6</span> <span class="keyword">in</span> han) <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">8</span> <span class="keyword">not</span> <span class="keyword">in</span> han) <span class="comment"># 输出：True</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-6-字典方法">1.6 字典方法</h2><ul><li><p><code>Python</code> 字典的数据类型为 <code>dict</code>，我们可使用 <code>dir(dict)</code> 来查看该类型包含哪些方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">dict</span>))</span><br><span class="line"><span class="comment"># [&#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__delitem__&#x27;, &#x27;__dir__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__getitem__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__reversed__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__setattr__&#x27;, &#x27;__setitem__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__subclasshook__&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;fromkeys&#x27;, &#x27;get&#x27;, &#x27;items&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;keys&#x27;, &#x27;pop&#x27;, &#x27;popitem&#x27;, &#x27;setdefault&#x27;, &#x27;update&#x27;, &#x27;values&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li><p>不以双下划线 <code>__</code> 开头结尾的方法都是字典的对象方法，即 <code>clear</code>, <code>copy</code>, <code>fromkeys</code>, <code>get</code>, <code>items</code>, <code>keys</code>, <code>pop</code>, <code>popitem</code>, <code>setdefault</code>, <code>update</code>, <code>values</code>。</p></li><li><p><code>fromkeys()</code> 和 <code>get()</code> 的用法在 [1.2.3 使用类方法 fromkeys() 创建字典](#123-使用类方法 fromkeys() 创建字典) 与 [1.3.2 使用 get 方法访问](#132-使用 get 方法访问) 中进行了介绍。</p></li><li><p><strong>修改字典的方法都是对原字典进行修改</strong>，即 <code>in-place</code> 操作（原地操作），无返回值，或者说返回值为 <code>None</code>。</p></li></ul></li></ul><h3 id="1-6-1-clear-方法">1.6.1 clear() 方法</h3><ul><li><p>格式：<code>dictname.clear()</code>，用于删除字典内所有元素。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;肆&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;伍&#x27;</span>), (<span class="string">&#x27;weekend&#x27;</span>, [<span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>])])</span><br><span class="line">han.clear()</span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-2-copy-方法">1.6.2 copy() 方法</h3><ul><li><p>格式：<code>dictname.copy()</code>，返回一个字典的 <strong>浅拷贝</strong>（如果属性是基本类型，拷贝的是基本类型的值；如果属性是引用类型，拷贝的是内存地址）。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">p = Person(<span class="string">&quot;dong&quot;</span>, <span class="number">18</span>) <span class="comment"># 创建 Person 类对象 p</span></span><br><span class="line">dict_test = &#123;<span class="string">&quot;work&quot;</span>:<span class="string">&quot;student&quot;</span>, <span class="string">&quot;person&quot;</span>:p&#125; <span class="comment"># 创建字典 dict_test</span></span><br><span class="line">dict_copy = dict_test.copy() <span class="comment"># 浅拷贝字典</span></span><br><span class="line">dict_copy[<span class="string">&quot;work&quot;</span>] = <span class="string">&quot;coder&quot;</span> <span class="comment"># 基本类型拷贝的是值，修改字典拷贝不会影响源字典</span></span><br><span class="line"><span class="built_in">print</span>(dict_test[<span class="string">&quot;work&quot;</span>],dict_test[<span class="string">&quot;person&quot;</span>].name,dict_test[<span class="string">&quot;person&quot;</span>].age) <span class="comment"># 输出：student dong 18</span></span><br><span class="line">dict_copy[<span class="string">&quot;person&quot;</span>].name = <span class="string">&quot;kexin&quot;</span> <span class="comment"># 引用类型拷贝的是内存地址，修改字典拷贝会影响源字典</span></span><br><span class="line"><span class="built_in">print</span>(dict_test[<span class="string">&quot;work&quot;</span>],dict_test[<span class="string">&quot;person&quot;</span>].name,dict_test[<span class="string">&quot;person&quot;</span>].age) <span class="comment"># 输出：student kexin 18</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-3-items-方法">1.6.3 items() 方法</h3><ul><li><p>格式：<code>dictname.items()</code>，用于返回字典中所有的键值对（<code>key-value</code>）组成的 <strong>视图对象</strong>。</p><ul><li><p>视图并不真正的存储数据，但透过视图，可以看到真实的数据，这意味着，当真实数据发生变化时，视图对象也会相应地 <strong>实时更新</strong>。</p></li><li><p>视图对象不是迭代器，但是一种可迭代对象。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> GeneratorType</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>)])</span><br><span class="line">items = han.items()</span><br><span class="line"><span class="built_in">print</span>(items)  <span class="comment"># 输出：dict_items([(1, &#x27;壹&#x27;), (2, &#x27;贰&#x27;), (3, &#x27;叁&#x27;)])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(han.items(), GeneratorType))  <span class="comment"># False，不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(han.items(), Iterable))  <span class="comment"># True，是可迭代对象</span></span><br><span class="line">han[<span class="number">6</span>] = <span class="string">&quot;陆&quot;</span>  <span class="comment"># 修改原数据</span></span><br><span class="line"><span class="built_in">print</span>(items)  <span class="comment"># 视图对象更新，输出：dict_items([(1, &#x27;壹&#x27;), (2, &#x27;贰&#x27;), (3, &#x27;叁&#x27;), (6, &#x27;陆&#x27;)])</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>list()</code> 函数将返回值转换成列表，或使用 <code>for in</code> 循环遍历返回值。</li></ul></li></ul><h3 id="1-6-4-keys-方法">1.6.4 keys() 方法</h3><ul><li><p>格式：<code>dictname.keys()</code>，用于返回字典中的所有键（<code>key</code>）组成的 <strong>视图对象</strong>。</p><ul><li><p>视图并不真正的存储数据，但透过视图，可以看到真实的数据，这意味着，当真实数据发生变化时，视图对象也会相应地 <strong>实时更新</strong>。</p></li><li><p>视图对象不是迭代器，但是一种可迭代对象。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> GeneratorType</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>)])</span><br><span class="line">keys = han.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># 输出：dict_keys([1, 2, 3])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(han.keys(), GeneratorType))  <span class="comment"># False，不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(han.keys(), Iterable))  <span class="comment"># True，是可迭代对象</span></span><br><span class="line">han[<span class="number">6</span>] = <span class="string">&quot;陆&quot;</span>  <span class="comment"># 修改原数据</span></span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># 视图对象更新，输出：dict_keys([1, 2, 3, 6])</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>list()</code> 函数将返回值转换成列表，或使用 <code>for in</code> 循环遍历返回值。</li></ul></li></ul><h3 id="1-6-5-pop-方法">1.6.5 pop() 方法</h3><ul><li><p>格式：<code>dictname.pop(key[, default])</code>，用于删除字典中指定的键值对，返回键 <code>key</code> 对应的值，未找到 <code>key</code> 则返回 <code>default</code>。</p><ul><li><code>default</code>：指定当键不存在时应该返回的值，如果 <code>default</code> 未给出且 <code>key</code> 不存在于字典中，则会抛出异常 <code>KeyError</code>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="string">&#x27;weekend&#x27;</span>, [<span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>])])</span><br><span class="line"><span class="built_in">print</span>(han.pop(<span class="string">&#x27;weekend&#x27;</span>))  <span class="comment"># 输出：[&#x27;陆&#x27;, &#x27;柒&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(han.pop(<span class="string">&quot;workday&quot;</span>, <span class="string">&quot;未找到&quot;</span>))  <span class="comment"># 输出：未找到</span></span><br><span class="line"><span class="built_in">print</span>(han.pop(<span class="string">&quot;workday&quot;</span>))  <span class="comment"># 抛出异常 KeyError: &#x27;workday&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-6-popitem-方法">1.6.6 popitem() 方法</h3><ul><li><p>格式：<code>dictname.popitem()</code>，用于删除并返回字典中的 <strong>最后一个</strong> 键值对。当字典为空时会抛出异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="string">&#x27;weekend&#x27;</span>, [<span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>])])</span><br><span class="line"><span class="built_in">print</span>(han.popitem())  <span class="comment"># 输出：(&#x27;weekend&#x27;, [&#x27;陆&#x27;, &#x27;柒&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-7-setdefault-方法">1.6.7 setdefault() 方法</h3><ul><li><p>格式：<code>dictname.setdefault(key, default=None)</code>，用于返回某个 <code>key</code> 对应的 <code>value</code>。</p><ul><li><p>如果 <code>key</code> 存在，则返回对应的 <code>value</code>。</p></li><li><p>如果 <code>key</code> 不存在，则加入值为 <code>default</code> 的键值对，并返回 <code>default</code>（默认为 <code>None</code>）。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;肆&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;伍&#x27;</span>), (<span class="string">&#x27;weekend&#x27;</span>, [<span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>])])</span><br><span class="line"><span class="built_in">print</span>(han.setdefault(<span class="string">&quot;weekend&quot;</span>,[<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>])) <span class="comment"># 输出：[&#x27;陆&#x27;, &#x27;柒&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(han) <span class="comment"># 输出：&#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 4: &#x27;肆&#x27;, 5: &#x27;伍&#x27;, &#x27;weekend&#x27;: [&#x27;陆&#x27;, &#x27;柒&#x27;]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(han.setdefault(<span class="string">&quot;workday&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])) <span class="comment"># 输出：[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(han) <span class="comment"># 输出：&#123;1: &#x27;壹&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 4: &#x27;肆&#x27;, 5: &#x27;伍&#x27;, &#x27;weekend&#x27;: [&#x27;陆&#x27;, &#x27;柒&#x27;], &#x27;workday&#x27;: [1, 2, 3, 4, 5]&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果指定的 <code>key</code> 存在，那么直接返回该 <code>key</code> 对应的 <code>value</code>。</p></li><li><p>如果指定的 <code>key</code> 不存在，那么先为该 <code>key</code> 设置默认值 <code>defaultvalue</code>，然后再返回该 <code>key</code> 对应的 <code>defaultvalue</code>。</p></li></ul></li></ul><h3 id="1-6-8-update-方法">1.6.8 update() 方法</h3><ul><li><p>格式：<code>dictname.update([other])</code>，用于使用 <strong>键值对</strong> 参数来更新己有的字典。</p><ul><li><code>other</code> 可以是另一个字典对象；可以是一个包含键值对的可迭代对象；可以是关键字参数。</li></ul></li><li><p>在执行 <code>update</code> 方法时，如果被更新的字典中己包含对应的键值对，那么原 <code>value</code> 会被覆盖；如果被更新的字典中不包含对应的键值对，则将键值对添加到已有字典中。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>)])</span><br><span class="line">han.update(&#123;<span class="number">1</span>: <span class="string">&quot;一&quot;</span>&#125;)  <span class="comment"># 更新原有键值对</span></span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;1: &#x27;一&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;&#125;</span></span><br><span class="line">other = &#123;<span class="number">6</span>: <span class="string">&quot;陆&quot;</span>, <span class="number">9</span>: <span class="string">&quot;玖&quot;</span>&#125;  <span class="comment"># other 为另一个字典对象</span></span><br><span class="line">han.update(other)</span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;1: &#x27;一&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 6: &#x27;陆&#x27;, 9: &#x27;玖&#x27;&#125;</span></span><br><span class="line">other = [(<span class="string">&#x27;weekend&#x27;</span>, <span class="string">&quot;[&#x27;陆&#x27;, &#x27;柒&#x27;]&quot;</span>)]   <span class="comment"># other 为一个包含键/值对的可迭代对象</span></span><br><span class="line">han.update(other)</span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;1: &#x27;一&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 6: &#x27;陆&#x27;, 9: &#x27;玖&#x27;, &#x27;weekend&#x27;: &quot;[&#x27;陆&#x27;, &#x27;柒&#x27;]&quot;&#125;</span></span><br><span class="line">han.update(workday=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># other 为关键字参数</span></span><br><span class="line"><span class="built_in">print</span>(han)  <span class="comment"># 输出：&#123;1: &#x27;一&#x27;, 2: &#x27;贰&#x27;, 3: &#x27;叁&#x27;, 6: &#x27;陆&#x27;, 9: &#x27;玖&#x27;, &#x27;weekend&#x27;: &quot;[&#x27;陆&#x27;, &#x27;柒&#x27;]&quot;, &#x27;workday&#x27;: [1, 2, 3, 4, 5]&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-9-values-方法">1.6.9 values() 方法</h3><ul><li><p>格式：<code>dictname.value()</code>，用于返回字典中的所有值（<code>value</code>）组成的 <strong>视图对象</strong>。</p><ul><li><p>视图并不真正的存储数据，但透过视图，可以看到真实的数据，这意味着，当真实数据发生变化时，视图对象也会相应地 <strong>实时更新</strong>。</p></li><li><p>视图对象不是迭代器，但是一种可迭代对象。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> GeneratorType</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">han = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;壹&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;贰&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;叁&#x27;</span>)])</span><br><span class="line">values = han.values()</span><br><span class="line"><span class="built_in">print</span>(values)  <span class="comment"># 输出：dict_values([&#x27;壹&#x27;, &#x27;贰&#x27;, &#x27;叁&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(han.values(), GeneratorType))  <span class="comment"># False，不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(han.values(), Iterable))  <span class="comment"># True，是可迭代对象</span></span><br><span class="line">han[<span class="number">6</span>] = <span class="string">&quot;陆&quot;</span>  <span class="comment"># 修改原数据</span></span><br><span class="line"><span class="built_in">print</span>(values)  <span class="comment"># 视图对象更新，输出：dict_values([&#x27;壹&#x27;, &#x27;贰&#x27;, &#x27;叁&#x27;, &#x27;陆&#x27;])</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>list()</code> 函数将返回值转换成列表，或使用 <code>for in</code> 循环遍历返回值。</li></ul></li></ul><h1>二、set 集合</h1><h2 id="2-1-概述">2.1 概述</h2><ul><li><p>类型 <code>&lt;class 'set'&gt;</code>。</p></li><li><p><code>Python</code> 中的集合用来保存 <strong>不重复</strong> 的元素，即集合中的元素都是 <strong>唯一</strong> 的，互不相同。</p></li><li><p><code>Python</code> 中的集合是 <strong>无序</strong> 的，所以每次输出时元素的排序顺序可能会不同。</p><ul><li>注：如果集合中存储的数据都是数字，可能每次输出都是数字排序后的结果。</li></ul></li><li><p>集合不是序列，但它是 <strong>可迭代对象</strong>，是 <strong>可变</strong> 的。</p><ul><li><strong>注</strong>：这里的可变不是指元素可变，而是集合长度可变。</li></ul></li><li><p>从 <strong>形式</strong> 上看，集合与字典类似，<code>Python</code> 集合会将所有元素放在一对大括号 <code>&#123;&#125;</code> 中，相邻元素之间用 “<code>,</code>” 分隔：<code>&#123;element1, element2, ..., elementn&#125;</code>。</p></li><li><p>从 <strong>内容</strong> 上看，同一集合中，只能存储 <strong>不可变</strong> 的数据类型（数值、字符串、元组、<code>range</code> 对象等），无法存储可变的数据类型（列表、元组套列表、字典、集合等），否则 <code>Python</code> 解释器会抛出 <code>TypeError</code> 异常。</p><ul><li>注：集合会自动去重，只保留一个重复项。</li></ul></li><li><p><code>Python</code> 中有 <strong>两种集合</strong> 类型，一种是 <code>set</code> <strong>类型</strong> 的集合，另一种是 <code>frozenset</code> <strong>类型</strong> 的集合，它们唯一的区别是：<code>set</code> 类型集合可以进行添加、删除元素的操作，而 <code>forzenset</code> 类型集合不可以。因此，<code>set</code> 集合是可变的，<code>forzenset</code> 集合是不可变的。</p></li></ul><h2 id="2-2-set-类型的集合">2.2 set 类型的集合</h2><h3 id="2-2-1-创建-set-集合">2.2.1 创建 set 集合</h3><h4 id="1-使用-创建-set-集合">（1）使用 { } 创建 set 集合</h4><ul><li><p>通过 <code>&#123;&#125;</code> 创建 <code>set</code> 集合后，一般使用 <code>=</code> 将它赋值给某个变量，格式：<code>setname = &#123;element1,element2,...,elementn&#125;</code>，其中 <code>setname</code> 表示集合名，<code>element1 ~ elementn</code> 表示集合的元素。</p><ul><li><strong>注</strong>：不能使用 <code>&#123;&#125;</code> 创建 <strong>空集合</strong>，因为 <code>Python</code> 解释器会将 <code>&#123;&#125;</code> 视为一个空字典。</li></ul></li></ul><h4 id="2-使用-set-函数创建-set-集合">（2）使用 set() 函数创建 set 集合</h4><ul><li><p>格式：<code>set([iterable])</code>，用于创建集合并返回，其中 <code>iterable</code> 表示字符串、列表、元组、<code>range</code> 对象等可迭代对象。如果未指定 <code>iterable</code>，则返回空集合，即 <code>set()</code> 返回空集合。</p><ul><li><strong>注</strong>：只能使用 <code>set()</code> 函数创建 <strong>空集合</strong>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>) <span class="comment"># 只会保存一个重复元素，空格也是一个元素</span></span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># 输出：&#123;&#x27;e&#x27;, &#x27;l&#x27;, &#x27; &#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-2-访问-set-集合元素">2.2.2 访问 set 集合元素</h3><ul><li><p>由于集合中的元素是无序的，因此无法像列表一样使用索引访问元素。<code>Python</code> 中，<strong>访问</strong> 集合元素 <strong>最常用</strong> 的方法是使用 <strong>循环结构</strong>，将集合中的数据逐一读取出来。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(ele,end=<span class="string">&#x27; &#x27;</span>) <span class="comment"># 输出：h w   o l e r d </span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-3-删除-set-集合">2.2.3 删除 set 集合</h3><ul><li>格式：<code>del setname</code>，对于已经创建的集合，如果不再使用，可以使用 <code>del</code> 关键字将其删除，其中 <code>setname</code> 表示要删除的集合名称。</li></ul><h3 id="2-2-4-集合特性">2.2.4 集合特性</h3><h4 id="1-去重">（1）去重</h4><ul><li><p>利用集合特性，可以实现数据的去重。</p></li><li><p>示例：把一个列表变成集合，自动就会去掉重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]</span></span><br><span class="line">s = <span class="built_in">set</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27; &#x27;, &#x27;d&#x27;, &#x27;h&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;w&#x27;, &#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-关系测试">（2）关系测试</h4><ul><li><p>利用集合特性，可以使用集合测试多组数据之间的交集、差集、并集等关系。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)  <span class="comment"># &#123;&#x27;r&#x27;, &#x27;o&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;hello world dong&quot;</span>)  <span class="comment"># &#123;&#x27;g&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;n&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line">s3 = <span class="built_in">set</span>(<span class="string">&quot;welcome to python&quot;</span>)  <span class="comment"># &#123;&#x27;c&#x27;, &#x27;t&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;p&#x27;, &#x27;n&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;h&#x27;, &#x27;y&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt; s2)  <span class="comment"># 判断 s1 是否为 s2 的真子集, True</span></span><br><span class="line"><span class="built_in">print</span>(s2 &gt; s1)  <span class="comment"># 判断 s2 是否为 s1 的真父集, True</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt;= s2)  <span class="comment"># 判断 s1 是否为 s2 的子集, True</span></span><br><span class="line"><span class="built_in">print</span>(s2 &gt;= s1)  <span class="comment"># 判断 s2 是否为 s1 的父集, True</span></span><br><span class="line"><span class="built_in">print</span>(s2 &amp; s3)  <span class="comment"># 返回 s2 和 s3 的交集：&#123;&#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27; &#x27;, &#x27;e&#x27;, &#x27;w&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s2 | s3)  <span class="comment"># 返回 s2 和 s3 的并集：&#123;&#x27;h&#x27;, &#x27;n&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;l&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;m&#x27;, &#x27;p&#x27;, &#x27;d&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;g&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s3 - s2)  <span class="comment"># 返回 s3 和 s2 的差集：&#123;&#x27;y&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;c&#x27;, &#x27;p&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s2 ^ s3)  <span class="comment"># 返回 s1 和 s2 中不同时存在的元素（对称差集）：&#123;&#x27;d&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;g&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>((s2 | s3) - (s2 &amp; s3))  <span class="comment"># 等价于 (s2 和 s3 的并集) - (s2 和 s3 的交集)：&#123;&#x27;d&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;g&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>((s2 - s3) | (s3 - s2))  <span class="comment"># 等价于 (s3 和 s2 的差集) 与 (s2 和 s3 的差集) 的并集：&#123;&#x27;d&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;g&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-5-set-集合方法">2.2.5 set 集合方法</h3><ul><li><p><code>Python</code> 集合的数据类型为 <code>set</code>，我们可使用 <code>dir(set)</code> 来查看该类型包含哪些方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">set</span>))</span><br><span class="line"><span class="comment"># [&#x27;__and__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__iand__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__ior__&#x27;, &#x27;__isub__&#x27;, &#x27;__iter__&#x27;, &#x27;__ixor__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__or__&#x27;, &#x27;__rand__&#x27;, &#x27;__reduce__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__ror__&#x27;, &#x27;__rsub__&#x27;, &#x27;__rxor__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__sub__&#x27;, &#x27;__subclasshook__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__xor__&#x27;, &#x27;add&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;difference&#x27;, &#x27;difference_update&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;discard&#x27;, &#x27;intersection&#x27;, &#x27;intersection_update&#x27;, &#x27;isdisjoint&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;issubset&#x27;, &#x27;issuperset&#x27;, &#x27;pop&#x27;, &#x27;remove&#x27;, &#x27;symmetric_difference&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;symmetric_difference_update&#x27;, &#x27;union&#x27;, &#x27;update&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li><p>不以双下划线 <code>__</code> 开头结尾的方法都是集合的对象方法，即 <code>add</code>, <code>clear</code>, <code>copy</code>, <code>difference</code>, <code>difference_update</code>, <code>discard</code>, <code>intersection</code>, <code>intersection_update</code>, <code>isdisjoint</code>, <code>issubset</code>, <code>issuperset</code>, <code>pop</code>, <code>remove</code>, <code>symmetric_difference</code>, <code>symmetric_difference_update</code>, <code>union</code>, <code>update</code>。</p></li><li><p>下方带星号（<code>*</code>）的方法表示 <code>frozenset</code> 集合也可以调用，用法与 <code>set</code> 集合相同。不带星号（<code>*</code>）的方法表示仅 <code>set</code> 集合可以调用。</p></li></ul></li></ul><h4 id="1-add-方法">（1）add() 方法</h4><ul><li><p>格式：<code>setname.add(element)</code>，用于向 <code>set</code> 集合中 <strong>添加一个不可变类型</strong> 元素，无返回值。如果元素存在，则对集合没有影响。</p><ul><li>注：使用 <code>add()</code> 方法只能添加 <strong>数字</strong>、<strong>字符串</strong>、<strong>元组</strong> 或 <strong>布尔类型</strong>（<code>True</code> 和 <code>False</code>）这类不可变的数据，不能添加列表、字典、集合这类可变的数据，否则 <code>Python</code> 解释器会抛出 <code>TypeError</code> 异常。如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</li></ul></li><li><p><code>add</code> 方法每次只能添加一个元素，即 <code>element</code> 会被当做一个整体添加到集合中。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">s.add(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;w&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;d&#x27;, &#x27;dong&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-clear-方法">（2）clear() 方法</h4><ul><li><p>格式：<code>setname.clear()</code>，用于移除集合中的所有元素，变成空集合，无返回值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;h&#x27;, &#x27;w&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27; &#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;</span></span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># set()</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-copy-方法">（3）copy() 方法 *</h4><ul><li><p>格式：<code>setname.copy()</code>，返回一个集合的浅拷贝。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;l&#x27;, &#x27;d&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;w&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s.copy())  <span class="comment"># &#123;&#x27;l&#x27;, &#x27;d&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;w&#x27;, &#x27;r&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-difference-方法">（4）difference() 方法 *</h4><ul><li><p>格式：<code>setname.difference(*iterable)</code>，用于返回一个新的集合，集合元素为两个或多个可迭代对象的 <strong>差集</strong>，即包含在 <code>setname</code>，但不在 <code>*iterable</code> 中的元素。</p></li><li><p>对应的运算符 <code>-</code> 要求符号两端参数都为集合。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">s3 = <span class="built_in">set</span>(<span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.difference(lst, tup))  <span class="comment"># set()</span></span><br><span class="line"><span class="built_in">print</span>(s1 - s2 - s3)  <span class="comment"># set()</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-difference-update-方法">（5）difference_update() 方法</h4><ul><li><p>格式：<code>setname.difference_update(*iterable)</code>，用于移除集合 <code>setname</code> 中与可迭代对象 <code>*iterable</code> 共有的元素。</p><ul><li><code>difference_update</code> 方法与 <code>difference</code> 方法的区别：<code>difference</code> 方法返回一个移除相同元素的 <strong>新集合</strong>，而 <code>difference_update</code> 方法是直接在 <strong>原集合</strong> 中移除元素，没有返回值。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome to python&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;this is a tuple&quot;</span>)</span><br><span class="line">s.difference_update(lst, tup)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;d&#x27;, &#x27;r&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-discard-方法">（6）discard() 方法</h4><ul><li><p>格式：<code>setname.discard(element)</code>，用于移除集合中的 <strong>指定元素</strong>，无返回值。如果元素不存在，则不做任何操作。</p><ul><li>注：该方法不同于 <code>remove</code> 方法，因为 <code>remove</code> 方法在移除一个不存在的元素时会抛出 <code>KeyError</code> 异常，而 <code>discard</code> 方法不做任何操作。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;welcome to python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;l&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;n&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;h&#x27;, &#x27;p&#x27;&#125;</span></span><br><span class="line">s.discard(<span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;t&#x27;, &#x27;y&#x27;, &#x27;n&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;h&#x27;, &#x27;p&#x27;&#125;</span></span><br><span class="line">s.discard(<span class="string">&quot;A&quot;</span>)  <span class="comment"># 不做任何操作</span></span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;t&#x27;, &#x27;y&#x27;, &#x27;n&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;h&#x27;, &#x27;p&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-intersection-方法">（7）intersection() 方法 *</h4><ul><li><p>格式：<code>setname.intersection(*iterable)</code>，用于返回一个新的集合，集合元素为两个或多个可迭代对象中共有的元素，即 <strong>交集</strong>。</p></li><li><p>对应的运算符 <code>&amp;</code> 要求符号两端参数都为集合。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">s3 = <span class="built_in">set</span>(<span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.intersection(lst, tup))  <span class="comment"># &#123;&#x27;o&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2 &amp; s3)  <span class="comment"># &#123;&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-intersection-update-方法">（8）intersection_update() 方法</h4><ul><li><p>格式：<code>intersection_update(*iterable)</code>，用于保留两个或更多可迭代对象中 <strong>都存在</strong> 的元素，即 <strong>交集</strong>，移除非交集元素，无返回值。</p></li><li><p><code>intersection_update</code> 方法与 <code>intersection</code> 方法的区别：<code>intersection</code> 方法返回一个 <strong>新集合</strong>，而 <code>intersection_update</code> 方法是在 <strong>原集合</strong> 上移除非交集的元素，无返回值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome to python&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;this is a tuple&quot;</span>)</span><br><span class="line">s.intersection_update(lst, tup)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;l&#x27;, &#x27;h&#x27;, &#x27; &#x27;, &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-isdisjoint-方法">（9）isdisjoint() 方法 *</h4><ul><li><p>格式：<code>setname.isdisjoint(iterable)</code>，用于判断集合 <code>setname</code> 与可迭代对象 <code>iterable</code> 是否 <strong>不包含</strong> 相同的元素，如果 <strong>不包含</strong> 返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)  <span class="comment"># &#123;&#x27;r&#x27;, &#x27;o&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;fan&quot;</span>)  <span class="comment"># [&#x27;f&#x27;, &#x27;a&#x27;, &#x27;n&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.isdisjoint(lst))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="10-issubset-方法">（10）issubset() 方法 *</h4><ul><li><p>格式：<code>setname.issubset(iterable)</code>，用于判断集合 <code>setname</code> 是否为可迭代对象 <code>iterable</code> 的 <strong>子集</strong>，即 <code>setname</code> 的所有元素是否都被包含在 <code>iterable</code> 中，如果是则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>对应的运算符 <code>&lt;=</code> 要求符号两端参数都为集合。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)  <span class="comment"># &#123;&#x27;w&#x27;, &#x27;r&#x27;, &#x27; &#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;D&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;w&#x27;, &#x27;i&#x27;, &#x27;g&#x27;, &#x27;l&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;n&#x27;, &#x27;.&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;p&#x27;, &#x27;,&#x27;, &#x27;o&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;hi, Dr.dong, welcome to python&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;hi, Dr.dong, welcome to python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.issubset(tup))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt;= s2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="11-issuperset-方法">（11）issuperset() 方法 *</h4><ul><li><p>格式：<code>setname.issuperset(iterable)</code>，用于判断集合 <code>setname</code> 是否为可迭代对象 <code>iterable</code> 的 <strong>父集</strong>，即 <code>iterable</code> 的所有元素是否都被包含在 <code>setname</code> 中，如果是则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>对应的运算符 <code>&gt;=</code> 要求符号两端参数都为集合。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)  <span class="comment"># &#123;&#x27;w&#x27;, &#x27;r&#x27;, &#x27; &#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;D&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;w&#x27;, &#x27;i&#x27;, &#x27;g&#x27;, &#x27;l&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;n&#x27;, &#x27;.&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;p&#x27;, &#x27;,&#x27;, &#x27;o&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;hi, Dr.dong, welcome to python&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s2.issuperset(lst))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2 &gt;= s1)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="12-pop-方法">（12）pop() 方法</h4><ul><li><p>格式：<code>setname.pop()</code>，用于 <strong>随机移除</strong> 一个元素，返回移除的元素。如果集合为空则抛出 <code>KeyError</code> 异常。</p><ul><li>由于集合是无序的，所以 <code>pop</code> 方法本质是删除第一个元素。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;hello&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s.pop())  <span class="comment"># hello</span></span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># set()</span></span><br><span class="line">s.pop()  <span class="comment"># KeyError: &#x27;pop from an empty set&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="13-remove-方法">（13）remove() 方法</h4><ul><li><p>格式：<code>setname.remove(element)</code>，用于移除集合中的 <strong>指定元素</strong>，无返回值。如果元素不存在，则抛出 <code>KeyError</code> 异常。</p><ul><li>注：该方法不同于 <code>discard</code> 方法，因为 <code>discard</code> 方法在移除一个不存在的元素不做任何操作，而 <code>remove</code> 方法会抛出 <code>KeyError</code> 异常。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;l&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;d&#x27;, &#x27;r&#x27;, &#x27;h&#x27;, &#x27; &#x27;, &#x27;e&#x27;&#125;</span></span><br><span class="line">s.remove(<span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;w&#x27;, &#x27;o&#x27;, &#x27;d&#x27;, &#x27;r&#x27;, &#x27;h&#x27;, &#x27; &#x27;, &#x27;e&#x27;&#125;</span></span><br><span class="line">s.remove(<span class="string">&quot;A&quot;</span>)  <span class="comment"># 抛出异常 KeyError: &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="14-symmetric-difference-方法">（14）symmetric_difference() 方法 *</h4><ul><li><p>格式：<code>setname.symmetric_difference(iterable)</code>，返回一个新的集合，集合元素为两个集合中不重叠的元素（对称差集）。</p></li><li><p>对应的运算符 <code>^</code> 要求符号两端参数都为集合。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome to python&quot;</span>)</span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;welcome to python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(lst))  <span class="comment"># &#123;&#x27;d&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;c&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;n&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1 ^ s2)  <span class="comment"># &#123;&#x27;d&#x27;, &#x27;p&#x27;, &#x27;y&#x27;, &#x27;c&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;n&#x27;, &#x27;r&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="15-symmetric-difference-update-方法">（15）symmetric_difference_update() 方法</h4><ul><li><p>格式：<code>setname.symmetric_difference_update(iterable)</code>，用于将 <code>iterable</code> 中的元素插入到 <code>setname</code> 中，然后再删除 <code>setname</code> 与 <code>iterable</code> 的交集。</p><ul><li><code>symmetric_difference_update</code> 方法与 <code>symmetric_difference</code> 方法的区别：<code>symmetric_difference</code> 方法返回一个 <strong>新集合</strong>，而 <code>symmetric_difference_update</code> 方法是在 <strong>原集合</strong> 上插入可迭代对象中的元素，然后移除两个对象的交集。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome to python&quot;</span>)</span><br><span class="line">s.symmetric_difference_update(lst)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;y&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;p&#x27;, &#x27;m&#x27;, &#x27;t&#x27;, &#x27;n&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="16-union-方法">（16）union() 方法 *</h4><ul><li><p>格式：<code>setname.union(*iterable)</code>，返回一个新集合，新集合是两个或多个可迭代对象的 <strong>并集</strong>，重复的元素只会出现一次。</p></li><li><p>对应的运算符 <code>|</code> 要求符号两端参数都为集合。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line">s3 = <span class="built_in">set</span>(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.union(lst, tup))  <span class="comment"># &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;n&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;c&#x27;, &#x27;l&#x27;, &#x27;m&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1 | s2 | s3)  <span class="comment"># &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;n&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;c&#x27;, &#x27;l&#x27;, &#x27;m&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="17-update-方法">（17）update() 方法</h4><ul><li><p>格式：<code>setname.update(*iterable)</code>，用于向 <code>set</code> 集合中添加可迭代对象中的所有元素，无返回值。</p><ul><li>注：使用 <code>update()</code> 方法只能添加 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 这类可迭代的数据，不能添加 <strong>数字</strong> 或 <strong>布尔类型</strong>（<code>True</code> 和 <code>False</code>）这类不可迭代的数据，否则 <code>Python</code> 解释器会抛出 <code>TypeError</code> 异常。如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="string">&quot;This is a list&quot;</span>)</span><br><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&quot;This is a tuple&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;o&#x27;, &#x27;r&#x27;, &#x27;H&#x27;, &#x27;l&#x27;, &#x27;w&#x27;, &#x27; &#x27;, &#x27;d&#x27;, &#x27;e&#x27;&#125;</span></span><br><span class="line">s.update(lst, tup)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&#x27;o&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;H&#x27;, &#x27;l&#x27;, &#x27;T&#x27;, &#x27;u&#x27;, &#x27;h&#x27;, &#x27;w&#x27;, &#x27;i&#x27;, &#x27; &#x27;, &#x27;d&#x27;, &#x27;s&#x27;, &#x27;p&#x27;, &#x27;a&#x27;, &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-frozenset-类型的集合-set-集合的不可变版本">2.3 frozenset 类型的集合（set 集合的不可变版本）</h2><ul><li><p>格式：<code>frozenset([iterable])</code>，用于创建一个新的 <code>frozenset</code> 类型集合，即 <strong>冻结集合</strong>。其中 <code>iterable</code> 表示字符串、列表、元组、<code>range</code> 对象等可迭代对象。如果未指定 <code>iterable</code>，则返回空的冻结集合，即 <code>frozenset()</code> 返回空的冻结集合。</p></li><li><p><code>set</code> 中的元素必须是不可变类型的，而 <code>frozenset</code> 是可以作为 <code>set</code> 元素的。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="built_in">frozenset</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fs)</span><br><span class="line"><span class="built_in">print</span>(&#123;fs&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>set</code> 集合中所有能修改集合的方法（<code>remove()</code>、<code>discard()</code>、<code>add()</code> 等），<code>frozenset</code> 都不支持；<code>set</code> 集合中不修改集合的方法 <code>fronzenset</code> 都支持。</p></li><li><p>可以通过 <code>dir(frozenset)</code> 来查看 <code>frozenset</code> 集合支持的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">frozenset</span>))</span><br><span class="line"><span class="comment"># [&#x27;__and__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__or__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__rand__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__ror__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__rsub__&#x27;, &#x27;__rxor__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__sub__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__xor__&#x27;, &#x27;copy&#x27;, &#x27;difference&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;intersection&#x27;, &#x27;isdisjoint&#x27;, &#x27;issubset&#x27;, &#x27;issuperset&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;symmetric_difference&#x27;, &#x27;union&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li><p>不以双下划线 <code>__</code> 开头结尾的方法都是 <code>frozenset</code> 集合的对象方法，即 <code>copy</code>, <code>difference</code>, <code>intersection</code>, <code>isdisjoint</code>, <code>issubset</code>, <code>issuperset</code>, <code>symmetric_difference</code>, <code>union</code>。</p></li><li><p><code>frozenset</code> 集合的这些方法和 <code>set</code> 集合中同名方法的功能是一样的。</p></li></ul></li><li><p>两种情况下可以使用 <code>fronzenset</code>：</p><ul><li><p>当集合的元素不需要改变时，我们可以使用 <code>fronzenset</code> 替代 <code>set</code>，这样更加安全。</p></li><li><p>程序要求必须是不可变对象时也可以使用 <code>fronzenset</code> 替代 <code>set</code>。例：字典（<code>dict</code>）的键（<code>key</code>）就要求是不可变对象。<code>set</code> 集合中的元素要求是不可变的，可以使用 <code>fronzenset</code> 集合作为 <code>set</code> 集合中的元素。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 序列（字符串）</title>
      <link href="/posts/python/python3/04.html"/>
      <url>/posts/python/python3/04.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、字符串</h1><h2 id="1-1-概述">1.1 概述</h2><ul><li><p>类型 <code>&lt;class 'str'&gt;</code>。</p></li><li><p>字符串是一种 <strong>不可变</strong> 的数据类型。</p></li><li><p>字符串也是一种常见的 <strong>序列</strong>，所有标准的序列操作（<strong>索引</strong>、<strong>切片</strong>、<strong>相加</strong>、<strong>相乘</strong>、<code>in</code> <strong>操作</strong>、<strong>序列内置函数</strong> 等）对字符串同样使用。</p></li><li><p><code>Python</code> 没有 <strong>字符</strong>（<code>char</code>）这个类型，而是用 “<strong>长度为</strong> <code>1</code> <strong>的字符串</strong>” 来表示字符的概念。</p></li></ul><h2 id="1-2-字符串拼接">1.2 字符串拼接</h2><ul><li><p>使用逗号 <code>,</code> 拼接，相邻的两个字符串之间会 <strong>自动添加空格</strong>，可以应用于字符串常量和字符串变量。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1, str2)  <span class="comment"># 输出：hello world</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 输出：hello world</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, str2)  <span class="comment"># 输出：hello world</span></span><br></pre></td></tr></table></figure></li><li><p>直接拼接（中间有无空格皆可），相邻的两个字符串之间 <strong>不会自动添加空格</strong>，仅可以应用于字符串常量。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span><span class="string">&quot;world&quot;</span>)  <span class="comment"># 输出：helloworld</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span>)  <span class="comment"># 输出：helloworld</span></span><br></pre></td></tr></table></figure></li><li><p>使用加号 <code>+</code> 拼接，相邻的两个字符串之间 <strong>不会自动添加空格</strong>。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1 + str2)  <span class="comment"># 输出：helloworld</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>)  <span class="comment"># 输出：helloworld</span></span><br><span class="line"><span class="built_in">print</span>(str1 + <span class="string">&quot;world&quot;</span>)  <span class="comment"># 输出：helloworld</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-字符串方法">1.3 字符串方法</h2><ul><li><p><code>Python</code> 集合的数据类型为 <code>str</code>，我们可使用 <code>dir(str)</code> 来查看该类型包含哪些方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># [&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__getitem__&#x27;, &#x27;__getnewargs__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__mod__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__rmod__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;casefold&#x27;, &#x27;center&#x27;, &#x27;count&#x27;, &#x27;encode&#x27;, &#x27;endswith&#x27;, &#x27;expandtabs&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;find&#x27;, &#x27;format&#x27;, &#x27;format_map&#x27;, &#x27;index&#x27;, &#x27;isalnum&#x27;, &#x27;isalpha&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;isascii&#x27;, &#x27;isdecimal&#x27;, &#x27;isdigit&#x27;, &#x27;isidentifier&#x27;, &#x27;islower&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;isnumeric&#x27;, &#x27;isprintable&#x27;, &#x27;isspace&#x27;, &#x27;istitle&#x27;, &#x27;isupper&#x27;, &#x27;join&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;ljust&#x27;, &#x27;lower&#x27;, &#x27;lstrip&#x27;, &#x27;maketrans&#x27;, &#x27;partition&#x27;, &#x27;replace&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;rfind&#x27;, &#x27;rindex&#x27;, &#x27;rjust&#x27;, &#x27;rpartition&#x27;, &#x27;rsplit&#x27;, &#x27;rstrip&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;split&#x27;, &#x27;splitlines&#x27;, &#x27;startswith&#x27;, &#x27;strip&#x27;, &#x27;swapcase&#x27;, &#x27;title&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;translate&#x27;, &#x27;upper&#x27;, &#x27;zfill&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>因为字符串是 <strong>不可变</strong> 数据类型，所以字符串方法基本都 <strong>具有返回值</strong>，即返回一个 <strong>新字符串</strong>，原字符串并不被修改。</p><ul><li>对原字符串的操作其实是应用于原字符串的 <strong>拷贝副本</strong>，操作完成后再将拷贝副本的地址赋值给新的变量，这种操作又被称为 <strong>新建操作</strong>。</li></ul></li></ul><h3 id="1-3-1-capitalize-方法">1.3.1 capitalize() 方法</h3><ul><li><p>格式：<code>str.capitalize()</code>，返回一个 <strong>首字母大写</strong>，<strong>其他字母全部小写</strong> 的新字符串。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HELLO world&quot;</span>.capitalize())  <span class="comment"># 输出：Hello world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-2-casefold-方法">1.3.2 casefold() 方法</h3><ul><li><p>格式：<code>str.casefold()</code>，返回一个 <strong>所有字符均小写</strong> 的新字符串。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HELLO world&quot;</span>.casefold())  <span class="comment"># 输出：hello world</span></span><br></pre></td></tr></table></figure></li><li><p><code>casefold()</code> 方法是 <code>Python3.3</code> 版本之后引入的，与 <code>lower()</code> 方法的区别：<code>lower()</code> 方法只适用于 <code>ASCII</code> 编码（<code>A-Z</code>），对于其他语言（非汉语或英文）只能原样输出，这时就可以用到 <code>casefold()</code> 方法。示例：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ß&quot;</span>.lower())  <span class="comment"># 输出：ß</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ß&quot;</span>.casefold())  <span class="comment"># 输出 ß 的正确小写：ss</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-3-center-方法">1.3.3 center() 方法</h3><ul><li><p>格式：<code>str.center(length[, fillchar])</code>，返回一个在指定长度 <code>length</code> 居中的 <strong>新字符串</strong>。</p><ul><li><strong>注</strong>：<code>length</code> 小于字符串长度则直接返回 <strong>原字符串</strong>。</li><li><code>fillchar</code> 为左右填充的字符，默认为空格。必须是单个字符，否则报错：<code>TypeError: The fill character must be exactly one character long</code>。</li></ul></li><li><p>当左右填充不平衡时：</p><ul><li><p>原字符串长度为 <strong>奇数</strong> 时，<strong>左边填充更少</strong>。</p></li><li><p>原字符串长度为 <strong>偶数</strong> 时，<strong>左边填充更多</strong>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">cs1 = s.center(<span class="number">8</span>)  <span class="comment"># 指定长度 8 小于字符串长度 11，返回原字符串</span></span><br><span class="line"><span class="comment"># 指定长度 20，使用 - 填充，左右填充不平衡，原字符串长度 11 为奇数，所以左侧填充更少</span></span><br><span class="line">cs2 = s.center(<span class="number">20</span>, <span class="string">&quot;-&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(cs1)  <span class="comment"># hello world</span></span><br><span class="line"><span class="built_in">print</span>(cs2)  <span class="comment"># ----hello world-----</span></span><br><span class="line"><span class="built_in">print</span>(cs1 == s)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-4-count-方法">1.3.4 count() 方法</h3><ul><li><p>格式：<code>str.count(sub, start= 0, end=len(string))</code>，返回子字符串 <code>sub</code> 在字符串 <code>str</code> 中出现的 <strong>非重叠次数</strong>，默认全局搜索。</p><ul><li><p><code>sub</code>：搜索的子字符串。</p></li><li><p><code>start</code>：字符串开始搜索的位置。默认为第一个字符，第一个字符的索引为 <code>0</code>。</p></li><li><p><code>end</code>：字符串中结束搜索的位置（不包含），默认为 <code>len(str)</code>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;sososos&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;sos&quot;</span>)) <span class="comment"># 输出为 2 而不是 3，因为查找的是非重叠次数</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;sos&quot;</span>, <span class="number">3</span>))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;sos&quot;</span>, <span class="number">2</span>, <span class="number">5</span>))  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-5-encode-方法">1.3.5 encode() 方法</h3><ul><li><p>格式：<code>str.encode(encoding='UTF-8', errors='strict')</code>，返回以指定编码格式编码后的 <strong>新字符串</strong>，它是一个 <code>bytes</code> 对象。</p><ul><li><p><code>encoding</code>：要使用的编码，例：<code>UTF-8</code>。</p></li><li><p><code>errors</code>：设置不同错误的处理方案。默认为 <code>'strict'</code>，表示编码错误会抛出 <code>UnicodeError</code> 异常。 其他可能得值有 <code>'ignore'</code>, <code>'replace'</code>, <code>'xmlcharrefreplace'</code>, <code>'backslashreplace'</code> 以及通过 <code>codecs.register_error()</code> 注册的任何值。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;编码&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.encode(<span class="string">&quot;UTF-8&quot;</span>))  <span class="comment"># 输出：b&#x27;\xe7\xbc\x96\xe7\xa0\x81&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-6-endswith-方法">1.3.6 endswith() 方法</h3><ul><li><p>格式：<code>str.endswith(suffix[, start[, end]])</code>，用于检查字符串 <code>str</code> 在 <strong>指定范围</strong>（<code>start</code> ~ <code>end</code>（不包含））内是否是以指定子字符串 <code>suffix</code> <strong>结尾</strong>，如果是则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li><code>prefix</code> 可以是字符，字符串或者它们组成的元组（只要以元组中任意一个元素结尾都返回 <code>True</code>）。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.endswith(<span class="string">&quot;ld&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s.endswith(<span class="string">&quot;wo&quot;</span>, <span class="number">3</span>, <span class="number">8</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s.endswith((<span class="string">&quot;or&quot;</span>, <span class="string">&quot;el&quot;</span>, <span class="string">&quot;lo&quot;</span>), <span class="number">5</span>, <span class="number">9</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-7-expandtabs-方法">1.3.7 expandtabs() 方法</h3><ul><li><p>格式：<code>str.expandtabs(tabsize=8)</code>，用于将字符串中的 <code>tab</code> 符号 <code>\t</code> 转为指定数量的空格，<code>tab</code> 符号 <code>\t</code> 的默认空格数是 <code>8</code>。</p><ul><li><strong>注</strong>：输出空格数为一个制表符大小减去制表符前已有的字符。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello\tworld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)// helloworld</span><br><span class="line"><span class="built_in">print</span>(s.expandtabs())// helloworld</span><br><span class="line"><span class="built_in">print</span>(s.expandtabs(<span class="number">16</span>))// hello           world</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-8-find-方法">1.3.8 find() 方法</h3><ul><li><p>格式：<code>str.find(substr[, start=0[, end=len(str)]])</code>，返回 <strong>从左向右第一次</strong> 找到指定子字符串的索引位置，未找到则返回 <code>-1</code>。</p><ul><li><p><code>substr</code>：搜索的子字符串。</p></li><li><p><code>start</code>：搜索范围的开始。默认为第一个字符，第一个字符的索引为 <code>0</code>。</p></li><li><p><code>end</code>：搜索范围的结束（不包含），默认为 <code>len(str)</code>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;This is a test string&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.find(<span class="string">&quot;test&quot;</span>))  <span class="comment"># 输出：10</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-9-format-方法">1.3.9 format() 方法</h3><ul><li><a href="02.html">02.python3 基本数据类型</a> 中详细讲述了 <code>format()</code> 方法。</li></ul><h3 id="1-3-10-format-map-方法">1.3.10 format_map() 方法</h3><ul><li><p>格式：<code>str.format_map(mapping)</code>，与 <code>format(*args, **kwargs))</code> 方法不一样的地方是第一个参数为 <code>mapping</code> 类型的数据。<code>mapping</code> 是一种关联式的容器类型，它存储了对象与对象之间的映射关系。通过 <code>zip</code> 函数、<code>map</code> 函数等可以直接生成 <code>mapping</code> 类型的数据。字典（<code>dict</code>）是 <code>Python</code> 中唯一的映射类型。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;姓名：&#123;name&#125;，年龄：&#123;age&#125;&quot;</span></span><br><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;dong&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.format_map(person))  <span class="comment"># 输出：姓名：dong，年龄：18</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-11-index-方法">1.3.11 index() 方法</h3><ul><li><p>格式：<code>str.index(substr, start=0, end=len(str))</code>，返回 <strong>从左向右第一次</strong> 找到指定子字符串的索引位置，未找到则抛出一个异常 <code>ValueError: substring not found</code>。</p><ul><li><p><code>substr</code>：搜索的子字符串。</p></li><li><p><code>start</code>：搜索范围的开始。默认为第一个字符，第一个字符的索引为 <code>0</code>。</p></li><li><p><code>end</code>：搜索范围的结束（不包含），默认为 <code>len(str)</code>。</p></li></ul></li><li><p><strong>与 <code>find</code> 方法唯一区别</strong>：如果 <code>str</code> 中不包含 <code>substr</code>，<code>find</code> 返回 <code>-1</code>，<code>index</code> 则抛出一个异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;sososos&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&quot;os&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&quot;666&quot;</span>))  <span class="comment"># 抛出异常：ValueError: substring not found</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-12-isalnum-方法">1.3.12 isalnum() 方法</h3><ul><li><p>格式：<code>str.isalnum()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由字母、中文或数字组成</strong>。如果字符串至少有一个字符并且所有字符都是字母、中文或数字，则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li>数字可以是 <code>Unicode</code> 数字，罗马数字，<code>byte</code> 数字（单字节），全角数字（双字节）。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;123你好world&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;123 你好world&quot;</span></span><br><span class="line">s3 = <span class="string">&quot;123,你好world&quot;</span></span><br><span class="line">s4 = <span class="string">&quot;ⅠⅣⅤⅦ&quot;</span>  <span class="comment"># 罗马数字</span></span><br><span class="line">s5 = <span class="string">&quot;１２３&quot;</span>  <span class="comment"># 全角数字</span></span><br><span class="line">s6 = <span class="string">b&quot;123&quot;</span>  <span class="comment"># byte 数字</span></span><br><span class="line"><span class="built_in">print</span>(s1.isalnum())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isalnum())  <span class="comment"># False，因为字符串中包含空格</span></span><br><span class="line"><span class="built_in">print</span>(s3.isalnum())  <span class="comment"># False，因为字符串中包含逗号</span></span><br><span class="line"><span class="built_in">print</span>(s4.isalnum())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s5.isalnum())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s6.isalnum())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-13-isalpha-方法">1.3.13 isalpha() 方法</h3><ul><li><p>格式：<code>str.isalpha()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由字母或汉字组成</strong>。如果字符串至少有一个字符并且所有字符都是字母或汉字，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;你好world&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;123你好world&quot;</span></span><br><span class="line">s3 = <span class="string">&quot;123,你好world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isalpha())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isalpha())  <span class="comment"># False，因为字符串中包含数字</span></span><br><span class="line"><span class="built_in">print</span>(s3.isalpha())  <span class="comment"># False，因为字符串中包含逗号</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-14-isascii-方法">1.3.14 isascii() 方法</h3><ul><li><p>格式：<code>str.isascii()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由</strong> <code>ASCII</code> <strong>字符组成</strong>。如果字符串至少有一个字符并且所有字符都是 <code>ASCII</code> 字符，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;world&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;123,world&quot;</span></span><br><span class="line">s3 = <span class="string">&quot;123你好world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isascii())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isascii())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s3.isascii())  <span class="comment"># False，因为字符串中包含文字</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-15-isdecimal-方法">1.3.15 isdecimal() 方法</h3><ul><li><p>格式：<code>str.isdecimal()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由十进制数字符组成</strong>。如果字符串至少有一个字符并且所有字符都是十进制数字符，则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li><p><code>True</code>：<code>Unicode</code> 数字，全角数字（双字节）。</p></li><li><p><code>False</code>：汉字数字（例：壹、贰、叁、肆、伍、陆等），罗马数字，小数。</p></li><li><p><code>Error</code>：<code>byte</code> 数字（单字节）。<code>'bytes' object has no attribute 'isdecimal'</code>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;123&quot;</span>  <span class="comment"># Unicode 数字</span></span><br><span class="line">s2 = <span class="string">&quot;１２３&quot;</span>  <span class="comment"># 全角数字</span></span><br><span class="line">s3 = <span class="string">&quot;壹贰叁&quot;</span>  <span class="comment"># 汉字数字</span></span><br><span class="line">s4 = <span class="string">&quot;ⅠⅣⅤⅦ&quot;</span>  <span class="comment"># 罗马数字</span></span><br><span class="line"><span class="built_in">print</span>(s1.isdecimal())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isdecimal())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s3.isdecimal())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s4.isdecimal())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-16-isdigit-方法">1.3.16 isdigit() 方法</h3><ul><li><p>格式：<code>str.isdigit()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由数字字符组成</strong>。如果字符串至少有一个字符并且 <strong>所有字符</strong> 都是数字，则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li><p><code>True</code>：<code>Unicode</code> 数字，<code>byte</code> 数字（单字节），全角数字（双字节）。</p></li><li><p><code>False</code>：汉字数字，罗马数字，小数，负数，复数。</p></li><li><p><code>Error</code>：无。</p></li></ul></li><li><p>因为负号（<code>-</code>）、小数点（<code>.</code>）都不属于数字，所以只有非负整数返回 <code>True</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;123&quot;</span>  <span class="comment"># Unicode 数字</span></span><br><span class="line">s2 = <span class="string">b&quot;123&quot;</span>  <span class="comment"># byte 数字</span></span><br><span class="line">s3 = <span class="string">&quot;１２３&quot;</span>  <span class="comment"># 全角数字</span></span><br><span class="line">s4 = <span class="string">&quot;壹贰叁&quot;</span>  <span class="comment"># 汉字数字</span></span><br><span class="line">s5 = <span class="string">&quot;一二三&quot;</span>  <span class="comment"># 汉字数字</span></span><br><span class="line">s6 = <span class="string">&quot;3.1415&quot;</span>  <span class="comment"># 小数点不属于数字</span></span><br><span class="line">s7 = <span class="string">&quot;-1&quot;</span>  <span class="comment"># 负号不属于数字</span></span><br><span class="line">s8 = <span class="string">&quot;ⅠⅣⅤⅦ&quot;</span>  <span class="comment"># 罗马数字</span></span><br><span class="line"><span class="built_in">print</span>(s1.isdigit())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isdigit())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s3.isdigit())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s4.isdigit())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s5.isdigit())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s6.isdigit())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s7.isdigit())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s8.isdigit())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-17-isidentifier-方法">1.3.17 isidentifier() 方法</h3><ul><li><p>格式：<code>str.isidentifier()</code>，用于检测字符串 <code>str</code> 是否为有效标识符。如果字符串是有效标识符，则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li>有效标识符：仅包含字母（<code>A~Z</code>, <code>a ~ z</code>）、数字（<code>0 ~ 9</code>）和下划线（<code>_</code>），不以数字开头且不包含空格。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;0Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isidentifier())    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isidentifier())    <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-18-islower-方法">1.3.18 islower() 方法</h3><ul><li><p>格式：<code>str.islower()</code>，用于检测字符串 <code>str</code> 是否仅由小写字母组成。如果字符串至少有一个字符并且所有字符都是小写字母，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.islower())    <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s2.islower())    <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-19-isnumeric-方法">1.3.19 isnumeric() 方法</h3><ul><li><p>格式：<code>str.isnumeric()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由数值字符组成</strong>。如果字符串至少有一个字符并且所有字符都是数字，则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li><p><code>True</code>：<code>Unicode</code> 数字，全角数字（双字节），汉字数字，罗马数字。</p></li><li><p><code>False</code>：小数，负数，复数。</p></li><li><p><code>Error</code>：<code>byte</code> 数字（单字节）。<code>'bytes' object has no attribute 'isnumeric'</code>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;123&quot;</span>  <span class="comment"># Unicode 数字</span></span><br><span class="line">s2 = <span class="string">&quot;１２３&quot;</span>  <span class="comment"># 全角数字</span></span><br><span class="line">s3 = <span class="string">&quot;ⅠⅣⅤⅦ&quot;</span>  <span class="comment"># 罗马数字</span></span><br><span class="line">s4 = <span class="string">&quot;壹贰叁&quot;</span>  <span class="comment"># 汉字数字</span></span><br><span class="line">s5 = <span class="string">&quot;一二三&quot;</span>  <span class="comment"># 汉字数字</span></span><br><span class="line">s6 = <span class="string">&quot;3.1415&quot;</span>  <span class="comment"># 小数点不属于数字</span></span><br><span class="line">s7 = <span class="string">&quot;-1&quot;</span>  <span class="comment"># 负号不属于数字</span></span><br><span class="line"><span class="built_in">print</span>(s1.isnumeric())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isnumeric())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s3.isnumeric())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s4.isnumeric())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s5.isnumeric())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s6.isnumeric())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s7.isnumeric())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-20-isprintable-方法">1.3.20 isprintable() 方法</h3><ul><li><p>格式：<code>str.isprintable()</code>，用于检测字符串 <code>str</code> 是否仅由可打印字符组成。如果字符串至少有一个字符并且所有字符都是可打印字符，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;\0 Hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isprintable())    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isprintable())    <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-21-isspace-方法">1.3.21 isspace() 方法</h3><ul><li><p>格式：<code>str.isspace()</code>，用于检测字符串 <code>str</code> 是否 <strong>仅由空白符</strong>（<strong>空格</strong>、<strong>换行符</strong>、<strong>制表符等</strong>）<strong>组成</strong>。如果字符串至少有一个字符并且所有字符都是空白符，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;   hello\tworld\n   &quot;</span></span><br><span class="line">s2 = <span class="string">&quot;     \t   \n    &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isspace())  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s2.isspace())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-22-istitle-方法">1.3.22 istitle() 方法</h3><ul><li><p>格式：<code>str.istitle()</code>，用于检测字符串 <code>str</code> 中所有单词的首字母是否为大写，且其他字母为小写。如果字符串包含单词，且所有单词的首字母大写，其他字母为小写，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.istitle())    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.istitle())    <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-23-isupper-方法">1.3.23 isupper() 方法</h3><ul><li><p>格式：<code>str.isupper()</code>，用于检测字符串 <code>str</code> 中所有单词的字母是否都为大写。如果字符串包含单词，且所有单词的所有字母都为大写，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;HELLO WORLD&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isupper())    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isupper())    <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-24-join-方法">1.3.24 join() 方法</h3><ul><li><p>格式：<code>str.join(iterable)</code>，用于将 <strong>可迭代对象</strong> <code>iterable</code>（<strong>对象中的所有元素必须为字符串类型</strong>）中的元素以指定字符串 <code>str</code> 连接，返回一个 <strong>新字符串</strong>。</p><ul><li><p>可迭代对象 <code>iterable</code>：<code>string</code>、<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code> 等。要求可迭代对象中所有元素的数据类型必须为字符串。</p></li><li><p><strong>注</strong>：不管函数还是方法，只要形参类型为可迭代对象，意味着函数或方法将对可迭代对象进行 <strong>逐元素操作</strong>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sign = <span class="string">&quot;-&quot;</span></span><br><span class="line">s = <span class="string">&quot;welcome to python&quot;</span></span><br><span class="line">lst = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br><span class="line">tup = (<span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">dic = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line">se = &#123;<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>, <span class="string">&quot;wowo&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(sign.join(s))  <span class="comment"># w-e-l-c-o-m-e- -t-o- -p-y-t-h-o-n</span></span><br><span class="line"><span class="built_in">print</span>(sign.join(lst))  <span class="comment"># 1-2-3</span></span><br><span class="line"><span class="built_in">print</span>(sign.join(tup))  <span class="comment"># 5-6-7</span></span><br><span class="line"><span class="built_in">print</span>(sign.join(dic))  <span class="comment"># name-age，字典只进行键连接</span></span><br><span class="line"><span class="built_in">print</span>(sign.join(se))  <span class="comment"># wowo-haha-hehe，集合无序，所以这里的输出不是确定的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-25-ljust-方法">1.3.25 ljust() 方法</h3><ul><li><p>格式：<code>str.ljust(length[, fillchar])</code>，返回一个在指定长度 <code>length</code> 左对齐的 <strong>新字符串</strong>（<code>length</code> 小于字符串长度则直接返回字符串）。</p><ul><li><code>fillchar</code> 为 <strong>右侧填充</strong> 的字符，默认为空格。必须是单个字符，否则报错：<code>TypeError: The fill character must be exactly one character long</code>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">cs1 = s.ljust(<span class="number">8</span>)  <span class="comment"># 指定长度 8 小于字符串长度 11，返回原字符串</span></span><br><span class="line">cs2 = s.ljust(<span class="number">17</span>, <span class="string">&quot;-&quot;</span>)  <span class="comment"># 指定长度 17，右侧使用 - 填充</span></span><br><span class="line"><span class="built_in">print</span>(cs1)  <span class="comment"># hello world</span></span><br><span class="line"><span class="built_in">print</span>(cs2)  <span class="comment"># hello world------</span></span><br><span class="line"><span class="built_in">print</span>(cs1 == s)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-26-lower-方法">1.3.26 lower() 方法</h3><ul><li><p>格式：<code>str.lower()</code>，方法返回一个所有字符均为小写的 <strong>新字符串</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HELLO world&quot;</span>.lower())  <span class="comment"># 输出：hello world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-27-lstrip-方法">1.3.27 lstrip() 方法</h3><ul><li><p>格式：<code>str.lstrip([chars])</code>，移除字符串 <code>str</code> <strong>左侧</strong> 指定的 <strong>字符序列</strong> <code>chars</code>（默认空白符），直到遇到不在 <code>chars</code> 序列中的字符，返回移除后的 <strong>新字符串</strong>。</p><ul><li><p>字符序列：<code>chars</code> 中所有字符的 <strong>所有组合</strong>，而不是字符组成的字符串。</p><ul><li>例：<code>fan</code> 的所有组合：<code>f</code>、<code>a</code>、<code>n</code>、<code>fa</code>、<code>fn</code>、<code>an</code>、<code>af</code>、<code>na</code>、<code>nf</code>、<code>fan</code>、<code>fna</code>、<code>anf</code>、<code>afn</code>、<code>naf</code> 和 <code>nfa</code>。</li></ul></li><li><p>空白符：空格（<code>' '</code>）、换行符（<code>\n</code>）、制表符（<code>\t</code>）等。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;   hello world\t&quot;</span></span><br><span class="line">ns1 = s.lstrip()  <span class="comment"># 默认移除空白符</span></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">ns2 = s.lstrip(<span class="string">&quot;hdol&quot;</span>)  <span class="comment"># 移除 hdol 组成的字符序列</span></span><br><span class="line"><span class="built_in">print</span>(ns1)  <span class="comment"># 输出 &quot;hello world    &quot;，移除了字符串左侧的空格，保留了制表符</span></span><br><span class="line"><span class="built_in">print</span>(ns2)  <span class="comment"># 输出 &quot;ello world&quot;，移除了字符串左侧的 h</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-28-partition-方法">1.3.28 partition() 方法</h3><ul><li><p>格式：<code>str.partition(value)</code>，搜索指定字符串 <code>value</code> 的 <strong>第一个匹配项</strong>，并将 <code>str</code> 拆分为包含三个元素的 <strong>元组</strong>。</p><ul><li><p>第一个元素包含第一个匹配项之前的部分。</p></li><li><p>第二个元素为匹配项本身。</p></li><li><p>第三个元素包含第一个匹配项后面的部分。</p></li></ul></li><li><p>如果字符串 <code>value</code> 未被找到，则返回的元组包含 <strong>原字符串</strong> 及 <strong>两个空字符串</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.partition(<span class="string">&quot;ol&quot;</span>))  <span class="comment"># (&#x27;hello world&#x27;, &#x27;&#x27;, &#x27;&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(s.partition(<span class="string">&quot;lo&quot;</span>))  <span class="comment"># (&#x27;hel&#x27;, &#x27;lo&#x27;, &#x27; world&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-29-removeprefix-方法">1.3.29 removeprefix() 方法</h3><ul><li>格式：<code>str.removeprefix(prefix, /)</code>，返回一个删除指定 <strong>前缀</strong> <code>prefix</code> 的新字符串。如果前缀不存在则返回原始字符串的副本。<code>/</code> 表示在 <code>/</code> 之前的参数都必须为位置参数。</li></ul><h3 id="1-3-30-removesuffix-方法">1.3.30 removesuffix() 方法</h3><ul><li>格式：<code>str.removesuffix(suffix, /)</code>，返回一个删除指定 <strong>后缀</strong> <code>suffix</code> 的新字符串。如果后缀不存在则返回原始字符串的副本。<code>/</code> 表示在 <code>/</code> 之前的参数都必须为位置参数。</li></ul><h3 id="1-3-31-replace-方法">1.3.31 replace() 方法</h3><ul><li><p>格式：<code>str.replace(old, new[, max])</code>，返回一个将 <code>str</code> 中的 <code>old</code>（旧字符串）替换成 <code>new</code>（新字符串）的 <strong>新字符串</strong>。</p><ul><li>如果指定第三个参数 <code>max</code>（默认为 <code>-1</code>，全部替换），则替换不超过 <code>max</code> 次。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello dong dong&quot;</span></span><br><span class="line">ns1 = s.replace(<span class="string">&quot;dong&quot;</span>, <span class="string">&quot;fan&quot;</span>)  <span class="comment"># 全部替换</span></span><br><span class="line">ns2 = s.replace(<span class="string">&quot;dong&quot;</span>, <span class="string">&quot;fan&quot;</span>, <span class="number">1</span>)  <span class="comment"># 只替换一次</span></span><br><span class="line">space_r = s.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;-&quot;</span>)  <span class="comment"># 空格替换为短横线</span></span><br><span class="line">dash_r = s.replace(<span class="string">&quot;&quot;</span>, <span class="string">&quot;-&quot;</span>)  <span class="comment"># 所有字符以短横线分隔：每个字符两侧都具有空字符串，所以使用短横线替换空字符串即可</span></span><br><span class="line"><span class="built_in">print</span>(ns1)  <span class="comment"># hello fan fan</span></span><br><span class="line"><span class="built_in">print</span>(ns2)  <span class="comment"># hello fan dong</span></span><br><span class="line"><span class="built_in">print</span>(space_r)  <span class="comment"># hello-dong-dong</span></span><br><span class="line"><span class="built_in">print</span>(dash_r)  <span class="comment"># -h-e-l-l-o- -d-o-n-g- -d-o-n-g-</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-32-rfind-方法">1.3.32 rfind() 方法</h3><ul><li><p>格式：<code>str.find(substr, start=0, end=len(str))</code>，返回 <strong>从右向左第一次</strong> 找到指定子字符串的索引位置，未找到则返回 <code>-1</code>。</p><ul><li><p><code>substr</code>：搜索的子字符串。</p></li><li><p><code>start</code>：搜索范围的开始。默认为第一个字符，第一个字符的索引为 <code>0</code>。</p></li><li><p><code>end</code>：搜索范围的结束（不包含），默认为 <code>len(str)</code>。</p></li><li><p><strong>注</strong>：<strong>字符串并未倒置</strong>。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rfind(<span class="string">&quot;l&quot;</span>))  <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">print</span>(s.rfind(<span class="string">&quot;l&quot;</span>, <span class="number">1</span>, <span class="number">7</span>))  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(s.rfind(<span class="string">&quot;l&quot;</span>, <span class="number">5</span>, <span class="number">9</span>))  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-33-rindex-方法">1.3.33 rindex() 方法</h3><ul><li><p>格式：<code>str.rindex(substr, start=0, end=len(str))</code>，返回 <strong>从右向左第一次</strong> 找到指定子字符串的索引位置，未找到则抛出一个异常 <code>ValueError: substring not found</code>。</p><ul><li><p><code>substr</code>：搜索的子字符串。</p></li><li><p><code>start</code>：搜索范围的开始。默认为第一个字符，第一个字符的索引为 <code>0</code>。</p></li><li><p><code>end</code>：搜索范围的结束（不包含），默认为 <code>len(str)</code>。</p></li><li><p><strong>注</strong>：<strong>字符串并未倒置</strong>。</p></li></ul></li><li><p><strong>与 <code>rfind</code> 方法唯一区别</strong>：如果 <code>str</code> 中不包含 <code>substr</code>，<code>rfind</code> 返回 <code>-1</code>，<code>rindex</code> 则抛出一个异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rindex(<span class="string">&quot;l&quot;</span>))  <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">print</span>(s.rindex(<span class="string">&quot;l&quot;</span>, <span class="number">1</span>, <span class="number">7</span>))  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(s.rindex(<span class="string">&quot;l&quot;</span>, <span class="number">5</span>, <span class="number">9</span>))  <span class="comment"># 抛出异常 ValueError: substring not found</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-34-rjust-方法">1.3.34 rjust() 方法</h3><ul><li><p>格式：<code>str.rjust(length[, fillchar])</code>，返回一个在指定长度 <code>length</code> 右对齐的 <strong>新字符串</strong>（<code>length</code> 小于字符串长度则直接返回字符串）。</p><ul><li><code>fillchar</code> 为 <strong>左侧填充</strong> 的字符，默认为空格。必须是单个字符，否则报错：<code>TypeError: The fill character must be exactly one character long</code>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">cs1 = s.rjust(<span class="number">8</span>)  <span class="comment"># 指定长度 8 小于字符串长度 11，返回原字符串</span></span><br><span class="line">cs2 = s.rjust(<span class="number">17</span>, <span class="string">&quot;-&quot;</span>)  <span class="comment"># 指定长度 17，左侧使用 - 填充</span></span><br><span class="line"><span class="built_in">print</span>(cs1)  <span class="comment"># hello world</span></span><br><span class="line"><span class="built_in">print</span>(cs2)  <span class="comment"># ------hello world</span></span><br><span class="line"><span class="built_in">print</span>(cs1 == s)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-35-rpartition-方法">1.3.35 rpartition() 方法</h3><ul><li><p>格式：<code>str.rpartition(value)</code>，搜索指定字符串 <code>value</code> 的 <strong>最后一个匹配项</strong>，并将 <code>str</code> 拆分为包含三个元素的 <strong>元组</strong>。</p><ul><li><p>第一个元素包含最后一个匹配项之前的部分。</p></li><li><p>第二个元素为匹配项本身。</p></li><li><p>第三个元素包含最后一个匹配项后面的部分。</p></li></ul></li><li><p>如果字符串 <code>value</code> 未被找到，则返回的元组包含 <strong>两个空字符串</strong> 及 <strong>原字符串</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rpartition(<span class="string">&quot;ol&quot;</span>))  <span class="comment"># (&#x27;&#x27;, &#x27;&#x27;, &#x27;hello world&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(s.rpartition(<span class="string">&quot;lo&quot;</span>))  <span class="comment"># (&#x27;hel&#x27;, &#x27;lo&#x27;, &#x27; world&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-36-rsplit-方法">1.3.36 rsplit() 方法</h3><ul><li><p>格式：<code>str.split(sep=None, maxsplit=-1)</code>，通过指定分隔符 <code>sep</code> 对字符串进行分割，返回值为从 <strong>右侧</strong> 开始 <strong>分割</strong> 后的 <strong>字符串列表</strong>（分割结果不包含分隔符）。<strong>注</strong>：返回的字符串列表顺序依然为从左向右。</p><ul><li><p><code>sep</code> 表示用于分割字符串的分隔符，默认为所有的空白符（空格、换行符、制表符等）。</p><ul><li><p><strong>注</strong>：当使用默认分割符对字符串进行分割时，返回结果中的空字符串会被丢弃。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;   hello\tworld\n   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot; &quot;</span>))  <span class="comment"># [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;hello\tworld\n&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot;\t&quot;</span>))  <span class="comment"># [&#x27;   hello&#x27;, &#x27;world\n   &#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot;\n&quot;</span>))  <span class="comment"># [&#x27;   hello\tworld&#x27;, &#x27;   &#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>maxsplit</code> 表示最大分隔次数，默认为 <code>-1</code>，即分隔所有，返回的字符串列表长度为 <code>maxsplit + 1</code>。</p><ul><li>如果 <code>maxsplit</code> 大于最大可分割数，则分隔数量以最大分割数为准。</li></ul></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world, welcome to python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world,&#x27;, &#x27;welcome&#x27;, &#x27;to&#x27;, &#x27;python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot;,&quot;</span>))  <span class="comment"># [&#x27;hello world&#x27;, &#x27; welcome to python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot;l&quot;</span>))  <span class="comment"># [&#x27;he&#x27;, &#x27;&#x27;, &#x27;o wor&#x27;, &#x27;d, we&#x27;, &#x27;come to python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot;l&quot;</span>, <span class="number">3</span>))  <span class="comment"># [&#x27;hel&#x27;, &#x27;o wor&#x27;, &#x27;d, we&#x27;, &#x27;come to python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s.rsplit(<span class="string">&quot;l&quot;</span>, <span class="number">3</span>)))  <span class="comment"># 输出 maxsplit = 3，返回的字符串列表长度为 4</span></span><br><span class="line"><span class="built_in">print</span>(s.rsplit(<span class="string">&quot;l&quot;</span>, <span class="number">8</span>))  <span class="comment"># [&#x27;he&#x27;, &#x27;&#x27;, &#x27;o wor&#x27;, &#x27;d, we&#x27;, &#x27;come to python&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>当 <code>rsplit</code> 方法没有指定最大分割次数 <code>maxsplit</code> 时，返回的结果与 <code>split</code> 方法完全相同。</p></li></ul><h3 id="1-3-37-rstrip-方法">1.3.37 rstrip() 方法</h3><ul><li><p>格式：<code>str.rstrip([chars])</code>，移除字符串 <code>str</code> <strong>右侧</strong> 指定的 <strong>字符序列</strong> <code>chars</code>（默认空白符），直到遇到不在 <code>chars</code> 序列中的字符，返回移除后的 <strong>新字符串</strong>。</p><ul><li><p>字符序列：<code>chars</code> 中所有字符的 <strong>所有组合</strong>，而不是字符组成的字符串。</p><ul><li>例：<code>fan</code> 的所有组合：<code>f</code>、<code>a</code>、<code>n</code>、<code>fa</code>、<code>fn</code>、<code>an</code>、<code>af</code>、<code>na</code>、<code>nf</code>、<code>fan</code>、<code>fna</code>、<code>anf</code>、<code>afn</code>、<code>naf</code> 和 <code>nfa</code>。</li></ul></li><li><p>空白符：空格（<code>' '</code>）、换行符（<code>\n</code>）、制表符（<code>\t</code>）等。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;   hello world\n&quot;</span></span><br><span class="line">ns1 = s.rstrip()  <span class="comment"># 默认移除空白符</span></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">ns2 = s.rstrip(<span class="string">&quot;hdol&quot;</span>)  <span class="comment"># 移除 hdol 组成的字符序列</span></span><br><span class="line"><span class="built_in">print</span>(ns1)  <span class="comment"># 输出 &quot;   hello world&quot;，移除了字符串右侧的换行符</span></span><br><span class="line"><span class="built_in">print</span>(ns2)  <span class="comment"># 输出 &quot;hello wor&quot;，移除了字符串右侧的 ld</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-38-split-方法">1.3.38 split() 方法</h3><ul><li><p>格式：<code>str.split(sep=None, maxsplit=-1)</code>，通过指定分隔符 <code>sep</code> 对字符串进行分割，返回值为从 <strong>左侧</strong> 开始 <strong>分割</strong> 后的 <strong>字符串列表</strong>（分割结果不包含分隔符）。</p><ul><li><p><code>sep</code> 表示用于分割字符串的分隔符，默认为所有的空白符（空格、换行符、制表符等）。</p><ul><li><p><strong>注</strong>：当使用默认分割符对字符串进行分割时，返回结果中的空字符串会被丢弃。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;   hello\tworld\n   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot; &quot;</span>))  <span class="comment"># [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;hello\tworld\n&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot;\t&quot;</span>))  <span class="comment"># [&#x27;   hello&#x27;, &#x27;world\n   &#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot;\n&quot;</span>))  <span class="comment"># [&#x27;   hello\tworld&#x27;, &#x27;   &#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>maxsplit</code> 表示最大分隔次数，默认为 <code>-1</code>，即分隔所有，返回的字符串列表长度为 <code>maxsplit + 1</code>。</p><ul><li>如果 <code>maxsplit</code> 大于最大可分割数，则分隔数量以最大分割数为准。</li></ul></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world, welcome to python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world,&#x27;, &#x27;welcome&#x27;, &#x27;to&#x27;, &#x27;python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot;,&quot;</span>))  <span class="comment"># [&#x27;hello world&#x27;, &#x27; welcome to python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot;l&quot;</span>))  <span class="comment"># [&#x27;he&#x27;, &#x27;&#x27;, &#x27;o wor&#x27;, &#x27;d, we&#x27;, &#x27;come to python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot;l&quot;</span>, <span class="number">3</span>))  <span class="comment"># [&#x27;he&#x27;, &#x27;&#x27;, &#x27;o wor&#x27;, &#x27;d, welcome to python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s.split(<span class="string">&quot;l&quot;</span>, <span class="number">3</span>)))  <span class="comment"># 输出 maxsplit = 3，返回的字符串列表长度为 4</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot;l&quot;</span>, <span class="number">8</span>))  <span class="comment"># [&#x27;he&#x27;, &#x27;&#x27;, &#x27;o wor&#x27;, &#x27;d, we&#x27;, &#x27;come to python&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-39-splitlines-方法">1.3.39 splitlines() 方法</h3><ul><li>格式：<code>str.splitlines([keepends])</code>，按照行（’<code>\r</code>’, ‘<code>\r\n</code>’, ‘<code>\n</code>’）进行分隔，返回一个包含各行作为元素的列表。如果参数 <code>keepends</code> 为 <code>False</code>（默认），不包含换行符，如果为 <code>True</code>，则保留换行符。</li></ul><h3 id="1-3-40-startswith-方法">1.3.40 startswith() 方法</h3><ul><li><p>格式：<code>str.startswith(prefix[, start=0[, end=len(string)])</code>，用于检查字符串 <code>str</code> 在 <strong>指定范围</strong>（<code>start</code> ~ <code>end</code>（不包含））内是否是以指定子字符串 <code>prefix</code> <strong>开头</strong>，如果是则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li><code>prefix</code> 可以是字符，字符串或者它们组成的元组（只要以元组中任意一个元素开头都返回 <code>True</code>）。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.startswith(<span class="string">&quot;he&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s.startswith(<span class="string">&quot;l&quot;</span>, <span class="number">3</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s.startswith((<span class="string">&quot;ol&quot;</span>, <span class="string">&quot;el&quot;</span>, <span class="string">&quot;lo&quot;</span>), <span class="number">3</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-41-strip-方法">1.3.41 strip() 方法</h3><ul><li><p>格式：<code>str.strip([chars])</code>，移除字符串 <code>str</code> <strong>左右两侧</strong> 指定的 <strong>字符序列</strong> <code>chars</code>（默认空白符），直到遇到不在 <code>chars</code> 序列中的字符，返回移除后的 <strong>新字符串</strong>。</p><ul><li><p>字符序列：<code>chars</code> 中所有字符的 <strong>所有组合</strong>，而不是字符组成的字符串。</p><ul><li>例：<code>fan</code> 的所有组合：<code>f</code>、<code>a</code>、<code>n</code>、<code>fa</code>、<code>fn</code>、<code>an</code>、<code>af</code>、<code>na</code>、<code>nf</code>、<code>fan</code>、<code>fna</code>、<code>anf</code>、<code>afn</code>、<code>naf</code> 和 <code>nfa</code>。</li></ul></li><li><p>空白符：空格（<code>' '</code>）、换行符（<code>\n</code>）、制表符（<code>\t</code>）等。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;   hello world\n&quot;</span></span><br><span class="line">ns1 = s.strip()  <span class="comment"># 默认移除空白符</span></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">ns2 = s.strip(<span class="string">&quot;hdol&quot;</span>)  <span class="comment"># 移除 hdol 组成的字符序列</span></span><br><span class="line"><span class="built_in">print</span>(ns1)  <span class="comment"># 输出 &quot;hello world&quot;，移除了空格与换行符</span></span><br><span class="line"><span class="built_in">print</span>(ns2)  <span class="comment"># 输出 &quot;ello wor&quot;，移除了 h 和 ld</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-42-swapcase-方法">1.3.42 swapcase() 方法</h3><ul><li><p>格式：<code>str.swapcase()</code>，返回一个将大写字母转换为小写字母，小写字母转换为大写字母的 <strong>新字符串</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello DONG, Welcome to python&quot;</span>.swapcase())  <span class="comment"># 输出：hELLO dong, wELCOME TO PYTHON</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-43-title-方法">1.3.43 title() 方法</h3><ul><li><p>格式：<code>str.title()</code>，返回一个所有 <strong>单词</strong> 首字母均为大写，其余字母均为小写的 <strong>新字符串</strong>。</p><ul><li><strong>注</strong>：<strong>判断单词的方式仅以空格字符为标准</strong>，<strong>即一段连续的字符就为单词</strong>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world, welcome to python&quot;</span>.title())  <span class="comment"># 输出：Hello World, Welcome To Python</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-44-upper-方法">1.3.44 upper() 方法</h3><ul><li><p>格式：<code>str.upper()</code>，返回一个所有字符均为大写的 <strong>新字符串</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world, welcome to python&quot;</span>.upper())  <span class="comment"># 输出：HELLO WORLD, WELCOME TO PYTHON</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-45-zfill-方法">1.3.45 zfill() 方法</h3><ul><li>格式：<code>str.zfill(length)</code>，返回一个长度为 <code>length</code>，用 <code>0</code> 填充空位的右对齐 <strong>新字符串</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 序列（列表、元组）</title>
      <link href="/posts/python/python3/03.html"/>
      <url>/posts/python/python3/03.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、Python 序列</h1><h2 id="1-1-概述">1.1 概述</h2><ul><li><p><code>Python</code> 序列（<code>Sequence</code>）是指按 <strong>特定顺序</strong> 依次排列的一组数据。</p></li><li><p>序列三要素：有元素存在，元素之间有顺序，元素可以使用下标进行索引。</p></li><li><p>序列类型包括 <strong>列表</strong>（<code>&lt;class 'list'&gt;</code>）、<strong>元组</strong>（<code>&lt;class 'tuple'&gt;</code>）和 <strong>字符串</strong>（<code>&lt;class 'str'&gt;</code>）。</p></li><li><p>列表和元组相似，它们都 <strong>按顺序</strong> 保存元素，每个元素都有自己的 <strong>索引</strong>，因此列表和元组的元素都可以通过索引（<code>index</code>）来访问。它们的 <strong>区别</strong> 在于：<strong>列表可以修改</strong>，<strong>而元组不可修改</strong>。</p></li><li><p>字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。</p></li><li><p><strong>字典</strong>（<code>&lt;class 'dict'&gt;</code>）和 <strong>集合</strong>（<code>&lt;class 'set'&gt;</code>）不是序列类型，可以使用 <code>collections</code> 库中的 <code>abc</code> 模块里面的 <code>Sequence</code> <strong>基类</strong> 来判断一个类型是不是属于序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">list</span>() <span class="comment"># 创建空列表</span></span><br><span class="line">tup = <span class="built_in">tuple</span>() <span class="comment"># 创建空元组</span></span><br><span class="line">ss = <span class="built_in">str</span>() <span class="comment"># 创建空字符串</span></span><br><span class="line">d = <span class="built_in">dict</span>() <span class="comment"># 创建空字典</span></span><br><span class="line">st = <span class="built_in">set</span>() <span class="comment"># 创建空集合</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, abc.<span class="type">Sequence</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(tup, abc.<span class="type">Sequence</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(ss, abc.<span class="type">Sequence</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(d, abc.<span class="type">Sequence</span>)) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(st, abc.<span class="type">Sequence</span>)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-序列索引">1.2 序列索引</h2><ul><li><p>序列中，每个元素都有属于自己的编号（索引）：从起始元素开始，索引值从 <code>0</code> 开始递增。</p></li><li><p>序列索引格式：<code>seq[index]</code>。</p></li><li><p><code>Python</code> 支持索引值是 <strong>负数</strong>，此类索引是 <strong>从右向左</strong> 计数：从最后一个元素开始，索引值从 <code>-1</code> 开始递减。</p><ul><li>负值索引的最小值为序列长度的相反数，即正值索引最大值 + 1 的相反数。</li></ul></li><li><p>序列索引超出范围时报错：<code>IndexError: string index out of range</code>。</p></li></ul><h2 id="1-3-序列切片">1.3 序列切片</h2><ul><li><p>切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过 <strong>切片</strong> 操作，可以 <strong>生成一个新的序列</strong>。</p></li><li><p>序列实现切片操作的语法格式：<code>seqName[start : end : step] = iterable</code></p><ul><li><p><code>seqName</code>：表示序列的名称；</p></li><li><p><code>start</code>：表示切片的 <strong>开始</strong> 索引位置（<strong>包含</strong> 该位置），可以为负。可选，默认为 <code>0</code>，即序列开始。</p></li><li><p><code>end</code>：表示切片的 <strong>结束</strong> 索引位置（<strong>不包含</strong> 该位置），可以为负。可选，默认为序列长度，即 <code>len(seq)</code>。</p><ul><li><strong>当</strong> <code>end</code> <strong>超出序列长度时</strong>，<strong>不会报错</strong>，<strong>默认截取到序列结尾</strong>。</li></ul></li><li><p><code>step</code>：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，默认为 <code>1</code>。可选，如果 <code>step</code> 的值大于 <code>1</code>，则在进行切片操作时，会 “跳跃式” 的取元素。</p><ul><li><p><code>step</code> 为 <strong>正</strong> 表示 <strong>从左向右</strong>，要求 <code>start</code> &lt; <code>end</code>，否则为空。</p><ul><li><p>如果 <code>start</code> 省略，默认为 <code>0</code> 或 <code>-len(seq)</code>；</p></li><li><p>如果 <code>end</code> 省略，则默认为 <code>len(seq)</code>。</p></li></ul></li><li><p><code>step</code> 为 <strong>负</strong> 表示 <strong>从右向左</strong>，要求 <code>start</code> &gt; <code>end</code>，否则为空。</p><ul><li><p>如果 <code>start</code> 省略，默认为 <code>-1</code> 或 <code>len(seq)-1</code>；</p></li><li><p>如果 <code>end</code> 省略，则默认为 <code>-len(seq)-1</code>。</p></li></ul></li></ul></li><li><p><code>iterable</code>：可迭代对象，表示给序列的切片部赋予的值必须是可迭代类型。否则报错：<code>TypeError: can only assign an iterable</code>。</p><ul><li>注：当 <code>iterable</code> 为一个字符串时，字符串会被分成单个字符插入序列中。</li></ul></li></ul></li><li><p><strong>当</strong> <code>start</code> <strong>或</strong> <code>end</code> <strong>超出有效索引范围​时</strong>，<strong>切片操作不会抛出异常</strong>，<strong>而是仅保留有效索引范围的值</strong>。</p></li><li><p><strong>索引会降维</strong>（每索引一次降低一个维度），<strong>切片不会降维</strong>。</p></li></ul><h2 id="1-4-序列相加">1.4 序列相加</h2><ul><li><code>Python</code> 中，支持两种 <strong>类型相同</strong> 的序列使用 “<code>+</code>” 运算符做相加操作，它会将两个序列进行 <strong>连接</strong> 并生成一个新的序列，这个新的序列 <strong>不会去除重复</strong> 的元素且 <strong>不改变序列类型</strong>。</li></ul><h2 id="1-5-序列相乘">1.5 序列相乘</h2><ul><li><p><code>Python</code> 中，使用数字 <code>n</code> 乘以一个序列会生成新的序列，其内容为原来序列被重复 <code>n</code> 次的结果。</p></li><li><p>特殊地，列表类型在进行乘法运算时，可以实现初始化指定长度列表的功能。例：<code>list = [None] * 5</code> 将创建一个长度为 <code>5</code>的列表，列表中的每个元素都是 <code>None</code>，即 <code>[None, None, None, None, None]</code>。</p></li></ul><h2 id="1-6-检查元素是否为序列成员">1.6 检查元素是否为序列成员</h2><ul><li><p><code>Python</code> 中，可以使用 <code>in</code> <strong>关键字</strong> 检查某元素是否为序列成员，格式：<code>value in sequence</code>，其中 <code>value</code> 表示要检查的元素，<code>sequence</code> 表示指定的序列。</p><ul><li>集合和字典同样支持 <code>in</code> 操作符，其中字典的 <code>in</code> 操作符用于判断 <strong>键</strong> 是否存在于字典中，如果存在返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li><li><p><code>not in</code> 关键字和 <code>in</code> 关键字用法相同，但功能恰好相反的，它用来检查某个元素是否不包含在指定的序列中。</p></li></ul><h2 id="1-7-和序列相关的内置函数">1.7 和序列相关的内置函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>len(seq)</code></td><td>计算序列的长度（包含多少个元素）。</td></tr><tr><td><code>map(function, iterable, ...)</code></td><td>根据提供的函数 <code>function</code> 对 <code>iterable</code> 序列做映射。</td></tr><tr><td><code>max(seq)</code></td><td>查找序列中的最大元素。</td></tr><tr><td><code>min(seq)</code></td><td>查找序列中的最小元素。</td></tr><tr><td><code>sum(seq)</code></td><td>计算序列中的元素和，元素只能是数字</td></tr><tr><td><code>sorted(iterable, [key], reverse=False)</code></td><td>对元素排序，默认为升序，括号内增加参数<code>reverse=True</code>，则为降序</td></tr><tr><td><code>range([start=0,] stop[, step=1])</code></td><td>返回的是一个可迭代对象。</td></tr><tr><td><code>reversed(seq)</code></td><td>反向排列序列中的元素</td></tr><tr><td><code>enumerate()</code></td><td>将序列组合为一个索引序列，多用于 <code>for</code> 循环。</td></tr><tr><td><code>list(seq)</code></td><td>将序列 <code>seq</code> 转换为列表，注意不能转换字典。</td></tr><tr><td><code>str(seq)</code></td><td>将序列 <code>seq</code> 整体转换为字符串。</td></tr><tr><td><code>tuple(seq)</code></td><td>将序列 <code>seq</code> 转换为元组对象。</td></tr><tr><td><code>dict(d)</code></td><td>创建一个字典对象，<code>d</code> 必须是一个序列 <code>(key, value)</code> 的元组。</td></tr><tr><td><code>set(seq)</code></td><td>将序列 <code>seq</code> 转换为可变集合对象。</td></tr><tr><td><code>frozenset(seq)</code></td><td>将序列 <code>seq</code> 转换为不可变集合对象。</td></tr><tr><td><code>zip(*iterables)</code></td><td>将可迭代的对象（如：列表、元组、字符串等）作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的可迭代对象。</td></tr></tbody></table><h3 id="1-7-1-enumerate-函数">1.7.1 enumerate 函数</h3><ul><li><p><code>enumerate(iterable, [start=0])</code>：用于遍历 <strong>可迭代对象</strong>，<code>enumerate</code> 函数返回一个迭代器，迭代器的 <code>__next__</code> 方法返回一个元组，元组的第一个元素是从 <code>0</code> 开始的计数器，第二个元素是计数器所对应的可迭代对象里的元素。<code>start</code> 参数表示计数器开始的数值，默认从 <code>0</code> 开始。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"><span class="comment"># 输出：[(0, 10), (1, 20), (2, 30), (3, 40), (4, 50)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">enumerate</span>(li)))</span><br><span class="line"><span class="comment"># 输出：[(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">enumerate</span>(li, start=<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 0 10</span></span><br><span class="line"><span class="comment"># 1 20</span></span><br><span class="line"><span class="comment"># 2 30</span></span><br><span class="line"><span class="comment"># 3 40</span></span><br><span class="line"><span class="comment"># 4 50</span></span><br><span class="line"><span class="keyword">for</span> num, ele <span class="keyword">in</span> <span class="built_in">enumerate</span>(li):</span><br><span class="line">    <span class="built_in">print</span>(num, ele)</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-2-len-函数">1.7.2 len 函数</h3><ul><li><p><code>len(sequence)</code>：返回可迭代对象（列表、元组、字典、集合和字符串等）的长度（元素个数）。</p><ul><li><code>sequence</code> 是 <strong>必需参数</strong>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst)) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-3-map-函数">1.7.3 map 函数</h3><ul><li><p><code>map(function, iterable, ...)</code>：返回一个将 <code>function</code> 应用于 <code>iterable</code> 中每一个元素的迭代器，可以使用 <code>list()</code> 函数转成列表。</p><ul><li><p><code>function</code> 参数可以是 <code>lambda</code> 函数也可以是自定义函数。</p><ul><li><p><code>lambda</code> 函数（匿名函数）语法格式：<code>lambda argument_list:expersion</code></p></li><li><p><code>argument_list</code> 是参数列表，它的结构与 <code>Python</code> 中函数的参数列表是一样的。<code>map</code> 函数中，<code>argument_list</code> 来源于 <code>iterable</code>。</p></li><li><p><code>expression</code> 是一个关于参数的表达式，表达式中出现的参数需要在 <code>argument_list</code> 中有定义，并且表达式只能是单行的。<code>map</code> 函数中，<code>expression</code> 作用于 <code>iterable</code> 中的每一项。</p></li></ul></li><li><p>根据 <code>function</code> 所需参数数量传入可迭代对象。当传入多个可迭代对象时，如果可迭代对象的长度不统一，以最短的长度为准。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">result1 = <span class="built_in">list</span>(<span class="built_in">map</span>(func, lst, tup))</span><br><span class="line"><span class="built_in">print</span>(result1)<span class="comment"># [3, 7, 11, 15]</span></span><br><span class="line">result2 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y : x * y, lst, tup))</span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># [2, 12, 30, 56]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-7-4-max-函数">1.7.4 max 函数</h3><ul><li><p><code>max(*args, key=None)</code>：返回一个可迭代对象（列表、元组、字典、集合和字符串等）中最大的元素，或返回两个及以上可迭代对象中最大的一个。</p><ul><li><p><code>max(iterable, *[, default, key=None])</code>：如果 <strong>只提供了一个可迭代对象</strong>，则返回可迭代对象中最大的元素。如果可迭代对象为空，并且没有给定 <code>default</code> 参数，则会抛出 <code>ValueError</code> 异常。</p><ul><li><p><code>*</code> <strong>后面的参数要求以关键字参数的形式传参</strong>。</p></li><li><p>如果有多个最大元素，则返回第一个找到的最大值。</p></li><li><p><strong>字典进行比较的时候</strong>，<strong>比较的是字典的键</strong>，<strong>返回的也是键</strong>。</p></li><li><p>参数 <code>key</code> 为一个函数，用来指定取最大值的方法。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">&quot;dong&quot;</span>, <span class="string">&quot;kexin&quot;</span>, <span class="string">&quot;Harden&quot;</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Curry&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(li, key=<span class="built_in">len</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>max(arg1, arg2, *args[, key=None])</code>：如果提供了 <strong>两个及以上的可迭代对象</strong>，按索引顺序，逐一对比各可迭代对象的当前索引位的 “值”，遇见当前索引位值不相等时便立即停止对比，<strong>返回这个最大值所在的可迭代对象</strong>（也就是说，多可迭代对象参数，返回值依旧是一个可迭代对象）。</p><ul><li><p><strong>注</strong>：进行比较的可迭代对象类型要相同。</p></li><li><p>如果要比较多个字典，需要设置 <code>key</code> 参数，指定比较方式，否则会抛出异常 <code>TypeError: '&gt;' not supported between instances of 'dict' and 'dict'</code>。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="string">&quot;19&quot;</span>&#125;</span><br><span class="line">person2 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;kexin&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="string">&quot;18&quot;</span>&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxByNum</span>(<span class="params"><span class="built_in">dict</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>[<span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(person1, person2, key=maxByNum)) <span class="comment"># 输出 &#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: &#x27;19&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-7-5-min-函数">1.7.5 min 函数</h3><ul><li><code>min(*args, key=None)</code>：返回一个可迭代对象（列表、元组、字典、集合和字符串等）中最小的元素，或返回两个及以上可迭代对象中最小的一个。用法与 <code>max</code> 函数相同。</li></ul><h3 id="1-7-6-range-函数">1.7.6 range 函数</h3><ul><li><p><code>range([start=0,] stop[, step=1])</code>：返回一个 <strong>可迭代对象</strong>（不含 <code>stop</code>），而不是列表类型， 所以直接打印的时候不会打印列表，可是使用 <code>list()</code> 函数转换为列表。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">riter = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(riter)    <span class="comment"># range(0, 10)</span></span><br><span class="line">lst = <span class="built_in">list</span>(riter)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="comment"># 0,10,20,30,40,50,60,70,80,90,</span></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-7-reversed-函数">1.7.7 reversed 函数</h3><ul><li><p>格式：<code>reversed(seq)</code>，用于反转序列 <code>seq</code> 中的元素，<strong>不对原序列的数据进行操作</strong>，返回一个反转后的 <strong>迭代器</strong>。<strong>注</strong>：只要返回迭代器，第一件事 <strong>转成列表</strong>。</p><ul><li><p><code>reversed</code> 函数要求传入的实参必须 <strong>实现</strong> <code>__reversed__()</code> <strong>方法</strong> 或 <strong>支持可迭代协议</strong>（具有从 <code>0</code> 开始的整数类型参数的 <code>__len__()</code> 方法和 <code>__getitem__()</code> 方法）。</p></li><li><p>迭代器一定也是可迭代对象，反之不对。</p></li><li><p>迭代器只能被从头至尾迭代一次。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>]</span><br><span class="line">iterator = <span class="built_in">reversed</span>(lst)</span><br><span class="line"><span class="comment"># 直接打印的是迭代器所在地址</span></span><br><span class="line"><span class="built_in">print</span>(iterator)  <span class="comment"># &lt;list_reverseiterator object at 0x0000026D2CC30250&gt;</span></span><br><span class="line"><span class="comment"># 将迭代器转成列表打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(iterator))  <span class="comment"># [9, 2, 7, 3, 5, 1]</span></span><br><span class="line"><span class="comment"># reversed 不修改原数据</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 5, 3, 7, 2, 9]</span></span><br><span class="line"><span class="comment"># 迭代器只能被从头至尾迭代一次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(iterator))  <span class="comment"># []</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-8-sum-函数">1.7.8 sum 函数</h3><ul><li><p><code>sum(iterable[, start])</code>：对可迭代对象进行求和操作。<strong>注</strong>：可迭代对象使用 <code>sum()</code> 函数时，做求和操作的元素必须都是数字，不能是字符或字符串，否则将抛出异常：<code>TypeError: unsupported operand type(s) for +:</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(lst)) <span class="comment"># 45</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-9-sorted-函数">1.7.9 sorted 函数</h3><ul><li><p>格式：<code>sorted(iterable, [key], reverse=False)</code>，对可迭代对象进行排序操作（不对原数据操作），以 <strong>列表</strong> 形式返回。要求可迭代对象中所有元素的数据类型 <strong>可比较大小</strong>。</p><ul><li><p><code>iterable</code>：可迭代对象（字符串，列表，元组，字典，集合等）。</p></li><li><p><code>key</code>：指定一个函数，在排序之前，先将列表中的 <strong>每个元素</strong> 作为实参传递给这个函数之后，<strong>再按函数结果对原数据进行排序</strong>。</p></li><li><p><code>reverse</code>：默认为 <code>False</code>，代表升序，指定为 <code>True</code> 时表示降序。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;X&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">sorted_tup = <span class="built_in">sorted</span>(tup)  <span class="comment"># 使用 ASCII 码排序</span></span><br><span class="line">sorted_s = <span class="built_in">sorted</span>(s)  <span class="comment"># 对字符串中的字符进行排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_tup)  <span class="comment"># [&#x27;G&#x27;, &#x27;X&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;h&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(sorted_s)  <span class="comment"># [&#x27; &#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;w&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(sorted_tup))  <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(sorted_s))  <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-10-zip-函数">1.7.10 zip 函数</h3><ul><li><p>格式：<code>zip(*iterables)</code>，<strong>在多个可迭代对象上进行并行迭代</strong>，<strong>返回一个迭代器</strong>，<strong>迭代器中的每个元素均为元组</strong>。</p><ul><li><p>当 <code>zip</code> 函数不带参数时，它将返回一个空迭代器。</p></li><li><p>当 <code>zip</code> 函数只有一个可迭代对象参数时，它将返回一个单元组的迭代器。</p></li><li><p><code>zip</code> 函数从每一个可迭代对象中返回一个元素组成迭代器中的一个元组，如果可迭代对象的长度不统一，那么以最短的那个为准。</p></li></ul></li><li><p><code>zip</code> 函数的操作被称为 <strong>拉链操作</strong>。</p></li><li><p>迭代器对象一定是 <code>iterable</code>。</p></li><li><p>迭代器对象如果耗尽，则不能继续迭代取值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">zh = [<span class="string">&quot;壹&quot;</span>, <span class="string">&quot;贰&quot;</span>, <span class="string">&quot;叁&quot;</span>, <span class="string">&quot;肆&quot;</span>, <span class="string">&quot;伍&quot;</span>, <span class="string">&quot;陆&quot;</span>]</span><br><span class="line">eng = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="comment"># [(&#x27;壹&#x27;,), (&#x27;贰&#x27;,), (&#x27;叁&#x27;,), (&#x27;肆&#x27;,), (&#x27;伍&#x27;,), (&#x27;陆&#x27;,)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(zh)))</span><br><span class="line"><span class="comment"># &lt;zip object at 0x0000024F1D52FEC0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">zip</span>(num, zh, eng))</span><br><span class="line"><span class="comment"># [(1, &#x27;壹&#x27;, &#x27;one&#x27;), (2, &#x27;贰&#x27;, &#x27;two&#x27;), (3, &#x27;叁&#x27;, &#x27;three&#x27;), (4, &#x27;肆&#x27;, &#x27;four&#x27;), (5, &#x27;伍&#x27;, &#x27;five&#x27;), (6, &#x27;陆&#x27;, &#x27;six&#x27;)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(num, zh, eng)))</span><br></pre></td></tr></table></figure></li></ul><h1>二、list 列表</h1><h2 id="2-1-概述">2.1 概述</h2><ul><li><p>类型 <code>&lt;class 'list'&gt;</code>。</p></li><li><p><code>Python</code> 中没有数组，但是加入了更加强大的列表。</p></li><li><p>列表是一种 <strong>可变数据类型</strong>。</p></li><li><p>列表在内存中的 <strong>存储空间</strong> 是 <strong>连续</strong> 的，所以列表支持索引和切片，但列表中的元素 <strong>引用</strong> 的 <strong>地址</strong> 却在绝大多数情况下是 <strong>不连续</strong> 的（列表存储不同的数据类型）。</p><ul><li><strong>列表相当于将数据的内存地址按照一定顺序排列好</strong>。</li></ul></li><li><p>列表是可变的，所以我们可以通过 <strong>索引</strong> 和 <strong>切片</strong> 的方式来对列表的元素进行修改。</p></li><li><p>从 <strong>表现形式</strong> 上看，列表会将所有元素都放在一对中括号 <code>[]</code> 里面，相邻元素之间用逗号 <code>,</code> 分隔：<code>[element1, element2, ... , elementn]</code>，其中 <code>element1 ~ elementn</code> 表示列表中的元素，个数没有限制，数据类型只要是 <code>Python</code> 支持的就可以。</p></li><li><p>从 <strong>存储内容</strong> 上看，列表可以存储数字、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同。</p><ul><li>在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。</li></ul></li></ul><h2 id="2-2-创建列表">2.2 创建列表</h2><ul><li><p>创建列表的方法可分为 <strong>两种</strong>：</p><ul><li><p>使用 <code>[]</code> <strong>直接创建</strong> 列表：<code>listname = [element1, element2,  ... , elementn]</code>，其中 <code>listname</code> 表示变量名，<code>element1 ~ elementn</code> 表示列表元素。可以创建空列表，例：<code>emptylist = []</code>。</p></li><li><p>使用 <strong>内置函数</strong> <code>list([iterable])</code> 将 <strong>可迭代对象</strong> 转换为 <code>list</code> 类型，可以转换的对象有字符串，列表，元组，<code>range</code> 函数的返回值，字典 <code>keys</code>，<code>values</code> 方法的返回值。如果没有传入参数，则创建空列表，例：<code>emptylist = list()</code>。</p></li></ul></li><li><p><strong>列表变量指向引用地址</strong>，<strong>该引用地址中保存有列表中每个元素所在的内存地址</strong>。</p></li><li><p><strong>注</strong>：<strong>列表中存储的数据都是数据对应的内存地址</strong>，<strong>没有真实数据</strong>。</p></li></ul><h2 id="2-3-访问列表元素">2.3 访问列表元素</h2><ul><li><p>列表是 <code>Python</code> 序列中的一种，我们可以使用 <strong>索引</strong>（<code>index</code>）<strong>访问</strong> 列表中的某个元素（得到的是一个元素的值），也可以使用 <strong>切片访问</strong> 列表中的一组元素（得到的是一个新的子列表）。</p><ul><li><p>使用 <strong>索引</strong> 访问列表元素的格式为：<code>listname[i]</code>，其中 <code>listname</code> 表示列表名字，<code>i</code> 表示索引值。列表的索引可以是正数，也可以是负数。</p></li><li><p>使用 <strong>切片</strong> 访问列表元素的格式为：<code>listname[start : end : step]</code>，其中 <code>listname</code> 表示列表名字，<code>start</code> 表示起始索引（包含该位置），<code>end</code> 表示结束索引（不包含该位置），<code>step</code> 表示步长。</p></li></ul></li></ul><h2 id="2-4-删除列表-del-关键字">2.4 删除列表（del 关键字）</h2><ul><li><p>对于已经创建的列表，如果不再使用，可以使用 <code>del</code> <strong>关键字</strong> 将其删除。</p></li><li><p>格式：<code>del listname</code>，其中 <code>listname</code> 表示要删除列表的名称。</p></li><li><p><code>del</code> 语句在删除变量时，不是直接删除数据，而是 <strong>解除</strong> 变量对数据的 <strong>引用</strong>，当数据 <strong>引用计数</strong> 为 <code>0</code> 时，数据就变成了一个可回收的对象，然后内存会被不定期回收。</p></li><li><p><strong>注</strong>：<code>Python</code> <strong>中的所有删除操作都是解除引用关系</strong>，<strong>而不是直接将数据删除</strong>。</p></li></ul><h2 id="2-5-列表方法">2.5 列表方法</h2><ul><li><p><code>Python</code> 列表的数据类型为 <code>list</code>，我们可使用 <code>dir(list)</code> 来查看该类型包含哪些方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">list</span>))</span><br><span class="line"><span class="comment"># [&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__delitem__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__gt__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__hash__&#x27;, &#x27;__iadd__&#x27;, &#x27;__imul__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__reversed__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__setitem__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__subclasshook__&#x27;, &#x27;append&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;count&#x27;, &#x27;extend&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;index&#x27;, &#x27;insert&#x27;, &#x27;pop&#x27;, &#x27;remove&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li>不以双下划线 <code>__</code> 开头结尾的方法都是列表的对象方法，即 <code>append</code>, <code>clear</code>, <code>copy</code>, <code>count</code>, <code>extend</code>, <code>index</code>, <code>insert</code>, <code>pop</code>, <code>remove</code>, <code>reverse</code>, <code>sort</code>。</li></ul></li><li><p><strong>修改列表的方法都是对原列表进行修改</strong>，即 <code>in-place</code> 操作（原地操作），无返回值，或者说返回值为 <code>None</code>。</p></li></ul><h3 id="2-5-1-列表增加元素">2.5.1 列表增加元素</h3><h4 id="1-append-方法">（1）append() 方法</h4><ul><li><p>格式：<code>listname.append(obj)</code>，用于在 <strong>列表末尾</strong> <strong>追加</strong> 元素。</p><ul><li><p><code>listname</code>：要追加元素的列表。</p></li><li><p><code>obj</code>：要添加到列表末尾的 <strong>任意数据</strong>，可以是数字、单个元素、列表、元组、字符串等任意对象。</p></li></ul></li><li><p><code>listname.append(obj)</code> 作用等价于 <code>listname[len(listname):] = [obj]</code>。</p></li><li><p>使用 <code>append</code> 方法将列表、元组等 <strong>可迭代数据</strong> 添加到列表末尾时，此方法会将它们作为一个 <strong>整体</strong> 添加到列表中，从而形成包含元素为列表或元组的新列表。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">tup = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">lst.append(tup)</span><br><span class="line">lst.append(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, (5, 6, 7), &#x27;dong&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-extend-方法-批量-append">（2）extend() 方法（批量 append）</h4><ul><li><p>格式：<code>listname.extend(iterable)</code>，用于在 <strong>列表末尾</strong> <strong>追加</strong> 元素。</p><ul><li><p><code>listname</code> 表示要追加可迭代对象的列表。</p></li><li><p><code>iterable</code> 表示要添加到列表末尾的 <strong>可迭代数据</strong>，它可以是列表、元组、字符串等。</p></li></ul></li><li><p><code>listname.extend(obj)</code> 作用等价于 <code>listname[len(listname):] = iterable</code>。</p></li><li><p><code>extend(iterable)</code> 和 <code>append(obj)</code> 的不同之处：</p><ul><li><p><code>extend</code> 的参数要求是可迭代对象，<code>append</code> 的参数可以是任意数据。</p></li><li><p><code>extend</code> 不会将列表、元祖、字符串等可迭代对象视为一个整体，而是将可迭代对象中包含的元素 <strong>逐个添加</strong> 到列表中。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">tup = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">lst.extend(tup)</span><br><span class="line">lst.extend(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 5, 6, 7, &#x27;d&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-insert-方法">（3）insert() 方法</h4><ul><li><p><code>append</code> 和 <code>extend</code> 方法只能在 <strong>列表末尾</strong> 插入元素，如果希望在 <strong>列表中间</strong> 某个位置插入元素，那么可以使用 <code>insert</code> 方法。</p></li><li><p>格式：<code>listname.insert(index , obj)</code>，用于在列表指定索引处插入 <strong>一个元素</strong>。</p><ul><li><p><code>index</code> 表示要插入位置的索引。</p></li><li><p><code>obj</code> 表示要添加到列表的任意数据。</p></li></ul></li><li><p>使用 <code>insert</code> 方法将列表、元祖等 <strong>可迭代数据</strong> 插入列表时，<code>insert</code> 方法也会将它们作为一个 <strong>整体</strong> 插入到列表中，这一点和 <code>append</code> 方法是一样的。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">tup = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">lst.insert(<span class="number">1</span>, tup)</span><br><span class="line">lst.insert(<span class="number">0</span>, <span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;dong&#x27;, 1, (5, 6, 7), 2, 3]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-2-列表删除元素">2.5.2 列表删除元素</h3><h4 id="1-pop-方法">（1）pop() 方法</h4><ul><li><p>格式：<code>listname.pop(index=-1)</code>，用于删除列表中 <strong>指定索引</strong>（默认 <code>index=-1</code>，表示末尾）处的元素，其中 <code>listname</code> 表示列表名称，<code>index</code> 表示索引值。返回被删除元素的值。</p><ul><li><p>如果不写 <code>index</code> 参数，<code>pop</code> 方法 <strong>默认</strong> 删除列表中的 <strong>最后一个</strong> 元素，类似于数据结构中的 “出栈” 操作。</p></li><li><p>该方法是既 <strong>修改原数据</strong> 又具有 <strong>返回值</strong> 的列表方法。返回被删除元素的值。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">True</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst.pop(<span class="number">3</span>))  <span class="comment"># False</span></span><br><span class="line">var = lst.pop()</span><br><span class="line"><span class="built_in">print</span>(var)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(var))  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-remove-方法">（2）remove() 方法</h4><ul><li><p>格式：<code>listname.remove(obj)</code> 用于移除列表中 <strong>第一个</strong> 与指定值相 <strong>匹配</strong> 的元素，其中 <code>obj</code> 表示要移除的元素，无返回值。</p><ul><li><strong>注</strong>：要移除的元素不存在会报错 <code>ValueError: list.remove(x): x not in list</code> 。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">True</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">lst.remove(<span class="literal">True</span>)  <span class="comment"># 这里 1 被删除</span></span><br><span class="line">lst.remove(<span class="literal">False</span>)  <span class="comment"># 这里 False 被删除</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, 7, &#x27;0&#x27;, 6, 3, 7, True, 2, 9, 8, &#x27;1&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-clear-方法">（3）clear() 方法</h4><ul><li><p>格式：<code>listname.clear()</code>，用于删除列表中的所有元素，即清空列表，等价于 <code>del a[:]</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">True</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">lst.clear()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># []</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-del-关键字">（4）del 关键字</h4><ul><li><p><code>del</code> 是 <code>Python</code> 中用来执行删除操作的关键字，它不仅可以删除整个列表，还可以删除列表中的元素。</p><ul><li><p>使用 <code>del</code> 删除列表中的 <strong>单个元素</strong>，格式：<code>del listname[index]</code>，其中 <code>listname</code> 表示列表名称，<code>index</code> 表示元素的索引值。</p></li><li><p>使用 <code>del</code> 删除列表中的 <strong>切片</strong>，格式：<code>del listname[start : end ： step]</code>，其中 <code>start</code> 表示起始索引，<code>end</code> 表示结束索引，<code>step</code> 表示步长。<code>del</code> 会删除从索引 <code>start</code> 到 <code>end</code> 之间，步长为 <code>step</code> 的元素，不包括 <code>end</code> 索引的元素。</p></li></ul></li><li><p><code>del</code> <strong>只是解除引用关系</strong>，<strong>而不是直接将数据删除</strong>。</p></li><li><p>由于列表的 <strong>内存自动管理</strong> 机制，当使用 <code>del</code> 关键字同时删除两个列表元素，其中第二个被删元素为末尾元素时会抛出异常：<code>IndexError: list assignment index out of range</code>，这是因为第一个元素被删后，列表会自动缩短长度，这时第二个元素索引的位置已经不存在元素。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">3</span>], lst[<span class="number">5</span>] <span class="comment"># IndexError: list assignment index out of range</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-3-列表修改元素">2.5.3 列表修改元素</h3><h4 id="1-修改单个元素">（1）修改单个元素</h4><ul><li><p>使用索引得到列表元素，直接通过 <code>=</code> 重新赋值来改变元素的值，即 <code>listname[i]=obj</code>。这个操作也被称作 <code>in-place</code> 操作，即原地操作，表示不进行复制的操作，不返回新的对象，而是直接对原对象进行修改。</p></li><li><p>将列表中的某个元素赋值为 <strong>空列表</strong> 时，不表示删除该元素，而是将该元素替换成了 <strong>空列表</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">lst[<span class="number">1</span>] = []</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, [], 7, 8, 9]</span></span><br></pre></td></tr></table></figure></li><li><p>列表变量所指向的内存地址在列表修改后并不会发生改变。</p></li></ul><h4 id="2-修改一组元素">（2）修改一组元素</h4><ul><li><p><code>Python</code> 支持通过 <strong>切片</strong> 语法 <code>listname[start : end : step] = iterable</code> 为列表修改元素，即使用切片重新赋值来改变一组元素的值。</p><ul><li><p><code>iterable</code> 表示可迭代对象。</p></li><li><p>注：如果为切片赋值字符串，字符串将被当作字符数组插入列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">lst[<span class="number">1</span>:<span class="number">3</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lst) <span class="comment"># [5, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, 8, 9]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果 <code>start</code> 与 <code>end</code> 相等， 表示在 <code>start</code> 索引之后插入元素，在列表末尾追加元素即为 <code>listname[len(listname):]</code>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">lst[<span class="number">2</span>:<span class="number">2</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">lst[<span class="built_in">len</span>(lst):] = <span class="string">&quot;world&quot;</span>,</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, 6, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, 7, 8, 9, &#x27;world&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>如果不指定步长，即 <code>step = 1</code>，<code>Python</code> 就不要求 <code>iterable</code> 的 <strong>元素个数</strong> 与切片获取到的 <strong>元素个数</strong> 相同。</p><ul><li>列表的 <strong>内存自动管理</strong> 机制可以控制列表长度的伸缩。</li></ul></li><li><p>如果指定步长，<code>Python</code> 要求 <code>iterable</code> 的 <strong>元素个数</strong> 与切片获取到的 <strong>元素个数</strong> 必须相同。</p><ul><li>注：<code>step = -1</code> 时，<code>Python</code> 同样要求 <code>iterable</code> 的 <strong>元素个数</strong> 与切片获取到的 <strong>元素个数</strong> 必须相同，且 <code>iterable</code> 的元素被 <strong>反向赋值</strong> 给列表切片对应位置。</li></ul></li><li><p>如果为切片赋值空列表 <code>[]</code>，就相当于删除一组元素。</p></li><li><p>如果对空切片 <code>[n:n]</code> 赋值，就相当于插入一组新的元素。</p></li><li><p>列表变量所指向的内存地址在列表修改后并不会发生改变。</p></li></ul><h4 id="3-封包">（3）封包</h4><ul><li><p><strong>当多个对象同时赋值给同一个变量时</strong>，<strong>会被打包成一个元组</strong>，<strong>这样的特性就被称为封包</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment"># 封包</span></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst[<span class="number">1</span>:<span class="number">1</span>] = <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>  <span class="comment"># 封包</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 5, 6, 7, 2, 3]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-4-列表查找元素">2.5.4 列表查找元素</h3><h4 id="1-count-方法">（1）count() 方法</h4><ul><li><p>格式：<code>listname.count(obj)</code>，用于统计某个元素在列表中出现的次数并 <strong>返回</strong>。其中 <code>listname</code> 代表列表名，<code>obj</code> 表示要统计的元素。</p><ul><li>比较机制为 <code>==</code>，表示元素值比较，即 <code>listname[x] == obj</code>，所以 <code>1 == True</code>，<code>0 == False</code>。</li></ul></li><li><p>如果 <code>count()</code> 返回 <code>0</code>，就表示列表中不存在该元素，所以 <code>count()</code> 也可以用来判断列表中的某个元素是否存在。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="literal">True</span>, <span class="string">&quot;0&quot;</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst.count(<span class="number">0</span>))  <span class="comment"># 输出 1，因为 False == 0</span></span><br><span class="line"><span class="built_in">print</span>(lst.count(<span class="number">1</span>))  <span class="comment"># 输出 2，因为 True == 1，1 == 1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-index-方法">（2）index() 方法</h4><ul><li><p>格式：<code>listname.index(obj[, start[, end]])</code> 用于查找某个元素 <strong>从左至右</strong> 在列表的指定范围（<code>[start:end]</code>）中 <strong>第一次出现</strong> 的位置（索引）并 <strong>返回</strong>。</p><ul><li><p><strong>注</strong>：返回的索引是相对于 <strong>整个 listname 列表</strong> 计算的，而不是 <code>[start:end]</code> 的子列表。</p></li><li><p><code>start</code> 表示搜寻范围的起始索引（包含），默认为 <code>0</code>。</p></li><li><p><code>end</code> 表示搜寻范围的结束索引（不包含），默认为 <code>len(list)</code>。</p></li></ul></li><li><p>如果要查找的元素不存在，<code>index</code> 方法会抛出异常 <code>ValueError: x is not in list</code>，建议查找前使用 <code>count</code> 方法进行判断。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">True</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="number">7</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="number">0</span>))  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="number">6</span>))  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="number">4</span>))  <span class="comment"># ValueError: 4 is not in list</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-5-列表排序-sort">2.5.5 列表排序 sort</h3><ul><li><p>格式：<code>listname.sort([key], reverse=False)</code>，用于对列表 <code>listname</code> 进行排序操作（默认升序），是一个原地操作，要求列表中所有元素的数据类型 <strong>可比较大小</strong>。</p><ul><li><p><code>key</code>：指定一个 <code>callable</code> 函数，即可调用函数。在排序之前，先将列表中的 <strong>每个元素</strong> 作为实参传递给这个函数之后，再按 <strong>函数结果</strong> 对原数据进行排序。</p></li><li><p><code>reverse</code>：默认为 <code>False</code>，代表 <strong>升序</strong>，指定为 <code>True</code> 则降序。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [-<span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, -<span class="number">11</span>]</span><br><span class="line">lst.sort()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [-11, -5, -3, 1, 3, 5, 7]</span></span><br><span class="line">lst.sort(key=<span class="built_in">abs</span>)  <span class="comment"># 按照绝对值大小排序</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, -3, 3, -5, 5, 7, -11]</span></span><br><span class="line">lst.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [7, 5, 3, 1, -3, -5, -11]</span></span><br></pre></td></tr></table></figure></li><li><p><code>sort</code> 方法和 <code>sorted</code> 函数的区别：</p><ul><li><p><code>sort</code> 方法是只针对列表的排序，对原数据进行操作，无返回值，是列表的对象方法。</p></li><li><p><code>sorted</code> 函数可以对所有可迭代的对象进行排序，不对原数据操作，有返回值，是内置函数。</p></li></ul></li><li><p>当列表中的元素是可迭代对象时，依然可以比较元素大小，比较规则：首先比较每个元素的第一个子元素大小，如果大小相同则比较第二个子元素，依此类推。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lst = [([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]), ([-<span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>], [<span class="number">27</span>, <span class="number">55</span>, <span class="number">19</span>]),</span><br><span class="line">       ([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]), ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [-<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]),</span><br><span class="line">       ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>])]</span><br><span class="line">lst.sort()</span><br><span class="line"><span class="comment"># [([-3, 9, 5], [27, 55, 19]), </span></span><br><span class="line"><span class="comment">#  ([1, 2, 2], [-2, 1, 3]), </span></span><br><span class="line"><span class="comment">#  ([1, 2, 3], [-1, -2, -3]), </span></span><br><span class="line"><span class="comment">#  ([1, 2, 3], [5, 6, 7]), </span></span><br><span class="line"><span class="comment">#  ([1, 3, 5], [6, 8, 10])]</span></span><br><span class="line"><span class="built_in">print</span>(lst)</span><br></pre></td></tr></table></figure></li><li><p>可以通过函数指定比较的元素， 当比较的元素大小相同时，保持原有顺序不变（无论升序还是降序）。例：按照每个元组中最后一个列表中的最后一个元素进行比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_last</span>(<span class="params">tup</span>):</span><br><span class="line">    <span class="keyword">return</span> tup[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">lst = [([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]), ([-<span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>], [<span class="number">27</span>, <span class="number">55</span>, <span class="number">19</span>]),</span><br><span class="line">      ([<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]), ([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [-<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]),</span><br><span class="line">      ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>]), ([<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>])]</span><br><span class="line">lst.sort(key=get_last)</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-6-反转列表-reverse">2.5.6 反转列表 reverse</h3><ul><li><p>格式：<code>listname.reverse()</code>，用于将列表中的元素进行反转操作。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>]</span><br><span class="line">lst.reverse()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [9, 2, 7, 3, 5, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><code>reverse</code> 方法和 <code>reversed</code> 函数区别：</p><ul><li><p><code>reverse</code> 方法是只针对列表的，对原数据进行操作，无返回值，是列表的对象方法。</p></li><li><p><code>reversed</code> 函数是针对序列的，不对原数据操作，返回一个反向迭代器，是内置函数。</p></li></ul></li></ul><h3 id="2-5-7-复制列表-copy">2.5.7 复制列表 copy</h3><ul><li><p>格式：<code>listname.copy()</code>，用于返回列表的一个 <strong>浅拷贝</strong>，等价于 <code>listname[:]</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">True</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">slice_lst = lst[:]</span><br><span class="line">copy_lst = lst.copy()</span><br><span class="line"><span class="built_in">print</span>(slice_lst)  <span class="comment"># [1, 5, 7, False, &#x27;0&#x27;, 6, 3, 7, True, 2, 9, 8, &#x27;1&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(copy_lst)  <span class="comment"># [1, 5, 7, False, &#x27;0&#x27;, 6, 3, 7, True, 2, 9, 8, &#x27;1&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst == slice_lst)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(lst == copy_lst)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h1>三、tuple 元组</h1><h2 id="3-1-概述">3.1 概述</h2><ul><li><p>类型 <code>&lt;class 'tuple'&gt;</code>。</p></li><li><p>元组（<code>tuple</code>）是 <code>Python</code> 中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排序的元素组成。</p></li><li><p>元组和列表（<code>list</code>）的 <strong>区别</strong>：列表的元素是可以更改的，包括修改、删除和插入元素，所以 <strong>列表是可变序列</strong>。然而，元组一旦被创建，它的元素就不可更改了，所以 <strong>元组是不可变序列</strong>。</p><ul><li><p>注：元组不可变只是元组中的 <strong>引用地址不可变</strong>，但是如果引用地址所指向的元素本身数据类型是可变的，那这个元素依然是可变的。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">2</span>]</span><br><span class="line">tup = (<span class="number">123</span>, <span class="number">567</span>, <span class="number">257</span>, lst, <span class="number">912</span>)</span><br><span class="line"><span class="built_in">print</span>(tup)  <span class="comment"># (123, 567, 257, [1, 5, 7, False, &#x27;0&#x27;, 2], 912)</span></span><br><span class="line">tup[<span class="number">3</span>][<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(tup)  <span class="comment"># (123, 567, 257, [1, True, 7, False, &#x27;0&#x27;, 2], 912)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>从 <strong>表现形式</strong> 上看，元组的所有元素都放在一对小括号 <code>( )</code> 中，相邻元素之间用逗号 <code>,</code> 分隔，格式：<code>(element1, element2, ... , elementn)</code>，其中 <code>element1 ~ elementn</code> 表示列表中的元素，个数没有限制，数据类型只要是 <code>Python</code> 支持的就可以。</p></li><li><p>从 <strong>存储内容</strong> 上看，元组可以存储数字、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同。</p></li></ul><h2 id="3-2-创建元组">3.2 创建元组</h2><h3 id="3-2-1-使用-创建元组">3.2.1 使用 ( ) 创建元组</h3><ul><li><p>通过 <code>()</code> 创建元组后，一般使用 <code>=</code> 将它赋值给某个变量，格式：<code>tuplename = (element1, element2, ..., elementn)</code>，其中 <code>tuplename</code> 表示元组名，<code>element1 ~ elementn</code> 表示元组的元素。</p></li><li><p>在 <code>Python</code> 中，元组通常都是使用一对小括号将所有元素包围起来的，但 <strong>小括号不是必须的</strong>，只要将各元素用逗号隔开，<code>Python</code> 就会将其视为元组，这种操作被称为 <strong>封包</strong>。</p></li><li><p>当创建的元组中 <strong>只有一个元素</strong> 时，该元素后面必须要加一个 <strong>逗号</strong> <code>,</code>，否则 <code>Python</code> 解释器不会将它视为元组，只会将它视为单个元素，数据类型为元素类型。</p></li></ul><h3 id="3-2-2-使用-tuple-方法创建元组">3.2.2 使用 tuple() 方法创建元组</h3><ul><li><p>格式：<code>tuple([iterable])</code>，内置函数，用于创建一个新的元组或将其它可迭代对象转换为元组类型。</p><ul><li><code>iterable</code> 表示可迭代对象，包括字符串、元组、<code>range</code> 对象等。如果未指定，则返回空元组，即 <code>tuple()</code> 返回 <code>()</code>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(tup)  <span class="comment"># (1, 5, 7, False, &#x27;0&#x27;, 2)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>())  <span class="comment"># ()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-访问元组">3.3 访问元组</h2><ul><li><p>和列表一样，可以使用 <strong>索引</strong>（<code>index</code>）<strong>访问</strong> 元组中的某个元素（得到的是一个元素的值），也可以使用 <strong>切片访问</strong> 元组中的一组元素（得到的是一个 <strong>新</strong> 的子元组）。</p><ul><li><p>使用 <strong>索引访问</strong> 元组元素的格式：<code>tuplename[i]</code>，其中 <code>tuplename</code> 表示元组名字，<code>i</code> 表示索引值。元组的索引可以是正数，也可以是负数。</p></li><li><p>使用 <strong>切片访问</strong> 元组元素的格式：<code>tuplename[start : end : step]</code>，其中 <code>start</code> 表示起始索引（包含该位置），<code>end</code> 表示结束索引（不包含该位置），<code>step</code> 表示步长。</p></li></ul></li></ul><h2 id="3-4-删除元组">3.4 删除元组</h2><ul><li><p>对于已经创建的元组，如果不再使用，可以使用 <code>del</code> 关键字将其删除。格式为：<code>del tuplename</code>，其中 <code>tuplename</code> 表示要删除元组的名称。</p><ul><li><strong>注</strong>：<strong>元组不支持单个元素删除</strong>。</li></ul></li></ul><h2 id="3-5-元组对象方法">3.5 元组对象方法</h2><ul><li><p><code>Python</code> 元组的数据类型为 <code>tuple</code>，我们可使用 <code>dir(tuple)</code> 来查看该类型包含哪些方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">tuple</span>))  </span><br><span class="line"><span class="comment"># [&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__getitem__&#x27;, &#x27;__getnewargs__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__repr__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, </span></span><br><span class="line"><span class="comment"># &#x27;__subclasshook__&#x27;, &#x27;count&#x27;, &#x27;index&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li>不以双下划线 <code>__</code> 开头结尾的方法都是元组的对象方法，只有 <code>count</code> 和 <code>index</code>。</li></ul></li></ul><h3 id="3-5-1-count-方法">3.5.1 count() 方法</h3><ul><li><p>格式：<code>tuplename.count(obj)</code>，用于统计某个元素在元组中出现的次数，其中 <code>tuplename</code> 代表元组名，<code>obj</code> 表示要统计的元素。</p><ul><li>如果 <code>count()</code> 返回 <code>0</code>，就表示元组中不存在该元素，所以 <code>count()</code> 也可以用来判断元组中的某个元素是否存在。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(tup.count(<span class="number">0</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-2-index-方法">3.5.2 index() 方法</h3><ul><li><p>格式：<code>tuplename.index(obj[, start, end])</code>，用于查找某个元素 <strong>从左至右</strong> 在元组的指定范围（<code>[start:end]</code>）中 <strong>第一次出现</strong> 的位置（索引）并 <strong>返回</strong>。注：返回的索引是相对于 <strong>整个 tuplename 元组</strong> 计算的，而不是 <code>[start:end]</code> 的子列表。</p><ul><li><p><code>start</code> 表示搜寻范围的起始索引（包含），默认为 <code>0</code>。</p></li><li><p><code>end</code> 表示搜寻范围的结束索引（不包含），默认为 <code>len(list)</code>。</p></li></ul></li><li><p>如果要查找的元素不存在，<code>index</code> 方法会抛出异常 <code>ValueError: tuple.index(x): x not in tuple</code>，建议查找前使用 <code>count()</code> 方法进行判断。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="literal">False</span>, <span class="string">&quot;0&quot;</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(tup.index(<span class="number">0</span>))  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 基本数据类型</title>
      <link href="/posts/python/python3/02.html"/>
      <url>/posts/python/python3/02.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、Python 基本数据类型</h1><ul><li><p><code>Python</code> 基本数据类型一般分为 <code>6</code> 种：数值（<code>Numbers</code>）、字符串（<code>String</code>）、列表（<code>List</code>）、元组（<code>Tuple</code>）、字典（<code>Dictionary</code>）、集合（<code>Set</code>）。</p></li><li><p><code>Python</code> 的六个标准数据类型中：</p><ul><li><p>不可变数据（<code>3</code> 个）：<code>Number</code>（数字）、<code>String</code>（字符串）、<code>Tuple</code>（元组）。</p></li><li><p>可变数据（<code>3</code> 个）：<code>List</code>（列表）、<code>Dictionary</code>（字典）、<code>Set</code>（集合）。</p></li></ul></li><li><p><code>Python</code> 内置的 <code>type(object)</code> 函数可以用来查询变量 <code>object</code> 所指向的对象类型。该函数具有返回值：<code>object</code> 的数据类型。</p></li></ul><h2 id="1-1-numbers-数值">1.1 Numbers 数值</h2><ul><li><p><code>Numbers</code> 数字类型是 <strong>不允许改变</strong> 的，这就意味着如果改变数字数据类型的值，将 <strong>重新分配内存空间</strong>。</p></li><li><p><code>Python</code> 中数字类型有 <code>3</code> 种：整型数（<code>int</code>）、浮点型数（<code>float</code>）、复数（<code>complex</code>）。其中，整型数又可以分为整型（<code>int</code>）和布尔型（<code>bool</code>）。</p></li></ul><h3 id="1-1-1-int-整型数">1.1.1 int 整型数</h3><h4 id="1-int-整型">（1）int 整型</h4><ul><li><p>类型 <code>&lt;class 'int'&gt;</code>。</p></li><li><p><code>Python</code> 整数不分类型，或者说它只有一种类型的整数。<code>Python</code> 整数的 <strong>取值范围</strong> 是 <strong>无限</strong> 的，不管多大或者多小的数字。</p></li><li><p>当所用数值超过计算机自身的计算能力时，<code>Python</code> 会自动转用高精度计算（大数计算）。</p></li><li><p>在 <code>Python</code> 中，可以使用多种进制来表示整数：</p><ul><li><p>十进制形式：常见的整数形式，由 <code>0 ~ 9</code> 共十个数字排列组合而成。</p></li><li><p>二进制形式：由 <code>0</code> 和 <code>1</code> 两个数字组成，书写时以 <code>0b</code> 或 <code>0B</code> 开头。</p></li><li><p>八进制形式：由 <code>0 ~ 7</code> 共八个数字组成，书写时以 <code>0o</code> 或 <code>0O</code> 开头。</p></li><li><p>十六进制形式：由 <code>0 ~ 9</code> 十个数字和 <code>A ~ F</code>（或 <code>a ~ f</code>）六个字母组成，书写时以 <code>0x</code> 或 <code>0X</code> 开头。</p></li></ul></li><li><p>为了提高数字的的 <strong>可读性</strong>，<code>Python 3.x</code> 允许使用下划线 <code>_</code> 作为数字（包括整数和小数）的 <strong>分隔符</strong>。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。例：<code>num = 1_234.123_456</code>。</p><ul><li><p>不能将下划线 <code>_</code> 换成逗号 <code>,</code>，否则会被识别为元组。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span>,<span class="number">234.123</span>,<span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># (1, 234.123, 456)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-bool-布尔型">（2）bool 布尔型</h4><ul><li><p>类型 <code>&lt;class 'bool'&gt;</code>。</p></li><li><p><code>Python3</code> 提供了 <code>bool</code> 类型来表示真（对）或假（错），其中 <strong>真</strong>（<strong>对</strong>）使用 <code>True</code> 来代表、<strong>假</strong>（<strong>错</strong>）使用 <code>False</code> 来代表。</p></li><li><p><code>True</code> 和 <code>False</code> 是 <code>Python</code> 中的 <strong>关键字</strong>，要注意字母的大小写。</p></li><li><p>在 <code>Python3</code> 中，<code>bool</code> 是 <code>int</code> 的 <strong>子类</strong>，<code>bool.__base__</code> 返回的 <strong>基类</strong> 是 <code>&lt;class 'int'&gt;</code>，<code>True</code> <strong>和</strong> <code>False</code> <strong>可以与数字直接相加</strong>，类似于数值 <code>1</code> 和 <code>0</code>。在实际使用中，<code>True == 1</code>、<code>False == 0</code> 会返回 <code>True</code>。</p></li><li><p><strong>注</strong>：<code>+True</code> 返回 <code>1</code>，<code>+False</code> 返回 <code>0</code>。</p></li></ul><h3 id="1-1-2-float-浮点型数">1.1.2 float 浮点型数</h3><ul><li><p>类型 <code>&lt;class 'float'&gt;</code>。</p></li><li><p><code>Python</code> <strong>只有一种小数类型</strong>，就是 <code>float</code>。书写时必须包含一个 <strong>小数点</strong>，否则会被当作整数处理。</p></li><li><p><code>Python</code> 浮点数允许仅保留小数点模式，例：<code>3.</code>。</p></li><li><p><code>Python</code> 中的小数有两种书写形式：</p><ul><li><p>十进制形式：常见的浮点数形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3.1415926</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 3.1415926</span></span><br></pre></td></tr></table></figure></li><li><p>指数形式：写法为 <code>aEn</code> 或 <code>aen</code>，整个表达式等价于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a×10^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>。例：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.1</mn><mi>E</mi><mn>5</mn><mo>=</mo><mn>2.1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2.1E5 = 2.1×10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">2.1E5</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 210000.0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-1-3-complex-复数">1.1.3 complex 复数</h3><ul><li><p>类型 <code>&lt;class 'complex'&gt;</code>。</p></li><li><p>复数由 <strong>实部</strong>（<code>real</code>）和 <strong>虚部</strong>（<code>imag</code>）构成。在 <code>Python</code> 中，复数的虚部以 <code>j</code> 或 <code>J</code> 作为后缀，具体格式为：<code>a + bj</code>，其中 <code>a</code> 表示实部，<code>b</code> 表示虚部。例：<code>12 + 0.2j</code>。</p><ul><li><strong>注</strong>：当表示复数时，<code>j</code> 或 <code>J</code> 前面的系数不能省略。</li></ul></li><li><p>复数（<code>complex</code>）是 <code>Python</code> 的内置类型，直接书写即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">12</span> + <span class="number">0.2j</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># (12+0.2j)</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>complex()</code> 内置函数可以表示复数，例：<code>complex(12, 0.2)</code> 表示复数 <code>(1 + 2j)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(<span class="number">12</span>, <span class="number">0.2</span>)) <span class="comment"># (12+0.2j)</span></span><br></pre></td></tr></table></figure></li><li><p>具有实部和虚部的复数在输出时自动在数据两侧添加括号，仅有虚部的复数则不会添加。</p></li><li><p>复数（<code>complex</code>）具有属性 <code>real</code> 和 <code>imag</code>，可以用来获取复数的实部和虚部。例：<code>num.real</code> 获得 <code>12</code>，<code>num.imag</code> 获得 <code>0.2</code>。</p></li></ul><h3 id="1-1-4-数字类型转换">1.1.4 数字类型转换</h3><ul><li><p><code>int([x], base=10)</code>：内置函数，将 <code>base</code> 进制的 <code>x</code> 转换为一个 <strong>十进制整数</strong> 并 <strong>返回</strong>。如果没有指定 <code>x</code>，则返回 <code>0</code>，即 <code>int()</code> 返回 <code>0</code>。</p><ul><li><p><code>x</code>：可选参数，数字（不能为复数）或字符串。</p></li><li><p><code>base</code>：进制数，指定 <code>x</code> 的进制，默认十进制（要用其他进制时，<code>x</code> 必须为字符串）。</p><ul><li><p>若 <code>x</code> 为纯数字，则 <code>base</code> 参数不能设置为 <code>10</code> 以外的值，否则报错；其作用为对参数 <code>x</code> 取整（<strong>向</strong> <code>0</code> <strong>取整</strong>）。</p><ul><li><p>注：可以使用 <code>math</code> 模块的 <code>ceil()</code> 方法实现 <strong>向上取整</strong>，使用 <code>floor()</code> 方法实现 <strong>向下取整</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">3.1415926</span>)) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(-<span class="number">3.1415926</span>)) <span class="comment"># -3</span></span><br><span class="line"><span class="built_in">print</span>(math.ceil(<span class="number">3.1415926</span>)) <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(math.ceil(-<span class="number">3.1415926</span>)) <span class="comment"># -3</span></span><br><span class="line"><span class="built_in">print</span>(math.floor(<span class="number">3.1415926</span>)) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(math.floor(-<span class="number">3.1415926</span>)) <span class="comment"># -4</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>若 <code>x</code> 为字符串，则必须为 <strong>整数的书写形式</strong>，否则报错，且 <code>base</code> 可略可有。若 <code>x</code> 不是 <code>base</code> 进制格式，则报错。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;3.1415926&quot;</span>)) <span class="comment"># ValueError: invalid literal for int() with base 10: &#x27;3.1415926&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;ab123&quot;</span>)) <span class="comment"># ValueError: invalid literal for int() with base 10: &#x27;ab123&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>float([x])</code>：内置函数，将 <code>x</code> 转换为一个 <strong>浮点数</strong> 并 <strong>返回</strong>。如果没有指定 <code>x</code>，则返回 <code>0.0</code>，即 <code>float()</code> 返回 <code>0.0</code>。</p><ul><li><code>x</code>：可选参数，数字（不能为复数）或数字型字符串（两端可包含空格）。</li></ul></li><li><p><code>bool([x])</code>：内置函数，将 <code>x</code> 转换为 <strong>布尔类型</strong> 并<strong>返回</strong>。如果没有指定 <code>x</code>，则返回 <code>False</code>，即 <code>bool()</code> 返回 <code>False</code>。</p><ul><li>不管 <code>x</code> 是什么类型，只要不为 <strong>空</strong>（空字符串、空列表、空元组、空字典、空集合等）、<code>None</code>、<code>0</code>、<code>0.0</code>、<code>0j</code> 或 <code>Fasle</code>，<code>bool(x)</code> 都会返回 <code>True</code>。</li></ul></li><li><p><code>complex([real[,imag]])</code>：内置函数，创建一个 <code>real + imag * j</code> 形式的复数，或将一个数字或字符串转为复数。如果没有指定 <code>real</code> 和 <code>imag</code>，则返回 <code>0j</code>，即 <code>complex()</code> 返回 <code>0j</code>。</p><ul><li><p><code>real</code>：可选参数，表示实数部分，可以为数字或字符串。</p><ul><li>注 <code>1</code>：字符串需要满足复数格式，即 <code>&quot;real+imag*j&quot;</code>，且加号 <code>+</code> 两侧不能加空格。</li><li>注 <code>2</code>：只能传入一个字符串。</li></ul></li><li><p><code>imag</code>：可选参数，表示虚数部分，默认为 <code>0j</code>。</p></li></ul></li><li><p><code>chr(x)</code>：内置函数，将一个整数转换为它对应的字符，它是 <code>ord()</code> 的逆函数。</p></li><li><p><code>ord(x)</code>：内置函数，将一个字符转换为它对应的 <code>ASCII</code> 数值或 <code>Unicode</code> 数值，它是 <code>chr()</code> 的逆函数。</p></li></ul><h2 id="1-2-string-字符串">1.2 String 字符串</h2><h3 id="1-2-1-普通字符串">1.2.1 普通字符串</h3><ul><li><p>类型 <code>&lt;class 'str'&gt;</code>。</p></li><li><p>字符串 <code>String</code> 是 <strong>不可变</strong> 的数据类型，它是 <strong>序列</strong>。</p></li><li><p><code>python</code> 中不存在字符类型，所有的字符都是字符串类型。</p></li><li><p><strong>若干个字符的集合</strong> 就是一个字符串（<code>String</code>），<code>Python</code> 中的字符串使用双引号 <code>&quot;&quot;</code> 或单引号 <code>''</code> 创建，双引号和单引号没有区别。</p></li><li><p>当字符串内容中出现 <strong>引号</strong> 时，需要对其进行特殊处理，有 <strong>两种处理方法</strong>：</p><ul><li><p>在引号前面添加反斜杠 <code>\</code> 对引号进行 <strong>转义</strong>，将引号作为普通文本。</p></li><li><p>使用 <strong>不同的引号</strong> 创建字符串，即字符串内容中出现了单引号，可以使用双引号创建字符串，反之亦然。</p></li></ul></li><li><p>直接输出字符串时不显示引号，只有当字符串作为 <strong>列表元素</strong> 时，打印列表会 <strong>保留引号</strong>，并默认显示 <strong>单引号</strong>。</p></li><li><p>要想 <strong>换行书写</strong> 一个比较长的字符串，可以在行尾添加反斜杠 <code>\</code> 对字符串内容实现换行， <code>\</code> 被称为 <strong>续行符</strong>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;You and I remains the same in different time, at different places,\</span></span><br><span class="line"><span class="string">among different people; time is changing, \</span></span><br><span class="line"><span class="string">space is changing and everything is changing except my miss to you!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>) <span class="comment"># You and I remains the same in different time, at different places,among different people; time is changing, pace is changing and everything is changing except my miss to you!</span></span><br></pre></td></tr></table></figure><ul><li>列表，元组，字典和集合，无需使用续行符，它们的元素会自动拼接为一行（隐式行拼接）。</li></ul></li></ul></li><li><p><code>Python</code> 也支持表达式的换行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1024</span> + <span class="number">2048</span> - <span class="number">520</span> + \</span><br><span class="line">      <span class="number">5</span> / <span class="number">12</span> + <span class="number">2222</span> * <span class="number">3</span> + \</span><br><span class="line">      <span class="number">4</span> * <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 9242.416666666666</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-2-长字符串">1.2.2 长字符串</h3><ul><li><p><code>Python</code> 提供了 <strong>长字符串</strong> 的使用。所谓长字符串，就是可以直接换行书写（不用加反斜杠 <code>\</code>）的字符串。</p></li><li><p><code>Python</code> 长字符串由三个双引号 <code>&quot;&quot;&quot;</code> 或者三个单引号 <code>'''</code> 创建。</p></li><li><p>长字符串中的换行、空格、缩进等空白符都会 <strong>原样输出</strong>。</p></li><li><p>在 “双引号长字符串中放置单引号” 或 “单引号长字符串中放置双引号” 不会导致解析错误。</p></li><li><p>如果长字符串 <strong>没有赋值</strong> 给任何变量，那么这个长字符串就相当于 <strong>多行注释</strong>。</p></li></ul><h3 id="1-2-3-原始字符串-raw-string">1.2.3 原始字符串（Raw String）</h3><ul><li><p><strong>原始字符串</strong>（<code>Raw String</code>）就是在普通字符串或者长字符串的开头加上 <code>r</code> 或 <code>R</code> 前缀。</p><ul><li>示例：<code>str = r&quot;F:\anaconda\envs\py39torch\Lib\site-packages\__pycache__&quot;</code></li></ul></li><li><p>如果想要在打印的字符串中出现引号，按照普通字符串的做法需要对引号进行转义（加转义字符 <code>\</code>），但是和普通字符串不同的是，如果在原始字符串中使用转义字符，那么用于转义的反斜杠会变成原始字符串内容的一部分。即 <code>print(r'I\'m a great coder!')</code> 输出结果为 <code>I\'m a great coder!</code>。</p></li><li><p>原始字符串中的反斜杠会对字符串 <strong>结束</strong> 的引号进行转义，因此 <strong>原始字符串的结尾处不能使用反斜杠</strong>，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。在 <code>Python</code> 中有 <strong>两种方式</strong> 解决这个问题：</p><ul><li><p>改用长字符串的写法，不要使用原始字符串。</p></li><li><p>单独书写反斜杠。例：<code>print(r'F:\anaconda\envs' '\\')</code>，输出结果 <code>F:\anaconda\envs\</code>，这是因为 <code>Python</code> <strong>会自动将</strong> <code>print</code> <strong>函数中的两个字符串拼接在一起</strong>。</p></li></ul></li></ul><h3 id="1-2-4-字符串转换">1.2.4 字符串转换</h3><ul><li><p><code>str(object)</code>：内置函数，将对象 <code>object</code> 转化为字符串并返回。</p><ul><li><p><code>object</code> 默认为空字符串 <code>''</code>，所以不传参时，返回空字符串，即 <code>str()</code> 返回 <code>''</code>。</p></li><li><p>当 <code>object</code> 为表达式时，<strong>先将表达式计算出结果</strong>，<strong>再将结果转为字符串</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">2</span>+<span class="number">3</span>)) <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">2</span>**<span class="number">3</span>)) <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">2E3</span>)) <span class="comment"># 2000.0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>repr(x)</code>：内置函数，将对象转化为供解释器读取的字符串并返回。可以将读取到的格式字符（例：换行符、制表符）转化为相应的转义字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&quot;物品\t单价\t数量\n包子\t1\t2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># 输出如下：</span></span><br><span class="line"><span class="comment"># 物品单价数量</span></span><br><span class="line"><span class="comment"># 包子12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(s)) <span class="comment"># &#x27;物品\t单价\t数量\n包子\t1\t2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>eval(str)</code>：用来执行一个字符串表达式，并 <strong>返回表达式的值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;2 + 3&quot;</span>)) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-5-转义字符">1.2.5 转义字符</h3><ul><li><p>在字符串中，反斜杠 <code>\</code> 和特定的字符可以组成转义字符，<code>Python</code> 支持的转义字符如下表所示。</p><table><thead><tr><th style="text-align:center">转义字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>\n</code></td><td style="text-align:center">换行符，将光标位置移到下一行开头</td></tr><tr><td style="text-align:center"><code>\r</code></td><td style="text-align:center">回车符，将光标位置移到本行开头</td></tr><tr><td style="text-align:center"><code>\t</code></td><td style="text-align:center">水平制表符，也即 <code>tab</code> 键，<code>Pycharm</code> 中占用 <code>4</code> 个空格，<code>cmd</code> 中占用 <code>8</code> 个空格</td></tr><tr><td style="text-align:center"><code>\a</code></td><td style="text-align:center">蜂鸣器响铃。</td></tr><tr><td style="text-align:center"><code>\b</code></td><td style="text-align:center">退格（<code>Backspace</code>），将光标位置移到前一列。</td></tr><tr><td style="text-align:center"><code>\\</code></td><td style="text-align:center">反斜线</td></tr><tr><td style="text-align:center"><code>\'</code></td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center"><code>\&quot;</code></td><td style="text-align:center">双引号</td></tr></tbody></table></li></ul><h3 id="1-2-6-格式化输出">1.2.6 格式化输出</h3><h4 id="1-格式化字符串">（1）格式化字符串</h4><ul><li><p><strong>格式化字符串</strong> 相当于一个 <strong>字符串模板</strong>，可以放置一些转换说明符。<strong>转换说明符</strong><br>（<code>Conversion Specifier</code>）就是以 <code>%</code> 开头的占位符，用来对各种类型的数据进行格式化输出，它会被后面表达式（变量、常量、数字、字符串、加减乘除等各种形式）的值代替。</p></li><li><p>格式化字符串（<code>&quot;格式化字符串模板&quot; % (传递给模板的参数)</code>）是一个 <strong>整体</strong>，传递给 <code>print</code> 函数相当于传递一个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串模板&quot;</span> % (传递给模板的参数))</span><br></pre></td></tr></table></figure></li><li><p>转换说明符的语法格式：<code>%[(name)][flags][width][.precision] typecode</code>。</p><ul><li><p><code>name</code>：可选。表示 <strong>参数的名称</strong>，后面的替换表达式需要使用字典格式，使用 <code>name</code> 时需要用括号包围。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：%(name)s，年龄：%(age)d&quot;</span> % &#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>, <span class="string">&quot;name&quot;</span>:<span class="string">&quot;dong&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>flags</code>：可选。表示 <strong>对齐方式</strong>，指定宽度时 <strong>默认右对齐</strong>，可以选择 <code>+</code>、<code>-</code>、<code>' '</code> 或 <code>0</code>（允许多选）。其中，对于字符串，只能使用 <code>-</code> 标志，因为符号对于字符串没有意义，而补 <code>0</code> 会改变字符串的值。</p><ul><li><p><code>+</code> 表示输出的正数前面显示 <code>+</code>。</p></li><li><p><code>-</code> 表示左对齐。</p></li><li><p><code>#</code> 表示在八进制数前面显示 <code>0o</code>，在十六进制前面显示 <code>0x</code> 或者 <code>0X</code>（取决于用的是 <code>x</code> 还是 <code>X</code>）。</p></li><li><p><code>' '</code> 为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。</p></li><li><p><code>0</code> 表示宽度不足时，使用 <code>0</code> 填充。</p><ul><li>对于数字，指定左对齐时，在右边补 <code>0</code> 是没有效果的，因为这样会改变数字的值。</li></ul></li></ul></li><li><p><code>width</code>：可选。表示 <strong>最小输出宽度</strong>，如果输出大于 <code>width</code>，则 <code>width</code> 失效，按照原数据宽度输出。</p><ul><li><p>可以使用 <code>*</code> 表示最小显示宽度的占位符，然后再给 <code>*</code> 传递参数。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义最小显示宽度为12，%f 默认精确到小数点后 6 位</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%0*f&quot;</span> % (<span class="number">12</span>, math.pi)) <span class="comment"># 00003.141593</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>.precision</code>：可选。表示 <strong>小数点后精度</strong>。精度需要放在最小宽度之后，中间用点号 <code>.</code> 隔开：<code>%width.precision</code>；也可以不写最小宽度，只写精度：<code>%.precision</code>。</p><ul><li><p>可以使用 <code>*</code> 表示小数点后精度的占位符，然后再给 <code>*</code> 传递参数。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义精确到小数点后 3 位</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.*f&quot;</span> % (<span class="number">3</span>, math.pi)) <span class="comment"># 3.142</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>typecode</code>：<strong>必选</strong>。表示 <strong>输出数据</strong> 的具体 <strong>类型</strong>。</p><table><thead><tr><th style="text-align:center">类型符号</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><code>s</code></td><td style="text-align:center">使用 <code>str()</code> 函数将表达式转换为字符串</td></tr><tr><td style="text-align:center"><code>d</code>、<code>i</code></td><td style="text-align:center"><strong>转换为带符号的十进制整数</strong>，<strong>仅适用于数字</strong></td></tr><tr><td style="text-align:center"><code>b</code></td><td style="text-align:center">转换为带符号的二进制整数，仅适用于整数</td></tr><tr><td style="text-align:center"><code>o</code></td><td style="text-align:center">转换为带符号的八进制整数，仅适用于整数</td></tr><tr><td style="text-align:center"><code>x</code>、<code>X</code></td><td style="text-align:center">转换为带符号的十六进制整数，仅适用于整数</td></tr><tr><td style="text-align:center"><code>e</code></td><td style="text-align:center">转化为科学计数法表示的浮点数（<code>e</code> 小写），仅适用于数字</td></tr><tr><td style="text-align:center"><code>E</code></td><td style="text-align:center">等价于<code>e</code>，但将 <code>e</code> 转换成 <code>E</code></td></tr><tr><td style="text-align:center"><code>f</code></td><td style="text-align:center"><strong>转化为十进制浮点数</strong>，<strong>默认精确到小数点后六位</strong>，<strong>仅适用于数字</strong></td></tr><tr><td style="text-align:center"><code>F</code></td><td style="text-align:center">等价于 <code>f</code>，但将 <code>nan</code> 和 <code>inf</code> 转换成 <code>NAN</code>和 <code>INF</code></td></tr><tr><td style="text-align:center"><code>g</code></td><td style="text-align:center">保留 <code>6</code> 位有效数字，整数部分大于 <code>6</code> 位则用科学计数法表示，考虑四舍五入，仅适用于数字</td></tr><tr><td style="text-align:center"><code>G</code></td><td style="text-align:center">同 <code>g</code>，区别仅为当科学计数法表示时，使用 <code>E</code></td></tr><tr><td style="text-align:center"><code>c</code></td><td style="text-align:center">将 <code>ASCII</code> 码转换为字符，仅适用于整数和字符</td></tr><tr><td style="text-align:center"><code>r</code></td><td style="text-align:center">使用 <code>repr()</code> 函数将表达式转换为字符串</td></tr></tbody></table></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：%s&quot;</span> % <span class="string">&quot;dong&quot;</span>) <span class="comment"># 输出  用户名：dong</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>print()</code> 函数中间的 <code>%</code> 是一个分隔符，它左面是格式化字符串，右面是要输出的表达式。格式化字符串中可以包含多个转换说明符，这个时候也要提供多个表达式，用以替换对应的转换说明符。多个表达式必须使用小括号 <code>()</code> 包围起来。总之，有几个占位符，后面就得跟着几个表达式。</li></ul></li></ul></li></ul><h4 id="2-format-函数">（2）format() 函数</h4><ul><li><p>自 <code>Python 2.6</code> 版本开始，字符串类型（<code>str</code>）提供了 <code>format()</code> 函数对字符串进行格式化，语法：<code>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</code>。</p></li><li><p>模板字符串格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX &#123;[index][:[fill][align][sign][<span class="comment">#][0][width][grouping_option][.precision] [type]]&#125; XXX</span></span><br></pre></td></tr></table></figure><p>其中 <code>XXX</code> 表示正常文本，会原样输出，<code>&#123;&#125;</code> 内部的字段会被 <code>format()</code> 中的参数替换。</p><ul><li><p><code>index</code>：可选。表示 <code>:</code> 后边设置的格式要作用到 <code>format()</code> 中第几个参数，参数的索引值从 <code>0</code> 开始。</p><ul><li><p>如果省略此选项，则会根据 <code>format()</code> 中参数的先后顺序自动分配。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;dong&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">height = <span class="number">188</span></span><br><span class="line">weight = <span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; 您好，您的年龄：&#123;&#125; 岁，您的身高：&#123;&#125; cm，您的体重：&#123;&#125; kg&quot;</span>.<span class="built_in">format</span>(name, age, height, weight))</span><br></pre></td></tr></table></figure></li><li><p>支持通过名称填充，<code>format()</code> 中的参数名称与 <code>index</code> 名称要对应。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：&#123;name&#125;，年龄：&#123;age&#125;&quot;</span>.<span class="built_in">format</span>(age=<span class="number">18</span>, name=<span class="string">&quot;dong&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>支持通过列表填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = [<span class="string">&#x27;dong&#x27;</span>, <span class="number">18</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：&#123;list[0]&#125;, 年龄：&#123;list[1]&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">list</span>=person)) <span class="comment"># 输出：用户名：dong, 年龄：18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：&#123;0[0]&#125;, 年龄：&#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(person)) <span class="comment"># 输出：用户名：dong, 年龄：18</span></span><br></pre></td></tr></table></figure></li><li><p>支持通过字典填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;dong&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：&#123;dict[name]&#125;, 年龄：&#123;dict[age]&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">dict</span>=person)) <span class="comment"># 输出：用户名：dong, 年龄：18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：&#123;0[name]&#125;, 年龄：&#123;0[age]&#125;&quot;</span>.<span class="built_in">format</span>(person)) <span class="comment"># 输出：用户名：dong, 年龄：18</span></span><br></pre></td></tr></table></figure></li><li><p>支持参数复用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;dong&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;1&#125; 您好，您的年龄：&#123;0&#125; 岁，我国法律规定，年满 &#123;0&#125; 周岁是成年的标志。&quot;</span>.<span class="built_in">format</span>(age, name))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fill</code>：可选，默认空格。表示空白处填充的字符。</p><ul><li>注：当填充字符为逗号（<code>,</code>）且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例：<code>1000000</code> 会输出 <code>1,000,000</code>。</li></ul></li><li><p><code>align</code>：可选。表示数据的对齐方式。<strong>此选项需和</strong> <code>width</code> <strong>参数一起使用</strong>。</p><ul><li><p><code>&lt;</code>：数据左对齐。</p></li><li><p><code>&gt;</code>：数据右对齐。</p></li><li><p><code>=</code>：数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。</p></li><li><p><code>^</code>：数据居中。</p></li></ul></li><li><p><code>sign</code>：指定数字类型符号。</p><ul><li><p><code>+</code>：正数前加正号，负数前加负号。</p></li><li><p><code>-</code>：正数前不加正号，负数前加负号。</p></li><li><p><code> </code>（空格）：正数前加空格，负数前加负号。</p></li></ul></li><li><p><code>#</code>：对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 <code>0b</code>、<code>0o</code>、<code>0x</code> 或 <code>0X</code> 前缀；反之则不显示前缀。</p></li><li><p><code>0</code>：用 <code>0</code> 补足 <code>width</code> 宽度。如果设置了 <code>fill</code>，则使用 <code>fill</code> 填充。</p></li><li><p><code>width</code>：可选。表示最小输出宽度，如果输出大于 <code>width</code>，则原数据宽度输出。</p></li><li><p><code>grouping_option</code>：可选。表示千分位符，取值为 <code>_</code> 或 <code>,</code>。</p></li><li><p><code>.precision</code>：可选。表示保留的小数位数，小数点不能省略。</p></li><li><p><code>type</code>：指定输出数据的具体类型。与 <code>（1）</code> 相同。</p></li></ul></li><li><p>如果要在文本中输出大括号，需要使用 <code>&#123;&#125;</code> 来转义，不是使用转义字符 <code>\</code>。例：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is a format &#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;test&quot;</span>)) <span class="comment"># 输出 This is a format &#123;test&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-f-string">（3）f-string</h4><ul><li><p><code>f-string</code> 是 <code>python 3.6</code> 新添加的一种字符串格式化方法。在字符串前加前缀 <code>f</code> 或 <code>F</code>，通过 <code>&#123;expression&#125;</code> 表达式，把 <code>Python</code> 表达式的值添加到字符串内。</p></li><li><p><code>f-string</code> 采用 <code>&#123;content:format&#125;</code> 设置字符串格式。</p><ul><li><code>content</code> 是替换并填入字符串的内容，可以是变量、表达式或函数等，<code>format</code> 是 <strong>格式描述符</strong>。</li></ul></li><li><p><code>f-string</code> 的格式描述符 <code>format</code> 与 <code>format()</code> 函数的模板格式相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[fill][align][sign][#][<span class="number">0</span>][width][grouping_option][.<span class="property">precision</span>] [type]&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;dong&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">money = <span class="number">8888888888.88</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：用户名：dong，年龄：018, 余额：$8,888,888,888.880</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;用户名：<span class="subst">&#123;name:s&#125;</span>，年龄：<span class="subst">&#123;age:<span class="number">0</span>&gt;3d&#125;</span>, 余额：<span class="subst">&#123;money:$&gt;<span class="number">18</span>,<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># format() 函数格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名：&#123;:s&#125;，年龄：&#123;:0&gt;3d&#125;, 余额：&#123;:$&gt;18,.3f&#125;&quot;</span>.<span class="built_in">format</span>(name, age, money))</span><br></pre></td></tr></table></figure></li></ul><h1>二、Python 输入/输出</h1><h2 id="2-1-input-函数：获取用户输入的字符串">2.1 input() 函数：获取用户输入的字符串</h2><ul><li><p><code>input(prompt)</code> 函数的 <strong>用法</strong> 为：<code>str = input(prompt)</code></p><ul><li><p><code>str</code> 表示一个字符串类型的变量，<code>input</code> 会将控制台读取到的字符串放入 <code>str</code> 中。</p></li><li><p><code>prompt</code> 表示提示信息，它会显示在控制台，如果不写 <code>prompt</code>，就不会有任何提示信息。</p><ul><li><strong>注</strong>：<code>prompt</code> <strong>并不会作为返回值返回给调用方</strong>。</li></ul></li></ul></li><li><p><code>input(prompt)</code> 是 <code>Python</code> 的 <strong>内置函数</strong>，用于从控制台读取用户输入的内容并 <strong>返回</strong>。</p><ul><li>当程序执行到 <code>input(prompt)</code> 语句时，程序会 <strong>暂停</strong> 并等待用户输入，用户输入回车后程序继续运行。</li></ul></li><li><p><code>input(prompt)</code> 函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。</p></li></ul><h2 id="2-2-print-函数：输出字符串到控制台">2.2 print() 函数：输出字符串到控制台</h2><ul><li><p>语法格式：<code>print(*args, sep=' ', end='\n', file=sys.stdout, flush=False)</code>，参数之间使用逗号 <code>,</code> 分隔。</p><ul><li><p><code>*args</code> 是 <strong>位置参数</strong>，也是 <strong>单星号</strong> 参数，即 <strong>元组可变长</strong> 参数。表示 <code>print</code> 函数可以接受 <strong>0个或多个参数</strong>，并且这些传进来的 <strong>位置参数</strong> 都被放在元组 <code>args</code> 中，因此 <code>print</code> 函数 <strong>可以输出多个值</strong>。</p><ul><li><p><strong>注</strong>：<strong>位置参数要置于关键字参数之前</strong>。</p></li><li><p>当传入多个字符串，且字符串之间不使用 <code>,</code> 分隔，那么多个字符串会 <strong>自动拼接</strong>，且中间 <strong>无空格分隔</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dong&quot;</span> <span class="string">&quot;love&quot;</span> <span class="string">&quot;kexin&quot;</span>,) <span class="comment"># donglovekexin</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dong&quot;</span> <span class="string">&quot;love&quot;</span> <span class="string">&quot;kexin&quot;</span>, sep=<span class="string">&quot;,&quot;</span>) <span class="comment"># donglovekexin</span></span><br></pre></td></tr></table></figure><ul><li>如果在多个字符串之间使用 <code>,</code> 分隔，<code>print</code> 函数会在输出信息之间添加分隔符。默认情况下，分隔符是一个空格。</li></ul></li></ul></li><li><p><code>sep</code> 是 <strong>关键字参数</strong>。表示输出多个参数时使用什么 <strong>分隔符</strong> 进行分隔，默认以 <strong>空格</strong> 分隔多个参数。</p></li><li><p><code>end</code> 是 <strong>关键字参数</strong>。表示输出的最后使用什么符号 <strong>结尾</strong>，默认使用 <code>\n</code>，表示 <code>print</code> 函数输出之后会自动换行。如果希望 <code>print</code> 函数输出之后不会换行，则重设 <code>end</code> 参数即可。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出：name: dong, age: 18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name: dong&quot;</span>, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age: 18&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>file</code> 是 <strong>关键字参数</strong>。表示 <code>print</code> 函数的 <strong>输出目标</strong>，默认值为 <code>sys.stdout</code>，该默认值代表了系统标准输出，即 <strong>控制台</strong>。可以通过改变该参数让 <code>print</code> 函数输出到特定文件中。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./text.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dong love kexin&quot;</span>, file=f)</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/02/01.png" height="52"/></div></li><li><p><code>flush</code> 是 <strong>关键字参数</strong>。用于控制输出缓存，默认为 <code>False</code>，表示不刷新缓存。如果 <code>flush = True</code>，它会强制刷新缓存。</p><ul><li><p>例 <code>1</code>：实现 <code>loading......</code> 的 <code>.</code> 一个一个输出。（<code>PyCharm</code> 中显示不出区别）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loading&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">False</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loading&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/02/01.gif" width="520"/></div></li><li><p>例 <code>2</code>：不使用 <code>with</code> 语句打开文件时，不会主动关闭文件，<code>flush=False</code>的 <code>print</code> 函数中的内容不会被写入。（<code>PyCharm</code> 中显示不出区别）</p><ul><li><strong>注</strong>：<code>with</code> 语句执行结束后会自动关闭文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;flush.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>, file=f)</span><br></pre></td></tr></table></figure><ul><li><p>在 <code>Anaconda Prompt</code> 中运行上述代码后打开 <code>flush.txt</code> 文件，发现 <code>hello world</code> 并未被写入文件。只有关闭文件，即 <code>f.close()</code> 后才会将字符串写进文件中。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/02/02.png" width="666"/></div></li><li><p>下面我们将 <code>flush</code> 设置为 <code>True</code>，强制刷新缓存区，它会立即将字符串写入 <code>flush.txt</code> 文件，而无需使用 <code>f.close()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;flush.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>, file=f, flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/02/03.png" width="666"/></div></li></ul></li></ul></li></ul></li></ul><h1>三、运算符</h1><h2 id="3-1-算术运算符">3.1 算术运算符</h2><ul><li><p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>（取模 / 取余）、<code>**</code>（幂运算/次方运算）、<code>//</code>（整除）。</p><ul><li><p>当 <code>+</code> 用于数字时表示加法，但是当 <code>+</code> 用于相同类型的序列（字符串、列表、元组）时，它还有拼接的作用，得到的是拼接后的 <strong>新序列</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup1))  <span class="comment"># 2791578635648</span></span><br><span class="line">tup2 = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">tup1 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup1)  <span class="comment"># (1, 2, 3, 5, 6, 7)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup1))  <span class="comment"># 2791620085312</span></span><br></pre></td></tr></table></figure><ul><li>集合不支持拼接操作。</li></ul></li><li><p><code>*</code> 除了可以用作乘法运算，还可以用来重复相同类型的序列（字符串、列表、元组），即将 <code>n</code> 个同样的序列拼接起来，得到的是拼接后的 <strong>新序列</strong>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 3084696793728</span></span><br><span class="line">lst = lst * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 3084696795008</span></span><br></pre></td></tr></table></figure></li><li><p><code>/</code> 运算得到的结果永远都是浮点数。</p></li><li><p><code>//</code> 表示整除，只保留结果的整数部分（向下取整）。</p><ul><li>如果有小数参与运算时，<code>//</code> 的结果为小数（小数部分为 <code>0</code>）；否则为整数。</li></ul></li><li><p><code>/</code> 、<code>//</code> 和 <code>%</code> 的除数为 <code>0</code> 将抛出 <code>ZeroDivisionError</code> 异常。</p></li><li><p>只有当除数为负时，取模 <code>%</code> 的结果才为负。换句话说，取模结果的正负和被除数没有关系，只由除数决定。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">8</span> % -<span class="number">3</span>)  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(-<span class="number">8</span> % <span class="number">3</span>)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><ul><li><p>规律：</p><ul><li><p>如果 <code>a</code>、<code>b</code> 不等于 <code>0</code>，则 <code>a % b + (-a) % b = b</code>。</p></li><li><p>如果 <code>a</code>、<code>b</code> 不等于 <code>0</code>，则 <code>a % (-b) + (-a) % b = 0</code> 。</p></li></ul></li></ul></li><li><p><code>%</code> 两边的数字都是整数时，取模的结果也是整数；只要有一个数字是浮点数时，取模的结果就是浮点数。</p></li><li><p>由于开方是次方的逆运算，所以可以使用 <code>**</code> 运算符间接实现开方运算。例：<code>81**(1/4)</code> 结果为 <code>3.0</code>。</p></li></ul></li></ul><h2 id="3-2-比较运算符-关系运算符">3.2 比较运算符（关系运算符）</h2><ul><li><code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>，运算结果返回布尔值。</li><li>字符串、列表和元组比较是将每个元素进行比较。</li><li>集合比较是比较子集，即判断父子集（真子集）关系。</li><li>字典不支持比较。</li></ul><h2 id="3-3-赋值运算符">3.3 赋值运算符</h2><ul><li><p><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>**=</code>、<code>//=</code>、<code>:=</code></p></li><li><p><code>:=</code> 是 <code>Python3.8</code> 版本新增的运算符，称为 <strong>海象赋值运算符</strong>。</p><ul><li><p>海象运算符的优势在于能在 <strong>不允许赋值</strong> 的地方使用赋值变量。</p></li><li><p>海象运算符左侧有个标识符，赋值表达式的值等于分配给这个标识符的值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 海象运算符，可在表达式内部为变量赋值。</span></span><br><span class="line">string = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 省略了一次赋值和一次函数len的调用：length = len(string)</span></span><br><span class="line"><span class="built_in">print</span>((length := <span class="built_in">len</span>(string)) + <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;string的长度为<span class="subst">&#123;length&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>+=</code>、<code>*=</code> 支持字符串、列表、元组的拼接操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world, &quot;</span></span><br><span class="line"><span class="built_in">str</span> *= <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>) <span class="comment"># hello world, hello world, hello world, </span></span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<strong>普通赋值</strong> 会以 <strong>新建</strong> 的方式进行拼接操作，<strong>增强赋值</strong> 会以 <code>inplace</code>（原地操作）方式进行赋值，即数据本身可修改（列表）时，直接修改原数据（追加数据），因此 <strong>增强赋值效率更高</strong>。</p><ul><li><p>例 <code>1</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 2267939344704</span></span><br><span class="line">lst *= <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 2267939344704</span></span><br><span class="line">lst = lst * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 2267939346560</span></span><br></pre></td></tr></table></figure></li><li><p>例 <code>2</code>：增强赋值不改变原始数据引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst1 = lst</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 1481102594368</span></span><br><span class="line">lst *= <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 1481102594368</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1)) <span class="comment"># 1481102594368</span></span><br></pre></td></tr></table></figure></li><li><p>例 <code>3</code>：普通赋值改变原始数据引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst1 = lst</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 1934793904448</span></span><br><span class="line">lst = lst * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 1934793906304</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst1)) <span class="comment"># 1934793904448</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>基本序列赋值</strong>：本质上为 <strong>解包</strong>，格式：<code>var1, var2, ..., varN = iterable</code>，可以理解为左侧变量 <strong>同时赋值</strong>，要求赋值符号左边变量的数量与可迭代对象中元素数量相等。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">5</span>, <span class="number">7</span>  <span class="comment"># 等同于 (a,b) = (3,4)</span></span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># 5 7</span></span><br><span class="line">a, b = (<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># 5 7</span></span><br><span class="line">[a, b] = [<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># 5 7</span></span><br><span class="line">a, b = <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># 你 好</span></span><br><span class="line">a, b = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># name age</span></span><br><span class="line">a, b = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>&#125; <span class="comment"># 集合中的元素无序</span></span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># B A</span></span><br></pre></td></tr></table></figure></li><li><p><strong>多目标赋值</strong>：一个数据同时赋值给多个变量，即多个变量指向同一地址。格式：<code>var1 = var2 = ... = varN = obj</code>。</p><ul><li><p><strong>注</strong>：当 <code>obj</code> 为可变数据时，<code>obj</code> 被修改，指向 <code>obj</code> 的所有引用会同时被修改。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">999</span></span><br><span class="line">d = <span class="number">999</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 2690117402864</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))  <span class="comment"># 2690117402864</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))  <span class="comment"># 2690117402864</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(d))  <span class="comment"># 2690117402736</span></span><br><span class="line">b = d</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))  <span class="comment"># 2690117402736</span></span><br><span class="line">a = b = c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)  <span class="comment"># [1, 2, 3, 4] [1, 2, 3, 4] [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4-逻辑运算符">3.4 逻辑运算符</h2><h3 id="3-4-1-逻辑运算符">3.4.1 逻辑运算符</h3><ul><li><p><code>and</code>（逻辑与）、<code>or</code>（逻辑或）、<code>not</code>（逻辑非）：<code>and</code> 和 <code>or</code> 运算符不返回布尔值。</p><ul><li><p>对于 <code>and</code> 运算符，两边的值 <strong>都为真</strong> 时最终结果才为 <strong>真</strong>，只要其中 <strong>有一个值为假</strong>，那么最终结果就是 <strong>假</strong>，所以 <code>Python</code> 按照下面的规则执行 <code>and</code> 运算：</p><ul><li><p>如果左边表达式的值为假，不计算右边表达式（<strong>短路</strong>），此时 <code>and</code> 会把左边 <strong>表达式的值</strong> 作为 <strong>最终结果</strong>，而 <strong>不是返回布尔值</strong>。</p></li><li><p>如果左边表达式的值为真，<code>and</code> 会继续计算右边表达式的值，并将右边 <strong>表达式的值</strong> 作为 <strong>最终结果</strong>，而 <strong>不是返回布尔值</strong>。</p></li></ul></li><li><p>对于 <code>or</code> 运算符，两边的值 <strong>都为假</strong> 时最终结果才为 <strong>假</strong>，只要其中 <strong>有一个值为真</strong>，那么最终结果就是 <strong>真</strong>，所以 <code>Python</code> 按照下面的规则执行 <code>or</code> 运算：</p><ul><li><p>如果左边表达式的值为真，不计算右边表达式（<strong>短路</strong>），此时 <code>or</code> 会把左边 <strong>表达式的值</strong> 作为 <strong>最终结果</strong>，而<strong>不是返回布尔值</strong>。</p></li><li><p>如果左边表达式的值为假，<code>or</code> 会继续计算右边表达式的值，并将右边 <strong>表达式的值</strong> 作为 <strong>最终结果</strong>，而 <strong>不是返回布尔值</strong>。</p></li></ul></li><li><p>对于 <code>not</code> 运算符，表达式的值为假，返回 <code>True</code>；表达式的值为真，返回 <code>False</code>。</p></li></ul></li><li><p><strong>注</strong>：<code>and</code> 和 <code>or</code> 运算符具有 <strong>短路机制</strong>，即无论右侧的表达式是否报错，都会先计算左侧表达式结果，然后再根据结果决定是否执行右侧表达式。例：</p><ul><li><code>print(&quot;Hello world&quot; or 2 / 0)</code> 会输出 <code>Hello world</code> 而不是报错。</li><li><code>print(&quot;Hello world&quot; and 2 / 0)</code> 会报错，因为 <code>Hello world</code> 为 <code>True</code> 会继续执行 <code>2 / 0</code> 而报错。</li></ul></li><li><p><code>None</code>、<code>False</code>、<code>0</code>、空字符串、空列表、空元组、空字典、空集合都会被认定为 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="string">&quot;welcome to python&quot;</span></span><br><span class="line">c = ()</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="comment"># and 逻辑与运算符：左边为假，返回左边；否则返回右边。</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">and</span> a)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">and</span> d)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(d <span class="keyword">and</span> c)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> c)  <span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)  <span class="comment"># welcome to python</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">and</span> a)  <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># or 逻辑或运算符：左边为真，返回左边；否则返回右边。</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> c)  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">or</span> a)  <span class="comment"># welcome to python</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">or</span> a)  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">or</span> d)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(d <span class="keyword">or</span> c)  <span class="comment"># ()</span></span><br><span class="line"><span class="comment"># not 逻辑非运算符：假，返回真；真，返回假。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> a)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> b)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> c)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> (a <span class="keyword">and</span> c))  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 优先级：not &gt; and &gt; or</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> a <span class="keyword">and</span> b <span class="keyword">or</span> d)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> c <span class="keyword">and</span> b <span class="keyword">or</span> a / d)  <span class="comment"># welcome to python</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-2-all-any-内置函数">3.4.2 all、any 内置函数</h3><ul><li><p><code>all(iterable)</code>：如果 <code>iterable</code> 的 <strong>所有元素</strong> 均为 <strong>真</strong> 值则返回 <code>True</code>（ <code>iterable</code> 为空返回 <code>True</code>）。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(lst))  <span class="comment"># True</span></span><br><span class="line">lst.append(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(lst))  <span class="comment"># False</span></span><br><span class="line">lst.clear()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(lst))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p><code>any(iterable)</code>：如果 <code>iterable</code> 的 <strong>任一元素</strong> 为 <strong>真</strong> 值则返回 <code>True</code>（<code>iterable</code> 为空返回 <code>False</code>）。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">0</span>, <span class="number">0.</span>, <span class="number">0j</span>, <span class="string">&quot;&quot;</span>, (), [], &#123;&#125;, <span class="built_in">set</span>(), <span class="literal">None</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(lst))  <span class="comment"># False</span></span><br><span class="line">lst.append(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(lst))  <span class="comment"># True</span></span><br><span class="line">lst.clear()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(lst))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-5-成员运算符-in">3.5 成员运算符 in</h2><ul><li><p><code>Python</code> 的成员运算符用于判断一个对象是否是另一个 <strong>可迭代对象</strong> 的成员，成员运算符仅有两个：<code>in</code> 和 <code>not in</code>，返回的结果为 <code>True</code> 或 <code>False</code>。</p></li><li><p>成员运算符后面的对象必须是 <strong>可迭代对象</strong>（列表、元组、字典、集合、字符串和迭代器等）。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9j</span>, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>&#125;, (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;he&quot;</span> <span class="keyword">in</span> lst[<span class="number">0</span>])   <span class="comment"># True，字符串片段也属于这个字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> <span class="keyword">in</span> lst)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span> ,<span class="number">2</span>] <span class="keyword">in</span> lst)    <span class="comment"># False，列表片段不属于这个列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span> <span class="keyword">in</span> lst)         <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-6-身份运算符-is">3.6 身份运算符 is</h2><ul><li><p>身份运算符是 <code>Python</code> 用来判断两个对象的 <strong>内存地址是否相同</strong> 的一种运算符号，身份运算符只有 <code>is</code> 和 <code>is not</code> 两个运算符，返回的结果为 <code>True</code> 或 <code>False</code>。</p></li><li><p><code>==</code> 用来比较两个变量的 <strong>值</strong> 是否相等，而 <code>is</code> 则用来比对两个变量 <strong>引用</strong> 的是否是同一个对象。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst1 = [<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9j</span>, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>&#125;, (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)] <span class="comment"># 新建列表</span></span><br><span class="line">lst2 = [<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9j</span>, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>&#125;, (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)] <span class="comment"># 新建列表</span></span><br><span class="line">lst3 = lst1 <span class="comment"># 引用指向 lst1</span></span><br><span class="line">lst4 = copy.deepcopy(lst1)  <span class="comment"># 深度拷贝，新建列表</span></span><br><span class="line"><span class="comment"># 值比较</span></span><br><span class="line"><span class="built_in">print</span>(lst2 == lst1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(lst3 == lst1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(lst4 == lst1) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 地址比较</span></span><br><span class="line"><span class="built_in">print</span>(lst2 <span class="keyword">is</span> lst1) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(lst3 <span class="keyword">is</span> lst1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(lst4 <span class="keyword">is</span> lst1) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst2) == <span class="built_in">id</span>(lst1)) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst3) == <span class="built_in">id</span>(lst1)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst4) == <span class="built_in">id</span>(lst1)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>Pycharm</code> <strong>优化策略</strong>：对于大小相同且内外皆不可变的数据，<code>Pycharm</code>会使用同一地址进行存储，但是 <code>cmd</code> 命令提示符中依然使用不同地址进行存储。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">tup1 = (<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9j</span>, (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)) <span class="comment"># 新建列表</span></span><br><span class="line">tup2 = (<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9j</span>, (<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>)) <span class="comment"># 新建列表</span></span><br><span class="line">tup3 = tup1 <span class="comment"># 引用指向 lst1</span></span><br><span class="line">tup4 = copy.deepcopy(tup1)  <span class="comment"># 深度拷贝，新建列表</span></span><br><span class="line"><span class="comment"># 值比较</span></span><br><span class="line"><span class="built_in">print</span>(tup2 == tup1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(tup3 == tup1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(tup4 == tup1) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 地址比较</span></span><br><span class="line"><span class="built_in">print</span>(tup2 <span class="keyword">is</span> tup1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(tup3 <span class="keyword">is</span> tup1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(tup4 <span class="keyword">is</span> tup1) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup2) == <span class="built_in">id</span>(tup1)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup3) == <span class="built_in">id</span>(tup1)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(tup4) == <span class="built_in">id</span>(tup1)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-7-位运算符">3.7 位运算符</h2><ul><li><p>按位运算符需要将数字转换为 <strong>补码</strong>，然后参与运算。</p><ul><li><p>原码：整数转为二进制得到的就是原码。</p></li><li><p>反码：除了符号位，其他位全部取反，即 <code>0</code> 变 <code>1</code>，<code>1</code> 变 <code>0</code>。</p></li><li><p>补码：反码加 <code>1</code>。</p></li></ul></li></ul><h3 id="3-7-1-位运算符-二进制">3.7.1 位运算符（二进制）</h3><ul><li><p><code>&amp;</code>：按位与运算符，如果两个相应位都为 <code>1</code>，则该位的结果为 <code>1</code>，否则为 <code>0</code>。</p></li><li><p><code>|</code>：按位或运算符，只要两个相应位有一个为 <code>1</code> 时，结果位就为 <code>1</code>。</p></li><li><p><code>^</code>：按位异或运算符，只要两个相应位不同，结果就为 <code>1</code>。</p></li><li><p><code>~</code>：按位取反运算符，对数据的每个二进制位取反（包含符号位），即把 <code>1</code> 变为 <code>0</code>，把 <code>0</code> 变为 <code>1</code>。<strong>规律</strong>：<code>~x = -(x+1)</code>。</p></li><li><p><code>&lt;&lt;</code>：按位左移运算符，运算数的各二进位全部左移若干位，右边补 <code>0</code>。<strong>规律</strong>：<code>x &lt;&lt; n = x * (2 ** n)</code>。</p></li><li><p><code>&gt;&gt;</code>：按位右移运算符，运算数的各二进位全部右移若干位，左边填充对应的符号位值，即正数补 <code>0</code>，负数补 <code>1</code>，这种填充方式被称为 <strong>符号扩展</strong>。<strong>规律</strong>：<code>x &gt;&gt; n = x // (2 ** n)</code>。</p><ul><li><p>负数如果一直右移，最终二进制位会全部变成 <code>1</code>，即十进制的 <code>-1</code> ( 二进制全 <code>1</code> 在补码中表示 <code>-1</code>)。</p></li><li><p>补位在转回十进制的过程中不做数值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num = -<span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(num))  <span class="comment"># -0b110100，即 10110100</span></span><br><span class="line"><span class="comment"># 原码：10110100</span></span><br><span class="line"><span class="comment"># 反码：11001011</span></span><br><span class="line"><span class="comment"># 补码：11001100</span></span><br><span class="line"><span class="comment"># 按位右移运算符针对补码操作，按位右移 3 位：11111001</span></span><br><span class="line"><span class="comment"># 11111001 对应反码：11111000</span></span><br><span class="line"><span class="comment"># 11111000 对应原码：11110111（前 4 位不做数值）</span></span><br><span class="line"><span class="comment"># 11110111 转十进制：-7</span></span><br><span class="line"><span class="built_in">print</span>(num &gt;&gt; <span class="number">3</span>)  <span class="comment"># -7</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-7-2-进制转换函数">3.7.2 进制转换函数</h3><ul><li><p><code>bin(x)</code>：内置函数，将一个整数转换为一个前缀为 <code>0b</code> 的 <strong>二进制</strong> 字符串。</p></li><li><p><code>oct(x)</code>：内置函数，将一个整数转换为一个前缀为 <code>0o</code> 的 <strong>八进制</strong> 字符串。</p></li><li><p><code>hex(x)</code>：内置函数，将一个整数转换为一个前缀为 <code>0x</code> 的 <strong>十六进制</strong> 字符串。</p></li></ul><h2 id="3-8-运算符优先级">3.8 运算符优先级</h2><table><thead><tr><th style="text-align:center">运算符说明</th><th style="text-align:center">Python运算符</th><th style="text-align:center">优先级（从高到低）</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">小括号</td><td style="text-align:center"><code>()</code></td><td style="text-align:center"><strong>19</strong></td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">索引运算符</td><td style="text-align:center"><code>x[i]</code> 或 <code>x[start: end [:step]]</code></td><td style="text-align:center"><strong>18</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">属性访问</td><td style="text-align:center"><code>x.attribute</code></td><td style="text-align:center"><strong>17</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">乘方</td><td style="text-align:center"><code>**</code></td><td style="text-align:center"><strong>16</strong></td><td style="text-align:center">右</td></tr><tr><td style="text-align:center">按位取反</td><td style="text-align:center"><code>~</code></td><td style="text-align:center"><strong>15</strong></td><td style="text-align:center">右</td></tr><tr><td style="text-align:center">符号运算符</td><td style="text-align:center"><code>+</code>（正号）、<code>-</code>（负号）</td><td style="text-align:center"><strong>14</strong></td><td style="text-align:center">右</td></tr><tr><td style="text-align:center">乘除</td><td style="text-align:center"><code>*</code>、<code>/</code>、<code>%</code>、<code>//</code></td><td style="text-align:center"><strong>13</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">加减</td><td style="text-align:center"><code>+</code>、<code>-</code></td><td style="text-align:center"><strong>12</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">位移</td><td style="text-align:center"><code>&gt;&gt;</code>、<code>&lt;&lt;</code></td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">按位与</td><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center">右</td></tr><tr><td style="text-align:center">按位异或</td><td style="text-align:center"><code>^</code></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">按位或</td><td style="text-align:center"><code>|</code></td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">比较运算符</td><td style="text-align:center"><code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td><td style="text-align:center"><strong>7</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center"><code>is</code> 运算符</td><td style="text-align:center"><code>is</code>、<code>is not</code></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center"><code>in</code> 运算符</td><td style="text-align:center"><code>in</code>、<code>not in</code></td><td style="text-align:center"><strong>5</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">逻辑非</td><td style="text-align:center"><code>not</code></td><td style="text-align:center"><strong>4</strong></td><td style="text-align:center">右</td></tr><tr><td style="text-align:center">逻辑与</td><td style="text-align:center"><code>and</code></td><td style="text-align:center"><strong>3</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">逻辑或</td><td style="text-align:center"><code>or</code></td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">左</td></tr><tr><td style="text-align:center">逗号运算符</td><td style="text-align:center"><code>exp1</code>, <code>exp2</code></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">左</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 入门</title>
      <link href="/posts/python/python3/01.html"/>
      <url>/posts/python/python3/01.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、Python 解释器</h1><ul><li><p><code>Python</code> 是一种高级计算机语言，设计它们的目的是为了方便程序员理解和使用。但严格意义上来说，计算机只能理解一种非常低级的计算机语言，也就是 <strong>机器语言</strong>。</p></li><li><p>我们需要设计一种方法，将高级语言翻译成计算机可以执行的机器语言。目前，有两种方法可以实现，分别是 <strong>编译器</strong> 和 <strong>解释器</strong>。</p></li><li><p>使用 <strong>编译器</strong> 将自身转换成机器语言的高级语言，通常称为 <strong>编译型语言</strong>；而使用 <strong>解释器</strong> 将自身转换成机器语言的高级语言，称为 <strong>解释型语言</strong>，<code>Python</code> 就是一种解释型编程语言。</p></li><li><p><strong>解释型语言</strong> 由 <strong>解释器</strong> 逐行对源码进行解释，一边解释一边执行，<strong>不会生成可执行程序</strong>。</p></li><li><p><code>Python</code> 官方针对 <strong>不同平台</strong>（例：<code>Windows</code>、<code>MacOS</code>、<code>Linux</code>）开发了不同的解释器，这些解释器必须要遵守同样的语法，识别同样的函数，完成同样的功能。只有这样，同一份代码才能在不同平台上拥有相同的执行结果。</p></li><li><p><code>Python</code> 解析器种类</p><ul><li><p><code>CPython</code>，<code>C</code> 语言开发的解释器，应用广泛的解释器。</p></li><li><p><code>IPython</code>，基于 <code>CPython</code> 的一种 <strong>交互式</strong> 解释器。</p></li><li><p><code>PyPy</code>，基于 <code>Python</code> 语言开发的解释器，解析效率低。</p></li><li><p><code>JPython</code>，运行在 <code>Java</code> 平台的解释器，直接把 <code>Python</code> 代码编译成 <code>Java</code> 字节码执行。</p></li><li><p><code>IronPython</code>，运行在微软 <code>.Net</code> 平台的解释器，直接把 <code>Python</code> 代码编译成 <code>.Net</code> 字节码执行。</p></li></ul></li><li><p><code>Python</code> 解析器下载</p><ul><li><p>官网：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Download Python 3.11.4</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/01.png" width="666"/></div></li></ul></li><li><p><code>Python</code> 解析器安装</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/02.png" width="399"/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/03.png" width="399"/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/04.png" width="399"/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/05.png" width="399"/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/06.png" width="399"/></div></li><li><p>测试安装成功：命令提示符 <code>cmd</code> 中输入 <code>python</code>，出现交互式语言即为安装成功，输入 <code>exit()</code> 退出。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/07.png" width="666"/></div></li></ul><h1>二、Python 之禅（Zen of Python）</h1><ul><li><p><code>Python</code> 之禅最早由 <code>Tim Peters</code> 在 <code>Python</code> 邮件列表中发表，它包含了影响 <code>Python</code> 编程语言设计的 <code>19</code> 条软件编写原则。</p></li><li><p>执行 <code>import this</code> 会输出一段文字。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/08.png" width="666"/></div><ul><li><code>import</code> 是一个关键字，用来导入模块、包或库，导入后可以使用 <code>.</code> 访问模块、包或库中相应的成员。<ul><li>一个 <code>python</code> 文件就是一个模块，在导入模块时，只需要导入模块名（文件名）即可。</li><li>包本质上就是一个文件夹，可以存放模块、子包或其他文件，便于文件管理、分区，避免模块名冲突。</li><li>库一定是包，但是包不一定是库，可以理解为一种特殊的包，即一种功能相对集中的包。</li></ul></li></ul></li><li><p><code>Python</code> 之禅列出了 <code>Python</code> 设计的原则与哲学，有助于理解与使用这种语言。</p><ul><li><p>优美优于丑陋（<code>Python</code> 以编写优美的代码为目标）</p></li><li><p>明了优于晦涩（优美的代码应当是明了的，命名规范，风格相似）</p></li><li><p>简洁优于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</p></li><li><p>复杂优于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</p></li><li><p>扁平优于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</p></li><li><p>稀疏优于稠密（优美的代码有适当的间隔，不要奢望一行代码解决问题）</p></li><li><p>可读性很重要（优美的代码是可读的）</p></li><li><p>即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</p></li><li><p>不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写<br><code>except:pass</code> 风格的代码）</p></li><li><p>面对不确定性，拒绝妄加猜测。</p></li><li><p>任何问题应有一种，且最好只有一种，显而易见的解决方法。</p></li><li><p>尽管这并不容易，除非你是荷兰人（这里的荷兰人 <code>Dutch</code> 是指 <code>Python</code> 之父 <code>Guido van Rossum</code>，生于荷兰哈勒姆）。</p></li><li><p>做优于不做，然而不假思索就做还不如不做。</p></li><li><p>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</p></li><li><p>命名空间是个绝妙的理念，我们应该好好利用它。</p></li></ul></li></ul><h1>三、行结构、缩进、注释</h1><h2 id="3-1-行结构">3.1 行结构</h2><ul><li><p><code>python</code> 程序中每条语句都以默认换行符结束，无需书写分号 <code>;</code>，例：<code>print(&quot;1234&quot;)</code>。</p></li><li><p>存在可以跨越多行的语句，例：复合语句（函数、序列、条件语句、循环语句等）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;行者&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> :<span class="string">&#x27;武松&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;num&#x27;</span> : <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果要在同一行上放置多条语句，可使用分号 <code>;</code> 隔开。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">123</span>); <span class="built_in">print</span>(<span class="number">456</span>); <span class="built_in">print</span>(<span class="number">789</span>) <span class="comment"># 输出格式如下</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 456</span></span><br><span class="line"><span class="comment"># 789</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用续行符（<code>\</code>）将长语句分为几行。</p><ul><li><p>显示的行拼接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span> \</span><br><span class="line">       + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span> \</span><br><span class="line">       + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>隐式的行拼接：<strong>圆括号</strong> <code>()</code>、<strong>方括号</strong> <code>[]</code> 和 <strong>花括号</strong> <code>&#123;&#125;</code> 内部的多行语句，无需使用续行符（<code>\</code>），可以自动实现行拼接。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, </span><br><span class="line">           <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span></span><br><span class="line">           <span class="string">&quot;eleven&quot;</span>, <span class="string">&quot;twelve&quot;</span>, <span class="string">&quot;thirteen&quot;</span>, <span class="string">&quot;fourteen&quot;</span>, <span class="string">&quot;fifteen&quot;</span>,</span><br><span class="line">           <span class="string">&quot;sixteen&quot;</span>, <span class="string">&quot;seventeen&quot;</span>, <span class="string">&quot;eighteen&quot;</span>, <span class="string">&quot;nineteen&quot;</span>, <span class="string">&quot;twenty&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(numbers) <span class="comment"># [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;teneleven&#x27;, &#x27;twelve&#x27;, &#x27;thirteen&#x27;, &#x27;fourteen&#x27;, &#x27;fifteen&#x27;, &#x27;sixteen&#x27;, &#x27;seventeen&#x27;, &#x27;eighteen&#x27;, &#x27;nineteen&#x27;, &#x27;twenty&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-2-缩进">3.2 缩进</h2><ul><li><p>每条语句开头处的空白被用来计算该行的缩进等级，以决定语句段落的组织结构。</p></li><li><p>不正确的缩进会导致程序的逻辑不对，甚至报错。</p></li><li><p>缩进常用于标示不同的代码块，如：函数体、条件语句、循环语句和类等。</p></li><li><p>每条语句的缩进量是任意的（常用 <code>4</code> 个空格，即单个 <code>Tab</code> 键），但是同一个代码块中的缩进量必须保持一致。</p></li></ul><h2 id="3-3-python-注释">3.3 Python 注释</h2><ul><li><p>注释在 <code>Python</code> 解释器的语法分析中会被忽略，即在程序运行过程中会被忽略，对程序不产生影响。</p></li><li><p>作用：</p><ul><li><p>对代码进行解释和说明，提高程序的可读性。</p></li><li><p>暂时注释掉某一段代码，不执行。</p></li></ul></li><li><p><code>Python</code> 中的注释有 <strong>单行注释</strong> 和 <strong>多行注释</strong>。</p><ul><li><p><code>Python</code> 中单行注释以 <code>#</code> 开头，<code>PyCharm</code> 快捷键 <code>Ctrl + /</code>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是单行注释</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释用三个单引号 <code>'''</code> 或者三个双引号 <code>&quot;&quot;&quot;</code> 将注释括起来，常用于代码块注释。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>四、静\动态、强\弱类型语言</h1>  <div align=center>    <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/09.png" width="399"/>  </div><h2 id="4-1-静-动态类型语言">4.1 静、动态类型语言</h2><ul><li><p><strong>静态类型</strong> 的编程语言指的是在创建一份数据（变量、参数、返回值等）时需要 <strong>显式</strong> 指明该数据的类型。通常情况下，这些数据的类型一旦被定义，在程序的整个生命周期也不再改变。</p><ul><li>静态类型的编程语言有很多，常见的有 <code>C/C++</code>、<code>Java</code>、<code>C#</code>、<code>Go</code> 等。</li></ul></li><li><p><strong>动态类型</strong> 的编程语言在创建数据时往往不需要指明该数据的类型，而且数据的类型也会 <strong>随着值的改变而改变</strong>，给数据赋予不同的值，数据将得到不同的类型。</p><ul><li><p>动态类型的编程语言会根据赋予数据的值进行猜测或者推断该数据的类型。</p></li><li><p>常见的动态类型语言有 <code>JavaScript</code>、<code>PHP</code>、<code>Python</code>、<code>Ruby</code> 等。</p></li></ul></li><li><p>一般而言，在 <strong>编译期</strong> 就确定变量类型的是 <strong>静态类型语言</strong>，在 <strong>运行期</strong> 才确定变量类型的则是 <strong>动态类型语言</strong>。</p></li><li><p><strong>静态语言</strong> 为我们提供了一个更加严格的编程环境，并且通常会生成更加健壮的代码。<strong>动态语言</strong> 为编写代码带来了灵活性，同时也提高了编写代码的效率，但是如果你不注意数据的类型，可能就会导致代码更容易出错。</p></li></ul><h2 id="4-2-强-弱类型语言">4.2 强、弱类型语言</h2><ul><li><p><strong>强</strong>、<strong>弱类型指的是编程语言如何处理运算过程中的值</strong>。当值的类型 <strong>不符合运算规则</strong> 时，编程语言究竟是做出一些猜测，临时转换值的类型以帮助人们解决问题，还是停止运行，提醒人们不应该这样做。</p></li><li><p>对于 “强弱类型” 概念，它的核心问题是 “<strong>不同类型的变量是否允许隐式转化</strong>”。</p></li><li><p><strong>强类型语言</strong> 的典型特征：它们不会处理与数据类型定义明显矛盾的运算，而是把它标记为一个语法错误，并且停止程序运行，将错误抛出。</p><ul><li>通常人们认为 <code>Java</code>、<code>C#</code>、<code>Python</code>、<code>Go</code> 都是强类型语言。</li></ul></li><li><p>和强类型语言不一样，当我们执行一些与类型定义不匹配的运算时，<strong>弱类型语言</strong> 尝试提供帮助，它可能会对其中一些值的类型进行转换，让它符合当前运算。</p></li></ul><h1>五、Python 变量与常量</h1><h2 id="5-1-python-变量的定义">5.1 Python 变量的定义</h2><ul><li><p>变量就是可以变化的量。</p></li><li><p>变量需要 <strong>先定义再使用</strong>，解释器执行到变量定义的代码时会申请 <strong>内存空间</strong> 存放 <strong>变量值</strong>，然后将变量值的 <strong>内存地址</strong> 绑定给 <strong>变量名</strong>。</p></li><li><p>变量名是存储数据的一块内存地址的 <strong>别名</strong>。</p><ul><li>变量 <strong>存储</strong> 的只是一个变量的值所在的 <strong>内存地址</strong>，而不是这个变量的 <strong>值本身</strong>。</li></ul></li><li><p>每个变量都拥有 <strong>独一无二</strong> 的名字，通过变量的名字就能找到变量中的数据。</p></li><li><p>变量存储的数据是 <strong>临时</strong> 的。</p></li></ul><h2 id="5-2-python-变量的赋值">5.2 Python 变量的赋值</h2><ul><li><p>将数据放入变量的过程就叫做 <strong>赋值</strong>。</p><ul><li><p><code>Python</code> 使用等号 <code>=</code> 作为赋值运算符，用来将变量值的内存地址绑定给变量名，格式：<code>name = value</code>。</p><ul><li>其中 <code>name</code> 表示变量名，<code>value</code> 表示变量值，也就是内存地址对应存储的数据。</li></ul></li></ul></li><li><p>变量的值可以随时被修改，只要重新赋值即可，可以将不同类型的数据赋值给同一个变量。</p></li><li><p><strong>变量名要遵守</strong> <code>Python</code> <strong>标识符命名规范</strong>，<strong>还要避免和</strong> <code>Python</code> <strong>内置函数及</strong> <code>Python</code> <strong>保留字重名</strong>。</p></li><li><p><strong>标识符</strong> 主要作用是作为变量、函数、类、模块及其他对象的名称，<code>Python</code> 标识符命名规范：</p><ul><li><p>标识符是由字母（<code>A ~ Z</code> 和 <code>a ~ z</code>）、数字和下划线（<code>_</code>）组成。</p></li><li><p>标识符第一个字符不能是数字。</p></li><li><p>标识符不能与 <code>Python</code> 中的 <strong>保留字</strong>（报错）和 <strong>内置函数名</strong>（不报错）相同。</p></li><li><p>标识符严格区分大小写。</p></li><li><p>以下划线开头的标识符通常有特殊含义，例：</p><ul><li><p>以 <strong>单下划线开头</strong> 的标识符（例：<code>_width</code>）表示不能直接访问的 <strong>类属性</strong>，其无法通过 <code>from ... import *</code> 的方式导入。</p></li><li><p>以 <strong>双下划线开头</strong> 的标识符（例：<code>__add</code>）表示 <strong>类的私有成员</strong>。</p></li><li><p>以 <strong>双下划线开头和结尾</strong> 的标识符（例：<code>__init__</code>），是 <strong>专用标识符</strong>。</p></li></ul></li></ul></li><li><p><code>Python</code> 变量的 <strong>命名习惯</strong>：</p><ul><li><p><code>Python</code> 变量命名一定要做到 <strong>见名知义</strong>。</p></li><li><p>当标识符用作 <strong>模块名</strong> 或 <strong>包名</strong> 时，应全部使用小写字母，尽量不使用下划线。</p></li><li><p>当标识符用作 <strong>类名</strong> 时，应采用单词首字母大写的形式（<strong>大驼峰</strong>）。</p></li><li><p>当标识符用作 <strong>函数名</strong> 或 <strong>变量名</strong> 时，应全部使用小写字母，多个单词之间使用下划线分割。</p><ul><li>也可采用第一个单词首字母小写，其余单词首字母大写的形式（<strong>小驼峰</strong>）。</li></ul></li><li><p>当标识符用作 <strong>常量</strong> 时，应全部使用大写字母，多个单词之间使用下划线分割。</p></li></ul></li></ul><h2 id="5-3-引用计数">5.3 引用计数</h2><ul><li><p>在一些代码中，如果存在一些变量但是没有用，会造成内存空间，因此叫做垃圾，所以要回收。</p></li><li><p>引用计数是一种最直观，最简单的垃圾收集技术。原理非常简单，每一个对象都包含了两个头部信息，一个是 <strong>类型标志符</strong>，标识这个对象的类型；另一个是 <strong>计数器</strong>，记录当前指向该对象的引用数目，表示这个对象被多少个变量名所引用。</p></li><li><p><code>CPython</code> 使用引用计数来管理内存，所有 <code>Python</code> 脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有 <code>0</code> 时，则会自动释放内存。</p></li><li><p>引用计数是用来记录对象被引用的次数，每当对象被创建或者被引用时将该对象的引用次数加一，当对象的引用被销毁时该对象的引用次数减一，当对象的引用次数减到零时说明程序中已经没有任何对象持有该对象的引用，换言之就是在以后的程序运行中不会再次使用到该对象了，那么其所占用的空间也就可以被释放了了。</p><ul><li><p>引用计数 <strong>增加</strong> 的场景：</p><ul><li><p>对象被创建并赋值给某个变量，例：<code>a = 'ABC'</code>。</p></li><li><p>变量间的相互引用（相当于变量指向了同一个对象），例：<code>b=a</code>。</p></li><li><p>变量作为参数传到函数中。例：<code>ref_method(a)</code>。</p></li><li><p>将对象放到某个容器对象中（列表、元组、字典）。比如：<code>c = [1, a, 'abc']</code>。</p></li></ul></li><li><p>引用计数 <strong>减少</strong> 的场景：</p><ul><li><p>当一个变量离开了作用域，例：函数执行完成时，执行函数前后的引用计数保持不变，这就是因为函数执行完后，对象的引用计数也会减少，如果在函数内打印，则能看到引用计数增加的效果。</p></li><li><p>对象的引用变量被销毁时，例：<code>del a</code> 或 <code>del b</code>。注：如果 <code>del a</code>，再去获取 <code>a</code> 的引用计数会直接报错。</p></li><li><p>对象被从容器对象中移除，例：<code>c.remove(a)</code>。</p></li><li><p>直接将整个容器销毁，例：<code>del c</code></p></li><li><p>对象的引用被赋值给其他对象，相当于变量不指向之前的对象，而是指向了一个新的对象。</p></li></ul></li></ul></li></ul><h2 id="5-4-python-常量">5.4 Python 常量</h2><ul><li><p>变量是变化的量，常量则是不变的量。</p></li><li><p><code>Python</code> 中没有使用语法强制定义常量，也就是说，<code>Python</code> 中定义常量 <strong>本质上</strong> 就是 <strong>变量</strong>。</p></li><li><p>如果非要定义常量，<strong>变量名</strong> 必须 <strong>全大写</strong>。并且 <code>Python</code> 只制定了一个规范，即常量的值 <strong>不应该</strong> 被更改，但 <strong>不是不可以</strong> 更改，而没指定常量的语法，因此常量也是可以修改的，但不建议。</p></li></ul><h1>六、Python 保留字和内置函数</h1><h2 id="6-1-python-保留字">6.1 Python 保留字</h2><ul><li><p><strong>保留字</strong>（关键字）是 <code>Python</code> 语言中一些已经被官方赋予特定意义的单词，所以不能使用这些保留字作为标识符给变量、函数、类、模块及其他对象命名。</p><ul><li><p>可以在 <code>keyword</code> 模块，即 <code>keyword.py</code> 文件中查询到保留字。</p><ul><li><p>可以通过 <code>print(keyword.kwlist)</code> 打印保留字列表，需要导入 <code>keyword</code> 模块（<code>import keyword</code>）。演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist) <span class="comment"># [&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]</span></span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/10.png" width="666"/></div></li><li><p>可以直接通过 <code>help(&quot;keywords&quot;)</code> 打印保留字列表，无需导入 <code>keyword</code> 模块。演示：</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/11.png" width="666"/></div><ul><li>内置函数 <code>help()</code> 中实现了 <code>print</code> 函数，已经具备打印功能，如果 <code>print(help(&quot;keywords&quot;))</code> 会打印 <code>None</code>，因为 <code>help()</code> 函数没有返回值。</li></ul></li></ul></li><li><p><code>Python</code> 中一共有 <code>35</code> 个保留字，如下表所示：</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/12.png" width="520"/></div><ul><li>注：<code>Python</code> 严格区分大小写，保留字也不例外。所以，<code>False</code> 是保留字，但 <code>false</code> 不是保留字。</li></ul></li></ul></li></ul><h2 id="6-2-python-内置函数">6.2 Python 内置函数</h2><ul><li><p><strong>内置函数</strong> 是 <code>Python</code> 解释器自带的函数，这些函数由官方在 <code>builtins</code> 模块中定义，可以被直接使用，不需要导入某个模块。只需了解函数的功能，学会使用即可，无需了解函数具体实现。</p><ul><li><p><code>python</code> 中所有内置函数都被定义在 <code>builtins</code> 模块中。可以通过下面代码查看 <code>Python</code> 的内置函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(builtins))</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Python/01/13.png" width="666"/></div><ul><li><p><code>dir()</code> 函数不带参数时，返回 <code>dir</code> 所在作用域内所有 <strong>属性</strong> 和 <strong>方法名</strong> 组成的 <strong>已排序</strong> 的字符串列表。返回的列表按字母表排序（按照 <code>ASCII</code> 码）</p></li><li><p><code>dir(object)</code> 函数带参数 <code>object</code> 时，返回给定 <code>object</code> 自身所具备的 <strong>属性</strong> 和 <strong>方法名</strong> 组成的已排序的字符串列表。返回的列表按字母表排序（按照 <code>ASCII</code> 码）</p><ul><li>如果给定的 <code>object</code> 中包含 <code>__dir__()</code> 方法，该方法将被调用。</li></ul></li><li><p><code>builtins</code> 模块中使用 <code>def</code> 定义的为 <strong>函数</strong>，使用 <code>class</code> 定义的是一种 <strong>内置类型</strong>。</p></li><li><p>不要使用内置函数作为标识符，虽然这样做 <code>Python</code> 解释器不会报错，但这会导致同名的内置函数被覆盖，从而无法使用。</p></li><li><p><code>builtins</code> 模块中不仅内置了函数，还内置了类型。</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3</title>
      <link href="/posts/python/python3/02.html"/>
      <url>/posts/python/python3/02.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="01.html">01.python3 入门</a></li><li><a href="02.html">02.python3 基本数据类型</a></li><li><a href="03.html">03.python3 序列（列表、元组）</a></li><li><a href="04.html">04.python3 序列（字符串）</a></li><li><a href="05.html">05 python3 字典和集合</a></li><li><a href="06.html">06.python3 浅拷贝和深拷贝</a></li><li><a href="07.html">07.python3 流程控制</a></li><li><a href="08.html">08.python3 迭代问题</a></li><li><a href="09.html">09.python3 推导式 &amp; random模块</a></li><li><a href="10.html">10.Python3 函数（上）</a></li><li><a href="11.html">11.Python3 函数（下）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly 主题自带美化效果</title>
      <link href="/posts/hexo/butterfly/06.html"/>
      <url>/posts/hexo/butterfly/06.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Beautify/Effect (美化/效果)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br></pre></td></tr></table></figure><h1>一、主题配色</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Theme color for customize</span></span><br><span class="line"><span class="comment"># Notice: color value must in double quotes like &quot;#000&quot; or may cause error!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># theme_color:</span></span><br><span class="line"><span class="comment">#   enable: true</span></span><br><span class="line"><span class="comment">#   main: &quot;#49B1F5&quot;</span></span><br><span class="line"><span class="comment">#   paginator: &quot;#00c4b6&quot;</span></span><br><span class="line"><span class="comment">#   button_hover: &quot;#FF7242&quot;</span></span><br><span class="line"><span class="comment">#   text_selection: &quot;#00c4b6&quot;</span></span><br><span class="line"><span class="comment">#   link_color: &quot;#99a9bf&quot;</span></span><br><span class="line"><span class="comment">#   meta_color: &quot;#858585&quot;</span></span><br><span class="line"><span class="comment">#   hr_color: &quot;#A4D8FA&quot;</span></span><br><span class="line"><span class="comment">#   code_foreground: &quot;#F47466&quot;</span></span><br><span class="line"><span class="comment">#   code_background: &quot;rgba(27, 31, 35, .05)&quot;</span></span><br><span class="line"><span class="comment">#   toc_color: &quot;#00c4b6&quot;</span></span><br><span class="line"><span class="comment">#   blockquote_padding_color: &quot;#49b1f5&quot;</span></span><br><span class="line"><span class="comment">#   blockquote_background_color: &quot;#49b1f5&quot;</span></span><br><span class="line"><span class="comment">#   scrollbar_color: &quot;#49b1f5&quot;</span></span><br><span class="line"><span class="comment">#   meta_theme_color_light: &quot;ffffff&quot;</span></span><br><span class="line"><span class="comment">#   meta_theme_color_dark: &quot;#0d0d0d&quot;</span></span><br></pre></td></tr></table></figure><h1>二、Category 和 Tag 页的 UI 设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The user interface setting of category and tag page (category和tag頁的UI設置)</span></span><br><span class="line"><span class="comment"># index - same as Homepage UI (index 值代表 UI將與首頁的UI一樣)</span></span><br><span class="line"><span class="comment"># default - same as archives UI 默認跟archives頁面UI一樣</span></span><br><span class="line"><span class="attr">category_ui:</span> <span class="comment"># 留空或 index</span></span><br><span class="line"><span class="attr">tag_ui:</span> <span class="comment"># 留空或 index</span></span><br></pre></td></tr></table></figure><h1>三、文字左右对齐</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stretches the lines so that each line has equal width</span></span><br><span class="line"><span class="comment"># 可设置文字向两侧对齐，对最后一行无效</span></span><br><span class="line"><span class="attr">text_align_justify:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1>四、黑色半透遮罩</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add mask to header or footer (为 header 或 footer 添加黑色半透遮罩)</span></span><br><span class="line"><span class="attr">mask:</span></span><br><span class="line">  <span class="attr">header:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1>五、加载动画</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loading Animation (加載動畫)</span></span><br><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># source</span></span><br><span class="line">  <span class="comment"># 1. fullpage-loading 整页加载</span></span><br><span class="line">  <span class="comment"># 2. pace (progress bar) 进度条</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># pace theme (see https://codebyzach.github.io/pace/)</span></span><br><span class="line">  <span class="attr">pace_css_url:</span></span><br></pre></td></tr></table></figure><ul><li><p>将 <a href="https://codebyzach.github.io/pace/">https://codebyzach.github.io/pace/</a> 中选定的主题下载到 <code>\themes\butterfly\source\css</code>。</p></li><li><p><code>pace_css_url</code> 填写 <code>css</code> 文件在渲染后 <code>public</code> 中的地址 <code>/css/center-atom.css</code>。</p></li></ul><h1>六、欢迎页面</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Page Transition</span></span><br><span class="line"><span class="attr">enter_transitions:</span> <span class="literal">true</span><span class="comment"># 是否开启欢迎页面</span></span><br></pre></td></tr></table></figure><h1>七、显示模式</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default display mode (網站默認的顯示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><h1>八、页面美化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Configuration for beautifying the content of the article</span></span><br><span class="line">beautify:</span><br><span class="line">  enable: false</span><br><span class="line">  <span class="comment"># Specify the field to beautify (site or post)</span></span><br><span class="line">  field: post<span class="comment"># field 配置生效的区域：post 只在文章页生效、site 在全站生效</span></span><br><span class="line">  <span class="comment"># Specify the icon to be used as a prefix for the title, such as &#x27;\f0c1&#x27;</span></span><br><span class="line">  title_prefix_icon:<span class="comment"># 标题前缀的 icon</span></span><br><span class="line">  <span class="comment"># Specify the color of the title prefix icon, such as &#x27;#F47466&#x27;</span></span><br><span class="line">  title_prefix_icon_color:<span class="comment"># 标题前缀的 icon 的颜色</span></span><br></pre></td></tr></table></figure><h1>九、全站字体</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span><span class="comment"># 全站字体大小</span></span><br><span class="line">  <span class="attr">code-font-size:</span><span class="comment"># 代码字体大小</span></span><br><span class="line">  <span class="attr">font-family:</span><span class="comment"># 全局字体</span></span><br><span class="line">  <span class="attr">code-font-family:</span><span class="comment"># 代码字体</span></span><br></pre></td></tr></table></figure><h1>十、站名字体</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Font settings for the site title and site subtitle</span></span><br><span class="line"><span class="comment"># 左上角網站名字和主頁居中網站名字</span></span><br><span class="line"><span class="attr">blog_title_font:</span></span><br><span class="line">  <span class="attr">font_link:</span></span><br><span class="line">  <span class="attr">font-family:</span></span><br></pre></td></tr></table></figure><h1>十一、水平分隔线图标</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The setting of divider icon (水平分隔線圖標設置)</span></span><br><span class="line"><span class="attr">hr_icon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span></span><br><span class="line">  <span class="attr">icon-top:</span> <span class="comment"># -20px：图标位于分割线上方；-10px：图标位于分割线中间；-0px：图标位于分割线下方</span></span><br></pre></td></tr></table></figure><ul><li>可以在 <a href="https://fontawesome.com/search">Font Awesome</a> 官网查询 <code>unicode</code>。</li></ul><h1>十二、打字效果</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line"><span class="comment"># https://github.com/disjukr/activate-power-mode</span></span><br><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖動特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示效果</span></span><br></pre></td></tr></table></figure><h1>十三、网站背景特效</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Background effects (背景特效)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_ribbon (靜止彩帶背景)</span></span><br><span class="line"><span class="comment"># See: https://github.com/hustcc/ribbon.js</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">false</span> <span class="comment"># 是否在点击时变换彩带</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示彩带</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fluttering Ribbon (動態彩帶)</span></span><br><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示彩带</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_nest</span></span><br><span class="line"><span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(<span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5. 线条不透明度</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines, default: 99.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示线条</span></span><br></pre></td></tr></table></figure><h1>十四、鼠标点击特效</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mouse click effects: fireworks (鼠標點擊效果: 煙火特效)</span></span><br><span class="line"><span class="attr">fireworks:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">9999</span> <span class="comment"># -1 or 9999，-1 代表烟火效果在底部，9999 代表烟火效果在前面</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示特效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mouse click effects: Heart symbol (鼠標點擊效果: 愛心)</span></span><br><span class="line"><span class="attr">click_heart:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示特效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mouse click effects: words (鼠標點擊效果: 文字)</span></span><br><span class="line"><span class="attr">clickShowText:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">text:</span> <span class="comment"># 文字可以自定义</span></span><br><span class="line">    <span class="comment"># - I</span></span><br><span class="line">    <span class="comment"># - LOVE</span></span><br><span class="line">    <span class="comment"># - YOU</span></span><br><span class="line">  <span class="attr">fontSize:</span> <span class="string">15px</span> <span class="comment"># 文字大小</span></span><br><span class="line">  <span class="attr">random:</span> <span class="literal">false</span> <span class="comment"># 是否随机出现 text 文字</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># 是否在移动设备上显示特效</span></span><br></pre></td></tr></table></figure><h1>十五、大图查看模式</h1><ul><li><p><code>medium-zoom</code> 或 <code>fancybox</code> 只能开启一个，推荐 <code>fancybox</code>。不需要大图查看模式时，请留空。</p></li><li><p>如果不想为某张图片添加大图查看模式，可以在 <code>img</code> 标签中添加 <code>class</code> 属性，值为 <code>no-lightbox</code>。例：<code>&lt;img src=&quot;xxxx.jpg&quot; class=&quot;no-lightbox&quot;&gt;</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Lightbox Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose: fancybox / medium_zoom</span></span><br><span class="line"><span class="comment"># https://github.com/francoischalifour/medium-zoom</span></span><br><span class="line"><span class="comment"># https://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="comment"># Leave it empty if you don&#x27;t need lightbox</span></span><br><span class="line"><span class="attr">lightbox:</span></span><br></pre></td></tr></table></figure></li></ul><ol class="series-items"><li><a href="/posts/hexo/butterfly/01" title="Hexo 框架 + Butterfly 主题打造个人博客">Hexo 框架 + Butterfly 主题打造个人博客</a></li><li><a href="/posts/hexo/butterfly/02" title="Hexo 框架全局配置文件">Hexo 框架全局配置文件</a></li><li><a href="/posts/hexo/butterfly/03" title="Butterfly 主题配置文件（一）">Butterfly 主题配置文件（一）</a></li><li><a href="/posts/hexo/butterfly/04" title="Butterfly 主题配置文件（二）">Butterfly 主题配置文件（二）</a></li><li><a href="/posts/hexo/butterfly/05" title="Butterfly 主题配置文件（三）">Butterfly 主题配置文件（三）</a></li><li><a href="/posts/hexo/butterfly/06" title="Butterfly 主题自带美化效果">Butterfly 主题自带美化效果</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly 主题配置文件（三）</title>
      <link href="/posts/hexo/butterfly/05.html"/>
      <url>/posts/hexo/butterfly/05.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、数学</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Math</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># About the per_page</span></span><br><span class="line"><span class="comment"># if you set it to true, it will load mathjax/katex script in each page</span></span><br><span class="line"><span class="comment"># if you set it to false, it will load mathjax/katex script according to your setting (add the &#x27;mathjax: true&#x27; or &#x27;katex: true&#x27; in page&#x27;s front-matter)</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Choose: mathjax, katex</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need math</span></span><br><span class="line">  <span class="attr">use:</span> <span class="comment"># 选择数学公式渲染引擎，选择 mathjax 或 katex，如果不需要数学公式，请留空</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span> <span class="comment"># 是否每一页都加载数学公式渲染引擎，如果设置为 false，则需要在文章的 Front-matter 添加</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">false</span> <span class="comment"># 是否隐藏滚动条</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span> <span class="comment"># 开启 Mathjax 需要把 use 设置为 mathjax</span></span><br><span class="line">    <span class="comment"># Enable the contextual menu</span></span><br><span class="line">    <span class="attr">enableMenu:</span> <span class="literal">true</span> <span class="comment"># 启用右键菜单</span></span><br><span class="line">    <span class="comment"># Choose: all / ams / none, This controls whether equations are numbered and how</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span> <span class="comment"># 选择是否编号，all 全部编号，ams 只编号公式，none 不编号</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="comment"># Enable the copy KaTeX formula</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="1-1-mathjax">1.1 mathjax</h2><h3 id="1-1-1-配置-mathjax">1.1.1 配置 mathjax</h3><ul><li><p>不要在标题里使用 <code>mathjax</code> 语法，<code>toc</code> 目录不一定能正确显示 <code>mathjax</code>，可能显示 <code>mathjax</code> 代码</p></li><li><p>使用 <code>mathjax</code> 前，需要卸载 <code>hexo</code> 的 <code>markdown</code> 渲染器，然后安装 <code>hexo-renderer-kramed</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-renderer-marked</span> <span class="string">--save</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-kramed</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure></li><li><p>配置全局配置文件 <code>_config.yml</code>，在末尾中添加如下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-renderer-kramed</span></span><br><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-2-解决-hexo-renderer-kramed-不能渲染-todo-list">1.1.2 解决 hexo-renderer-kramed 不能渲染 Todo List</h3><ul><li><p>将下列内容插入到项目文件夹中 <code>node_modules/hexo-renderer-kramed/lib/renderer.js</code> 文件的第 <code>20</code> 行中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support To-Do List</span></span><br><span class="line"><span class="title class_">Renderer</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">listitem</span> = <span class="keyword">function</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^\s*\[[x ]\]\s*/</span>.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">    text = text.<span class="title function_">replace</span>(<span class="regexp">/^\s*\[ \]\s*/</span>, <span class="string">&#x27;&lt;input type=&quot;checkbox&quot;&gt;&lt;/input&gt; &#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^\s*\[x\]\s*/</span>, <span class="string">&#x27;&lt;input type=&quot;checkbox&quot; checked&gt;&lt;/input&gt; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;li style=&quot;list-style: none&quot;&gt;&#x27;</span> + text + <span class="string">&#x27;&lt;/li&gt;\n&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;li&gt;&#x27;</span> + text + <span class="string">&#x27;&lt;/li&gt;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-3-解决-hexo-renderer-kramed-渲染-mathjax-时与-markdown-语法冲突">1.1.3 解决 hexo-renderer-kramed 渲染 MathJax 时与 Markdown 语法冲突</h3><p>（1） 下划线 <code>_</code> 被转义为 <code>Markdown</code> 斜体而非 <code>LaTeX</code> 下标</p><ul><li><p>问题描述：当公式中出现多个下划线时，会被 <code>kramed</code> 渲染为 <code>Markdown</code> 斜体，导致公式显示异常。</p></li><li><p><code>Markdown</code> 本身的语法是支持 <code>*</code> 和 <code>_</code> 都被转义为斜体的，所以我们可以取消掉 <code>kramed</code> 对 <code>_</code> 的转义。打开项目文件夹下的 <code>/node_modules/kramed/lib/rules/inline.js</code> 文件，找到第 <code>20</code> 行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure></li><li><p><code>Markdown</code> 使用斜体的话只用 <code>*</code> 符号即可。如果 <code>LaTeX</code> 要使用大量 <code>*</code> 符号，可用 <code>\ast</code> 代替。</p></li></ul><p>（2）反斜杠 <code>\\</code> 被转义为 <code>\</code> 而非 <code>LaTeX</code> 换行</p><ul><li><p>打开项目文件夹下的 <code>/node_modules/kramed/lib/rules/inline.js</code> 文件，找到第 <code>11</code> 行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([\\`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure></li></ul><p>（3）反斜杠加感叹号 <code>\!</code> 被转义为 <code>!</code>而非紧贴符</p><ul><li>同上，把第 <code>11</code> 行代码 <code>escape:</code> 后的正则表达式中的 <code>!</code> 去掉即可。</li></ul><p>（4）反斜杠加竖线 <code>\|</code> 被转义为 <code>|</code> 而非 <code>LaTeX</code> 双竖线</p><ul><li><p>打开项目文件夹下的 <code>/node_modules/kramed/lib/rules/inline.js</code> 文件，找到第 <code>64</code> 行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="title function_">replace</span>(inline.<span class="property">escape</span>)(<span class="string">&#x27;])&#x27;</span>, <span class="string">&#x27;~|])&#x27;</span>)(),</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="title function_">replace</span>(inline.<span class="property">escape</span>)(<span class="string">&#x27;])&#x27;</span>, <span class="string">&#x27;~])&#x27;</span>)(),</span><br></pre></td></tr></table></figure></li></ul><p>（5）行内公式与行内代码冲突</p><ul><li><p>行内公式：公式与公式前的文字处于同一行。行内公式统一使用 <code>$...$</code> 来表达。</p></li><li><p>行间公式：公式与公式前的文字换行，然后公式单独成行并居中显示。</p></li><li><p>行内代码：在同一行文字内容中间使用一对反引号（``）包围代码。</p></li><li><p>问题描述：把行内公式</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`$ a+b $`</span></span><br></pre></td></tr></table></figure><p>作为行内代码输入时，会显示异常。</p><p>显示如：<code>$ a+b $</code>，即行内公式被渲染，$ 符号不被保留。</p></li><li><p>解决方案：要在行内代码中输入行内公式，在 $ 符号前后加上空格即可：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">` $ a+b $ `</span></span><br></pre></td></tr></table></figure><p>显示如：<code>$ a+b $</code></p></li></ul><h2 id="1-2-katex">1.2 katex</h2><ul><li><p>使用 <code>katex</code> 前，需要卸载 <code>hexo</code> 的 <code>markdown</code> 渲染器，然后安装 <code>hexo-renderer-markdown-it</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-renderer-marked</span> <span class="string">--save</span></span><br><span class="line"><span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-renderer-kramed</span> <span class="string">--save</span> <span class="comment"># 如果有安装这个插件的话，需要卸载</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-markdown-it-katex</span></span><br></pre></td></tr></table></figure></li><li><p>配置全局配置文件 <code>_config.yml</code>，在末尾中添加如下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h1>二、搜索</h1><ul><li><p><code>butterfly</code> 主題支持三种搜索方式（<code>algolia_search</code> / <code>local_search</code> / <code>docsearch</code>），本站使用 <code>Algolia</code> 搜索。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="comment"># Choose: algolia_search / local_search / docsearch</span></span><br><span class="line">  <span class="comment"># leave it empty if you don&#x27;t need search</span></span><br><span class="line">  <span class="attr">use:</span> <span class="comment"># 选择你需要的搜索方式，不需要开启则保留空白</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="comment"># 搜索框的提示文字</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-1-algolia-搜索">2.1 Algolia 搜索</h2><h3 id="2-1-1-注册账号">2.1.1 注册账号</h3><ul><li><p><a href="https://www.algolia.com/">Algolia官网</a>（ <a href="https://www.algolia.com/">https://www.algolia.com/</a> ）</p></li><li><p>在项目根目录执行以下代码下载第三方包：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-algoliasearch</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure></li><li><p>在 Algolia <a href="https://dashboard.algolia.com/users/sign_up">注册页面</a> 使用 <code>Google</code> 账号、<code>Github</code> 账号或邮箱直接进行注册。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/01.png" width=500/></div></li><li><p>登录后进入控制台，按以下步骤创建 <code>index</code>，自定义 <code>indexName</code>。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/02.png" width=888/></div></li><li><p>在控制台进入设置页面，点击 <code>API Keys</code> 获取 <code>Application ID</code>、<code>Search API Key</code>、<code>Admin API Key</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/03.png" width=888/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/04.png" width=888/></div></li><li><p>在 <code>_config.yml</code> 全局配置文件末尾加入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">&quot;your applicationID&quot;</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">&quot;your Search-Only API Key&quot;</span></span><br><span class="line">  <span class="attr">adminApiKey:</span> <span class="string">&quot;your Admin API Key&quot;</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">&quot;your indexName&quot;</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">content:strip:truncate,0,500</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">excerpt:strip</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gallery</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">permalink</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">photos</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">slug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">title</span></span><br></pre></td></tr></table></figure><ul><li><p><code>content:strip:truncate,0,500</code></p><ul><li><p><code>content</code>：文章的内容。</p></li><li><p><code>strip</code>：去掉 <code>HTML</code> 标签和样式。</p></li><li><p><code>truncate,0,500</code>：截取内容的前 <code>500</code> 个字符。</p></li></ul></li><li><p><code>excerpt:strip</code></p><ul><li><p><code>excerpt</code>：文章的摘要。</p></li><li><p><code>strip</code>：去掉 <code>HTML</code> 标签和样式。</p></li></ul></li><li><p><code>gallery</code>：文章的图片集字段，不做处理直接索引。</p></li><li><p><code>permalink</code>：文章的永久链接，不做处理直接索引。</p></li><li><p><code>slug</code>：文章的短链接，不做处理直接索引。</p></li><li><p><code>title</code>：文章的标题，不做处理直接索引。</p></li></ul></li><li><p>把主题配置文件 <code>_config.butterfly.yml</code> 中 <code>search</code> 的 <code>use</code> 设置为 <code>algolia_search</code>。</p></li></ul><h2 id="2-2-本地搜索">2.2 本地搜索</h2><ul><li><p>安装依赖：<code>npm install hexo-generator-search --save</code></p></li><li><p>把主题配置文件 <code>_config.butterfly.yml</code> 中 <code>search</code> 的 <code>use</code> 设置为 <code>local_search</code>。</p></li><li><p>其他配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  preload: false  <span class="comment"># 预加载，开启后，进入网页后会自动加载搜索文件。关闭时，只有点击搜索按钮后，才会加载搜索文件</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: false  <span class="comment"># 将 html 字符串解码为可读字符串</span></span><br><span class="line">  CDN:<span class="comment"># 搜索文件的 CDN 地址（默认使用的本地链接）</span></span><br></pre></td></tr></table></figure></li></ul><h1>三、分享系统</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Share System</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">share:</span></span><br><span class="line">  <span class="comment"># Choose: sharejs / addtoany</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need share</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">sharejs</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Share.js</span></span><br><span class="line">  <span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line">  <span class="attr">sharejs:</span></span><br><span class="line">    <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># AddToAny</span></span><br><span class="line">  <span class="comment"># https://www.addtoany.com/</span></span><br><span class="line">  <span class="attr">addtoany:</span></span><br><span class="line">    <span class="attr">item:</span> <span class="string">facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link</span></span><br></pre></td></tr></table></figure><ul><li><code>butterfly</code> 主题支持两种分享方式，通过设置 <code>use</code>，选择分享方式，可选 <code>sharejs</code> 或 <code>addtoany</code>，如果不提供分享功能则留空。</li></ul><h1>四、评论系统</h1><ul><li><code>Butterfly</code> 主题支持多种评论系统：<code>Disqus</code> / <code>Disqusjs</code> / <code>Livere</code> / <code>Gitalk</code> / <code>Valine</code> / <code>Waline</code> / <code>Utterances</code> / <code>Facebook Comments</code> / <code>Twikoo</code> / <code>Giscus</code> / <code>Remark42</code> / <code>Artalk</code>。可以根据自己的喜好选择其中一种评论系统。</li><li>可以配置双评论系统，只需要同时配置两个评论系统（第一个为默认显示）。</li><li>本站使用 <code>Giscus</code> 评论系统。</li></ul><h2 id="4-1-通用配置">4.1 通用配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need comments</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span></span><br><span class="line">  <span class="comment"># Format of two comments system : Disqus,Waline</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">  <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Display comment count in Home Page</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><code>use</code>：使用的评论（请注意，最多支持两个，如果不需要请留空）。<ul><li><strong>注</strong>：双评论不能是 <code>Disqus</code> 和 <code>Disqusjs</code> 一起，由于其共用同一个 <code>ID</code>，会出错。</li></ul></li><li><code>text</code>：是否显示评论服务商的名字。</li><li><code>lazyload</code>：是否为评论开启 <code>lazyload</code>，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启 <code>lazyload</code> 后，评论数将不显示）。</li><li><code>count</code>：是否在文章顶部显示评论数。<code>Livere</code>、<code>Giscus</code> 和 <code>Utterances</code> 不支持评论数显示。</li><li><code>card_post_count</code>：是否在首页文章卡片显示评论数。<code>Livere</code>、<code>Gitalk</code>、<code>Giscus</code> 和 <code>Utterances</code> 不支持评论数显示。</li></ul><h2 id="4-2-giscus">4.2 Giscus</h2><h3 id="4-2-1-选择一个仓库">4.2.1 选择一个仓库</h3><ul><li>一般选择博客本身即可，比如这里我用的就是这个 <a href="https://github.com/xindong2020/xindong2020.github.io">xindong2020/xindong2020.github.io</a> 。</li></ul><h3 id="4-2-2-安装-giscus">4.2.2 安装 giscus</h3><ul><li><p><a href="https://github.com/apps/giscus">https://github.com/apps/giscus</a> 进入 <code>giscus</code> 的安装界面。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/05.png" width=777/></div></li><li><p>点击 <code>install</code>，会提示选择一个仓库，这里就选择上一步中指定的仓库即可，后续 <code>giscus</code> 就会从该仓库读取数据。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/06.png" width=399/></div></li></ul><h3 id="4-2-3-开启-discussions">4.2.3 开启 Discussions</h3><ul><li><p>打开之前选择的仓库（<a href="https://github.com/xindong2020/xindong2020.github.io">xindong2020/xindong2020.github.io</a>），进入 <code>Settings</code> 设置界面，勾选上 <code>Discussions</code> 以开启该仓库的 <code>Discussions</code>。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/07.png" width=599/></div></li></ul><h3 id="4-2-4-从-giscus-官网获取配置信息">4.2.4 从 giscus 官网获取配置信息</h3><ul><li><p>完成上述准备工作后就可以访问 <a href="https://giscus.app/zh-CN">giscus 官网</a> 获取配置信息了。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/08.png" width=599/></div></li><li><p>配置完成后，页面往下滑，会生成一个配置文件。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/09.png" width=599/></div><ul><li>主要关注以下字段：<ul><li><code>data-repo</code></li><li><code>data-repo-id</code></li><li><code>data-category</code></li><li><code>data-category-id</code></li><li><code>data-mapping</code></li></ul></li></ul></li></ul><h3 id="4-2-5-在-butterfly-主题中配置">4.2.5 在 Butterfly 主题中配置</h3><ul><li><p>在主题配置文件 <code>_config.butterfly.yml</code> 中找到 <code>giscus</code> 配置项，根据上一步中重点关注的字段，对应填入内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Giscus</span></span><br><span class="line"><span class="comment"># https://giscus.app/</span></span><br><span class="line"><span class="attr">giscus:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">repo_id:</span></span><br><span class="line">  <span class="attr">category_id:</span></span><br><span class="line">  <span class="attr">light_theme:</span> <span class="string">light</span></span><br><span class="line">  <span class="attr">dark_theme:</span> <span class="string">dark</span></span><br><span class="line">  <span class="attr">js:</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-6-汉化">4.2.6 汉化</h3><ul><li><p>打开文件 <code>themes\butterfly\layout\includes\third-party\comments\giscus.pug</code>，添加内容 <code>'data-lang': 'zh-CN',</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">giscusConfig</span> <span class="string">=</span> &#123;</span><br><span class="line">  <span class="attr">src:</span> <span class="string">&#x27;!&#123;giscusUrl&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">&#x27;data-repo&#x27;:</span> <span class="string">&#x27;!&#123;repo&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">&#x27;data-repo-id&#x27;:</span> <span class="string">&#x27;!&#123;repo_id&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">&#x27;data-category-id&#x27;:</span> <span class="string">&#x27;!&#123;category_id&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">&#x27;data-theme&#x27;:</span> <span class="string">getGiscusTheme(document.documentElement.getAttribute(&#x27;data-theme&#x27;))</span>,</span><br><span class="line">  <span class="attr">&#x27;data-reactions-enabled&#x27;:</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="attr">&#x27;data-lang&#x27;:</span> <span class="string">&#x27;zh-CN&#x27;</span>, <span class="string">//</span> <span class="string">汉化</span></span><br><span class="line">  <span class="attr">crossorigin:</span> <span class="string">&#x27;anonymous&#x27;</span>,</span><br><span class="line">  <span class="attr">async:</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">...option</span>,</span><br><span class="line">  <span class="string">...mappingConfig</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>五、在线聊天</h1><ul><li><code>Butterfly</code> 主题内置了多种在线聊天工具。你可以选择开启一种，方便你与访客的交流。</li></ul><h2 id="5-1-通用配置">5.1 通用配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chat:</span><br><span class="line">  <span class="comment"># Choose: chatra/tidio/crisp</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need chat</span></span><br><span class="line">  use:</span><br><span class="line">  <span class="comment"># Chat Button [recommend]</span></span><br><span class="line">  <span class="comment"># It will create a button in the bottom right corner of website, and hide the origin button</span></span><br><span class="line">  rightside_button: false</span><br><span class="line">  <span class="comment"># The origin chat button is displayed when scrolling up, and the button is hidden when scrolling down</span></span><br><span class="line">  button_hide_show: false</span><br></pre></td></tr></table></figure><ul><li><code>use</code>：选择你要使用的聊天工具，可选择 <code>chatra</code> / <code>tidio</code> / <code>crisp</code>。</li><li><code>rightside_button</code>：是否开启右下角聊天按钮。</li><li><code>button_hide_show</code>：是否开启滚动时隐藏聊天按钮。</li></ul><h2 id="5-2-chatra">5.2 chatra</h2><ul><li><p><a href="https://chatra.com/cn/">https://chatra.com/cn/</a> 注册 <code>chatra</code> 并进行配置（需要使用国外邮箱地址），可以在 <code>Preferences</code> 中找到 <code>Public key</code> 填入 <code>chatra</code> 的 <code>id</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://chatra.io/</span></span><br><span class="line">chatra:</span><br><span class="line">  <span class="built_in">id</span>:</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/10.png" width=799/></div></li></ul><h2 id="5-3-tidio">5.3 tidio</h2><ul><li><p><a href="https://www.tidio.com/">https://www.tidio.com/</a> 注册 <code>tidio</code> 并进行配置，可以在 <code>Preferences</code> -&gt; <code>Developer</code> -&gt; <code>Project data</code> 中找到 <code>Public key</code> 填入 <code>tidio</code> 的 <code>public_key</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.tidio.com/</span></span><br><span class="line">tidio:</span><br><span class="line">  public_key:</span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/05/11.png" width=799/></div></li></ul><h2 id="5-4-crisp">5.4 crisp</h2><ul><li><p><a href="https://crisp.chat/en/">https://crisp.chat/en/</a> 注册 <code>crisp</code> 并进行配置，找到需要的网站 <code>ID</code> 填入 <code>crisp</code> 的 <code>website_id</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://crisp.chat/en/</span></span><br><span class="line">crisp:</span><br><span class="line">  website_id:</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly 主题配置文件（二）</title>
      <link href="/posts/hexo/butterfly/04.html"/>
      <url>/posts/hexo/butterfly/04.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、主页设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Index page settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="1-1-主页顶部图">1.1 主页顶部图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The top_img settings of home page</span></span><br><span class="line"><span class="comment"># default: top img - full screen, site info - middle</span></span><br><span class="line"><span class="comment"># The position of site info, eg: 300px/300em/300rem/10%</span></span><br><span class="line"><span class="attr">index_site_info_top:</span> <span class="comment"># 主页标题距离顶部距离，例：300px/300em/300rem/10%</span></span><br><span class="line"><span class="comment"># The height of top_img, eg: 300px/300em/300rem</span></span><br><span class="line"><span class="attr">index_top_img_height:</span> <span class="comment"># 主页 top_img 高度，例：300px/300em/ 300rem，不能使用百分比</span></span><br></pre></td></tr></table></figure><h2 id="1-2-主页副标题">1.2 主页副标题</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The subtitle on homepage（主页副标题）</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Typewriter Effect（打字效果）</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span></span><br><span class="line">  <span class="comment"># Source - Call the third-party service API (Chinese only) 调用第三方服务</span></span><br><span class="line">  <span class="comment"># It will show the source first, then show the content of sub 先显示 source 内容，然后显示 sub 内容</span></span><br><span class="line">  <span class="comment"># Choose: false/1/2/3</span></span><br><span class="line">  <span class="comment"># false - disable the function</span></span><br><span class="line">  <span class="comment"># 1 - hitokoto.cn</span></span><br><span class="line">  <span class="comment"># 2 - yijuzhan.com</span></span><br><span class="line">  <span class="comment"># 3 - jinrishici.com</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If you close the typewriter effect, the subtitle will only show the first line of sub</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，副标题只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">人生苦短，我用</span> <span class="string">Python</span></span><br></pre></td></tr></table></figure><h2 id="1-3-主页文章布局">1.3 主页文章布局</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Article layout on the homepage</span></span><br><span class="line"><span class="comment"># 1: Cover on the left, info on the right 封面在左，信息在右</span></span><br><span class="line"><span class="comment"># 2: Cover on the right, info on the left 封面在右，信息在左</span></span><br><span class="line"><span class="comment"># 3: Cover and info alternate between left and right 封面和信息左右交替显示</span></span><br><span class="line"><span class="comment"># 4: Cover on top, info on the bottom 封面在上，信息在下</span></span><br><span class="line"><span class="comment"># 5: Info displayed on the cover 信息显示在封面上</span></span><br><span class="line"><span class="comment"># 6: Masonry layout - Cover on top, info on the bottom 瀑布流布局 - 封面在上，信息在下</span></span><br><span class="line"><span class="comment"># 7: Masonry layout - Info displayed on the cover 瀑布流布局 - 信息显示在封面上</span></span><br><span class="line"><span class="attr">index_layout:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="1-4-主页文章节选">1.4 主页文章节选</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display the article introduction on homepage</span></span><br><span class="line"><span class="comment"># 1: description 只显示 description</span></span><br><span class="line"><span class="comment"># 2: both (if the description exists, it will show description, or show the auto_excerpt) 优先选择 description，如果没有配置 description，则显示自动节选的内容</span></span><br><span class="line"><span class="comment"># 3: auto_excerpt (default) 只显示自动节选</span></span><br><span class="line"><span class="comment"># false: do not show the article introduction 不显示文章内容</span></span><br><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># If you set method to 2 or 3, the length need to config</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># 自动节选的长度，只有在 method 为 2 或 3 的时候才需要配置 length</span></span><br></pre></td></tr></table></figure><ul><li><p>在主页有三种显示文章的方法 <code>method</code>：</p><ul><li><p>1: <code>description</code>，这种方法需要在文章的 <code>front-matter</code>，即 <code>Markdown</code> 文件的顶部，添加自定义的 <code>description</code>，<code>description</code> 的内容会被作为文章简介显示在主页。</p></li><li><p>2: <code>both</code>，如果文章存在 <code>description</code> 就按照方法 <code>1</code> 操作，否则按照方法 <code>3</code> 处理。</p></li><li><p>3: <code>auto_excerpt</code>，这种方法会自动从文章中截取 <code>length</code> 长度的文字作为文章简介显示到主页。</p></li></ul></li></ul><h1>二、文章页设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="2-1-文章目录">2.1 文章目录</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># toc (目錄)</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span> <span class="comment"># 文章页是否显示 TOC</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">false</span> <span class="comment"># 普通页面是否显示 TOC</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span> <span class="comment"># 是否显示章节数</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">false</span> <span class="comment"># 是否展开 TOC</span></span><br><span class="line">  <span class="comment"># Only for post</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> <span class="comment"># for post 简洁模式（侧边栏只显示 TOC，只对文章页有效）</span></span><br><span class="line">  <span class="attr">scroll_percent:</span> <span class="literal">true</span> <span class="comment"># 是否显示滚动进度百分比</span></span><br></pre></td></tr></table></figure><h2 id="2-2-文章版权">2.2 文章版权</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否启用版权声明</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">false</span> <span class="comment"># 是否进行文章 URL 解码</span></span><br><span class="line">  <span class="attr">author_href:</span> <span class="comment"># 作者链接</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span> <span class="comment"># 许可证类型</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span> <span class="comment"># 许可证链接</span></span><br></pre></td></tr></table></figure><ul><li><p>如果有文章（例：转载文章）不需要显示版权，可以在文章 <code>Front-matter</code> 中单独设置 <code>copyright:  false</code></p></li><li><p>支持对单独文章设置版权信息，可以在文章 <code>Front-matter</code> 中单独设置</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copyright_author:</span> <span class="string">xxxx</span> </span><br><span class="line"><span class="attr">copyright_author_href:</span> <span class="string">https://xxxxxx.com</span> </span><br><span class="line"><span class="attr">copyright_url:</span> <span class="string">https://xxxxxx.com</span> </span><br><span class="line"><span class="attr">copyright_info:</span> <span class="string">此文章版权归</span> <span class="string">xxxxx</span> <span class="string">所有，如有转载，请注明来自原作者</span></span><br></pre></td></tr></table></figure><h2 id="2-3-文章打赏">2.3 文章打赏</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sponsor/reward</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="comment"># - img: /img/wechat.jpg</span></span><br><span class="line">    <span class="comment">#   link:</span></span><br><span class="line">    <span class="comment">#   text: wechat</span></span><br><span class="line">    <span class="comment"># - img: /img/alipay.jpg</span></span><br><span class="line">    <span class="comment">#   link:</span></span><br><span class="line">    <span class="comment">#   text: alipay</span></span><br></pre></td></tr></table></figure><h2 id="2-4-文章编辑">2.4 文章编辑</h2><ul><li><p>文章标题旁显示编辑按钮，点击则跳转到对应的链接，直接修改源码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post edit</span></span><br><span class="line"><span class="comment"># Easily browse and edit blog source code online.</span></span><br><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/</span></span><br><span class="line">  <span class="comment"># For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/</span></span><br><span class="line">  <span class="attr">url:</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-5-相关文章推荐">2.5 相关文章推荐</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Related Articles</span></span><br><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Number of posts displayed</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span></span><br><span class="line">  <span class="comment"># Choose: created / updated</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># 文章日期显示創建日 / 更新日</span></span><br></pre></td></tr></table></figure><h2 id="2-6-文章分页">2.6 文章分页</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post_pagination (分页)</span></span><br><span class="line"><span class="comment"># value: 1 || 2 || false</span></span><br><span class="line"><span class="comment"># 1: The &#x27;next post&#x27; will link to old post 下一篇显示的是旧文章</span></span><br><span class="line"><span class="comment"># 2: The &#x27;next post&#x27; will link to new post 下一篇显示的是新文章</span></span><br><span class="line"><span class="comment"># false: disable pagination 关闭分页按钮</span></span><br><span class="line"><span class="attr">post_pagination:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-7-文章过期提醒">2.7 文章过期提醒</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Displays outdated notice for a post（文章过期提醒）</span></span><br><span class="line"><span class="attr">noticeOutdate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span> <span class="comment"># style: simple/flat</span></span><br><span class="line">  <span class="attr">limit_day:</span> <span class="number">500</span> <span class="comment"># When will it be shown 距离更新时间多少天才显示文章过期提醒</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span> <span class="comment"># position: top/bottom # 文章过期提醒显示位置</span></span><br><span class="line">  <span class="attr">message_prev:</span> <span class="string">It</span> <span class="string">has</span> <span class="string">been</span> <span class="comment"># 天数之前的文字</span></span><br><span class="line">  <span class="attr">message_next:</span> <span class="string">days</span> <span class="string">since</span> <span class="string">the</span> <span class="string">last</span> <span class="string">update,</span> <span class="string">the</span> <span class="string">content</span> <span class="string">of</span> <span class="string">the</span> <span class="string">article</span> <span class="string">may</span> <span class="string">be</span> <span class="string">outdated.</span> <span class="comment"># 天数之后的文字</span></span><br></pre></td></tr></table></figure><h1>三、页脚设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Footer Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2024</span> <span class="comment"># 站点创建年份</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="comment"># 自定义文本</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework 框架和主题版权声明</span></span><br></pre></td></tr></table></figure><h1>四、侧边栏设置</h1><ul><li><p>可自定义侧边栏中显示的模块与显示的位置，也可以设置不显示侧边栏。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Aside Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 侧边栏是否开启</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span> <span class="comment"># 侧边栏是否隐藏</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span> <span class="comment"># # 是否显示侧边栏开启/隐藏按钮</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile 移动设备是否显示侧边栏</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right 侧边栏位置</span></span><br><span class="line">  <span class="attr">display:</span> <span class="comment"># 是否显示归档 archive、标签 tag、分类 category</span></span><br><span class="line">    <span class="attr">archive:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">category:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_author:</span> <span class="comment"># 作者信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span> </span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/xxxxxx</span></span><br><span class="line">  <span class="attr">card_announcement:</span> <span class="comment"># 公告栏</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">card_recent_post:</span> <span class="comment"># 最近发布的文章</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_newest_comments:</span> <span class="comment"># 最新评论</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">sort_order:</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示评论数目，0 为全部</span></span><br><span class="line">    <span class="comment"># Unit: mins, save data to localStorage</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="number">10</span> <span class="comment"># 保存时间，单位分钟，保存到本地存储，避免每次刷新都重新请求数据</span></span><br><span class="line">    <span class="attr">avatar:</span> <span class="literal">true</span> <span class="comment"># 是否显示头像</span></span><br><span class="line">  <span class="attr">card_categories:</span> <span class="comment"># 分类栏</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span> <span class="comment"># 标签栏</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span> <span class="comment"># 是否显示标签颜色</span></span><br><span class="line">    <span class="attr">orderby:</span> <span class="string">random</span> <span class="comment"># Order of tags, random/name/length</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span> <span class="comment"># 归档栏</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_post_series:</span> <span class="comment"># 显示系列名称</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># The title shows the series name</span></span><br><span class="line">    <span class="attr">series_title:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Order by title or date</span></span><br><span class="line">    <span class="attr">orderBy:</span> <span class="string">&#x27;date&#x27;</span></span><br><span class="line">    <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">card_webinfo:</span> <span class="comment"># 网站信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span> <span class="comment"># 是否显示文章数量</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span> <span class="comment"># 是否显示最近更新时间</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">    <span class="comment"># Time difference between publish date and now</span></span><br><span class="line">    <span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line">    <span class="comment"># Leave it empty if you don&#x27;t enable this feature</span></span><br><span class="line">    <span class="attr">runtime_date:</span> <span class="number">2024</span><span class="string">/11/07</span> <span class="number">00</span><span class="string">:00:00</span> <span class="comment"># 显示网站运行时间，开启格式一定要是 Month/Day/Year Time 或 Year/Month/Day Time</span></span><br></pre></td></tr></table></figure></li></ul><h1>五、右下角按钮</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Bottom right button</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="5-1-右下角按钮位置">5.1 右下角按钮位置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the position of bottom right button/default unit: px (右下角按鈕距離底部的距離/默認單位為px)</span></span><br><span class="line"><span class="attr">rightside_bottom:</span></span><br></pre></td></tr></table></figure><h2 id="5-2-简繁转换">5.2 简繁转换</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (簡繁轉換)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># The text of a button</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">繁</span> <span class="comment"># 默认按钮显示文字（网站是简体，应设置为&#x27;default: 繁&#x27;）</span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">2</span> <span class="comment"># 网站默认语言，1 - 繁体中文，2 - 简体中文</span></span><br><span class="line">  <span class="comment"># Time delay</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span> <span class="comment"># 延迟翻译的时间， 单位 ms，默认 0 无延迟</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Simplified Chinese</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">&#x27;繁&#x27;</span> <span class="comment"># 当网站语言是简体中文时，按钮显示的文字</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Traditional Chinese</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">&#x27;簡&#x27;</span> <span class="comment"># 当网站语言是繁体中文时，按钮显示的文字</span></span><br></pre></td></tr></table></figure><h2 id="5-3-阅读模式">5.3 阅读模式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read Mode (閲讀模式)</span></span><br><span class="line"><span class="attr">readmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="5-4-夜间模式">5.4 夜间模式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span> <span class="comment"># dark 和 light 两种模式切换按钮</span></span><br><span class="line">  <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">  <span class="comment"># autoChangeMode: false</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="literal">false</span> <span class="comment"># 自动切換 dark mode 和 light mode</span></span><br><span class="line">  <span class="comment"># Set the light mode time. The value is between 0 and 24. If not set, the default value is 6 and 18</span></span><br><span class="line">  <span class="attr">start:</span> <span class="comment"># 8</span></span><br><span class="line">  <span class="attr">end:</span> <span class="comment"># 22</span></span><br></pre></td></tr></table></figure><h2 id="5-5-滚动状态百分比">5.5 滚动状态百分比</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show scroll percent in scroll-to-top button</span></span><br><span class="line"><span class="attr">rightside_scroll_percent:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="5-6-右下角按钮排序">5.6 右下角按钮排序</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work</span></span><br><span class="line"><span class="comment"># Choose: readmode,translate,darkmode,hideAside,toc,chat,comment</span></span><br><span class="line"><span class="comment"># Don&#x27;t repeat the same value</span></span><br><span class="line"><span class="attr">rightside_item_order:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Default: readmode,translate,darkmode,hideAside</span></span><br><span class="line">  <span class="attr">hide:</span></span><br><span class="line">  <span class="comment"># Default: toc,chat,comment</span></span><br><span class="line">  <span class="attr">show:</span></span><br></pre></td></tr></table></figure><h1>六、全局设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Global Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="6-1-文章锚点">6.1 文章锚点</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="attr">anchor:</span></span><br><span class="line">  <span class="comment"># when you scroll, the URL will update according to header id.</span></span><br><span class="line">  <span class="attr">auto_update:</span> <span class="literal">false</span> <span class="comment"># 开启文章锚点后，在文章页滚动时，文章链接会根据标题 ID 进行更新</span></span><br><span class="line">  <span class="comment"># Click the headline to scroll and update the anchor</span></span><br><span class="line">  <span class="attr">click_to_scroll:</span> <span class="literal">false</span> <span class="comment"># 开启后，点击标题链接可以实现跳转并更新锚点</span></span><br></pre></td></tr></table></figure><h2 id="6-2-图片描述">6.2 图片描述</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># figcaption (圖片描述文字)</span></span><br><span class="line"><span class="attr">photofigcaption:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><p>开启图片 <code>Figcaption</code> 描述文字显示，将优先显示图片的 <code>title</code> 属性，然后是 <code>alt</code> 属性。</p><ul><li><p>图片中的 <code>title</code> 属性是在鼠标在移动到元素上的文本提示。</p></li><li><p>图片中的 <code>alt</code> 属性是在图片不能正常显示时出现的文本提示。</p></li></ul></li></ul><h2 id="6-3-文章复制">6.3 文章复制</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启网站复制权限</span></span><br><span class="line">  <span class="comment"># Add the copyright information after copied content</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="comment"># 复制的内容后面加上版权信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否开启复制版权信息添加</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">30</span> <span class="comment"># 当复制文字大于这个字数限制时，将在复制的内容后面加上版权信息</span></span><br></pre></td></tr></table></figure><h1>七、字数统计</h1><ul><li><p>在博客目录下安装插件：<code>npm install hexo-wordcount --save</code></p></li><li><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Need to install the hexo-wordcount plugin</span></span><br><span class="line"><span class="comment"># wordcount (字數統計)</span></span><br><span class="line"><span class="comment"># see https://butterfly.js.org/posts/ceeb73f/#字數統計</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Display the word count of the article in post meta</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span> <span class="comment"># 单篇文章字数</span></span><br><span class="line">  <span class="comment"># Display the time to read the article in post meta</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span> <span class="comment"># 单篇文章阅读时长</span></span><br><span class="line">  <span class="comment"># Display the total word count of the website in aside&#x27;s webinfo</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span> <span class="comment"># 全站总字数</span></span><br></pre></td></tr></table></figure></li></ul><h1>八、访问人数</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># busuanzi count for PV / UV in site</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span> <span class="comment"># 总访客数</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span> <span class="comment"># 总访问量</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span> <span class="comment"># 总阅读量</span></span><br></pre></td></tr></table></figure><ol class="series-items"><li><a href="/posts/hexo/butterfly/01" title="Hexo 框架 + Butterfly 主题打造个人博客">Hexo 框架 + Butterfly 主题打造个人博客</a></li><li><a href="/posts/hexo/butterfly/02" title="Hexo 框架全局配置文件">Hexo 框架全局配置文件</a></li><li><a href="/posts/hexo/butterfly/03" title="Butterfly 主题配置文件（一）">Butterfly 主题配置文件（一）</a></li><li><a href="/posts/hexo/butterfly/04" title="Butterfly 主题配置文件（二）">Butterfly 主题配置文件（二）</a></li><li><a href="/posts/hexo/butterfly/05" title="Butterfly 主题配置文件（三）">Butterfly 主题配置文件（三）</a></li><li><a href="/posts/hexo/butterfly/06" title="Butterfly 主题自带美化效果">Butterfly 主题自带美化效果</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly 主题配置文件（一）</title>
      <link href="/posts/hexo/butterfly/03.html"/>
      <url>/posts/hexo/butterfly/03.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><p>在 <code>\themes\butterfly</code> 文件夹中找到主题配置文件 <code>_config.yml</code>，复制到博客目录并重命名为 <code>_config.butterfly.yml</code>。</p></li><li><p><code>hexo</code> 中，博客目录下的 <code>_config.butterfly.yml</code> 文件优先级高于 <code>\themes\butterfly\_config.yml</code>。</p></li></ul><h1>一、导航栏设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Navigation Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="comment"># Navigation bar logo image</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># 网站的 logo</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span> <span class="comment"># 是否显示网站标题</span></span><br><span class="line">  <span class="comment"># Whether to fix navigation bar</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span> <span class="comment"># 是否固定导航栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Menu 目錄</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Home: / || fas fa-home</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br></pre></td></tr></table></figure><ul><li><p><code>menu</code> 菜单栏中的每一项都指向单独的子页面，对应于 <code>soure</code> 中的一个文件夹（不包含 <code>_posts</code> 和 <code>_draft</code> 文件夹）。</p><ul><li><p>可以使用 <code>hexo new page &lt;title&gt;</code> 指令创建页面，例：<code>hexo new page about</code> 创建 <code>About</code> 界面，同时在 <code>soure</code> 中自动生成一个 <code>about</code> 文件夹。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/01.png" width=520/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/02.png" width=399/></div></li><li><p><code>About</code>、<code>Link</code>、<code>List</code> 等属于普通页面，直接创建即可。但是 <code>archives</code>（归档）、<code>tags</code>（标签）、<code>categories</code>（分类）等属于特殊页面，需要其他操作。</p><ul><li><p>归档页面（<code>archives</code>）是内建的，不需要手动创建。</p></li><li><p>标签页面（<code>tags</code>）在使用 <code>hexo new page tags</code> 创建后，需要在 <code>tags</code> 文件夹的 <code>index.md</code> 文件开头加上 <code>type: &quot;tags&quot;</code> 和 <code>layout: &quot;tags&quot;</code>，内容留空。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title<span class="punctuation">:</span> tags</span><br><span class="line">date<span class="punctuation">:</span> <span class="number">2024</span><span class="number">-01</span><span class="number">-07</span> <span class="number">15</span><span class="punctuation">:</span><span class="number">47</span><span class="punctuation">:</span><span class="number">56</span></span><br><span class="line">type<span class="punctuation">:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line">layout<span class="punctuation">:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>分类页面（<code>categories</code>）采用相同操作。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title<span class="punctuation">:</span> categories</span><br><span class="line">date<span class="punctuation">:</span> <span class="number">2024</span><span class="number">-01</span><span class="number">-07</span> <span class="number">15</span><span class="punctuation">:</span><span class="number">58</span><span class="punctuation">:</span><span class="number">01</span></span><br><span class="line">type<span class="punctuation">:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line">layout<span class="punctuation">:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>创建新菜单选项的格式如下：</p><ul><li><p>单菜单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">菜单名称</span>&#125;<span class="string">:</span> &#123;<span class="string">路径</span>&#125; <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-&#123;图标名称&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>二级菜单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">一级菜单名称</span>&#125; <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-&#123;图标名称&#125;:</span></span><br><span class="line">  &#123;<span class="string">二级菜单名称</span>&#125;<span class="string">:</span> &#123;<span class="string">路径</span>&#125; <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-&#123;图标名称&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>二、图标相关</h1><ul><li><code>Butterfly</code> 主题默认支持 <code>font-awesome</code> 图标，但是 <code>font-awesome</code> 对于国内网站的支持不足，建议使用阿里巴巴 <code>iconfont</code>。</li></ul><h2 id="2-1-阿里巴巴-iconfont">2.1 阿里巴巴 iconfont</h2><ul><li><p>阿里巴巴矢量图标管理、交流平台：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a>，进入到图标库。</p></li><li><p>找到自己需要的图标之后点击添加入库。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/03.png" width=299/></div></li><li><p>选择购物车，然后添加至项目。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/04.png" width=333/>Q</div></li><li><p>如果不存在已有项目，需要创建新项目。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/05.png" width=333/>Q</div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/06.png" width=333/>Q</div></li><li><p>创建新项目后，选择 <code>Font class</code>，然后点击查看在线链接。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/07.png" width=777/>Q</div><ul><li><p>如果暂无代码，需要手动生成。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/08.png" width=666/>Q</div></li><li><p>进入生成的链接，并复制生成的代码（注：<code>点此复制代码</code> 只是复制了链接地址而不是代码本身）。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/09.png" width=699/>Q</div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/10.png" width=799/>Q</div></li></ul></li><li><p>在 <code>butterfly</code> 主题文件夹（<code>\themes\butterfly</code>）下的 <code>\source\css</code> 文价夹中新建 <code>font.css</code> 文件，将复制的代码粘贴进去。</p></li><li><p>在 <code>butterfly</code> 主题文件 <code>_config.butterfly.yml</code> 中引入 <code>font.css</code> 文件。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/11.png" width=699/>Q</div></li><li><p>在 <code>_config.butterfly.yml</code> 文件中使用格式 <code>iconfont icon名</code> 即可使用 <code>iconfont</code> 图标，其中 <code>icon名</code> 可以在 <code>iconfont</code> 项目中复制。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/03/12.png" width=599/>Q</div></li></ul><h1>三、代码相关</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Code Blocks Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">code_blocks:</span></span><br><span class="line">  <span class="comment"># Code block theme: darker / pale night / light / ocean / false</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">light</span> <span class="comment"># 代码主题</span></span><br><span class="line">  <span class="attr">macStyle:</span> <span class="literal">false</span> <span class="comment"># 是否使用 Mac 风格</span></span><br><span class="line">  <span class="comment"># Code block height limit (unit: px)</span></span><br><span class="line">  <span class="attr">height_limit:</span> <span class="literal">false</span> <span class="comment"># 代码块高度限制（单位: px）, 可填写数字或 false</span></span><br><span class="line">  <span class="attr">word_wrap:</span> <span class="literal">false</span> <span class="comment"># 是否自动换行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Toolbar</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="literal">true</span> <span class="comment"># 是否显示复制按钮</span></span><br><span class="line">  <span class="attr">language:</span> <span class="literal">true</span> <span class="comment"># 是否显示语言标签</span></span><br><span class="line">  <span class="comment"># true: shrink the code blocks | false: expand the code blocks | none: expand code blocks and hide the button</span></span><br><span class="line">  <span class="attr">shrink:</span> <span class="literal">false</span> <span class="comment"># true: 收缩代码块 / false: 展开代码块/ none: 展开代码块并隐藏按钮</span></span><br><span class="line">  <span class="attr">fullpage:</span> <span class="literal">false</span> <span class="comment"># 是否全屏显示代码块</span></span><br></pre></td></tr></table></figure><h1>四、社交图标</h1><ul><li><p>书写格式：<code>图标名：url || 描述性文字 || color</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social media links</span></span><br><span class="line"><span class="comment"># Formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description || color</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">iconfont icon-GitHub:</span> <span class="string">https://github.com/xindong2020</span> <span class="string">||</span> <span class="string">Github</span> <span class="string">||</span> <span class="string">&#x27;#24292e&#x27;</span></span><br><span class="line">  <span class="attr">iconfont icon-icon-email:</span> <span class="string">mailto:641743220@qq.com</span> <span class="string">||</span> <span class="string">Email</span> <span class="string">||</span> <span class="string">&#x27;#4a7dbe&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h1>五、图片设置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># Image Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="5-1-网站图标">5.1 网站图标</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Favicon（網站圖標）</span></span><br><span class="line"><span class="attr">favicon:</span> </span><br></pre></td></tr></table></figure><h2 id="5-2-头像">5.2 头像</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> </span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span> <span class="comment"># 头像是否自动旋转</span></span><br></pre></td></tr></table></figure><h2 id="5-3-去掉所有页面顶部图">5.3 去掉所有页面顶部图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disable all banner image</span></span><br><span class="line"><span class="attr">disable_top_img:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><code>disable_top_img</code> 设置为 <code>true</code> 时，所有页面的顶部图都不显示，即所有顶部图相关设置都会失效。</li></ul><h2 id="5-4-默认顶部图">5.4 默认顶部图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of page not setting, it will show the top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> </span><br></pre></td></tr></table></figure><h2 id="5-5-主页顶部图">5.5 主页顶部图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page</span></span><br><span class="line"><span class="attr">index_img:</span> </span><br></pre></td></tr></table></figure><h2 id="5-5-归档页面顶部图">5.5 归档页面顶部图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The banner image of archive page</span></span><br><span class="line"><span class="attr">archive_img:</span> </span><br></pre></td></tr></table></figure><h2 id="5-6-标签页面顶部图">5.6 标签页面顶部图</h2><ul><li><p>设置标签页面（<code>tags</code>）顶部图，需要在 <code>\source\tags</code> 文件夹中的 <code>index.md</code> 文件开头处加入 <code>top_img: 图片地址</code>。例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top_img:</span> </span><br></pre></td></tr></table></figure></li><li><p>子标签页面（<code>tag</code>）默认顶部图 <code>tag_img</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of tag page not setting, it will show the top_img</span></span><br><span class="line"><span class="comment"># <span class="doctag">note:</span> tag page, not tags page (子標籤頁面的 top_img)</span></span><br><span class="line"><span class="attr">tag_img:</span> </span><br></pre></td></tr></table></figure></li><li><p>设置每个子标签页面（<code>tag</code>）的顶部图 <code>tag_per_img</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The banner image of tag page, you can set the banner image for each tag</span></span><br><span class="line"><span class="comment"># format:</span></span><br><span class="line"><span class="comment">#  - tag name: xxxxx</span></span><br><span class="line"><span class="attr">tag_per_img:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">tag name:</span> <span class="string">xxxxx</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-7-分类页面顶部图">5.7 分类页面顶部图</h2><ul><li><p>设置分类页面（<code>categories</code>）顶部图，需要在 <code>\source\categories</code> 文件夹中的 <code>index.md</code> 文件开头处加入 <code>top_img: 图片地址</code>。例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top_img:</span> </span><br></pre></td></tr></table></figure></li><li><p>分类页面（<code>categorie</code>）默认顶部图</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of category page not setting, it will show the top_img</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> category page, not categories page (子分類頁面的 top_img)</span></span><br><span class="line"><span class="attr">category_img:</span> </span><br></pre></td></tr></table></figure></li><li><p>设置每个分类页面（<code>tag</code>）的顶部图</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The banner image of category page, you can set the banner image for each category</span></span><br><span class="line"><span class="comment"># format:</span></span><br><span class="line"><span class="comment">#  - category name: xxxxx</span></span><br><span class="line"><span class="attr">category_per_img:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">category name:</span> <span class="string">xxxxx</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-8-页脚背景图">5.8 页脚背景图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The background image of footer</span></span><br><span class="line"><span class="attr">footer_img:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><p>留空 / <code>false</code>：显示默认的颜色</p></li><li><p><code>true</code>：显示跟 <code>top_img</code> 一样。</p></li><li><p>图片链接：显示链接对应的图片。</p></li><li><p>颜色（<code>HEX</code> 值 / <code>RGB</code> 值 / 颜色单词 / 渐变色）：显示对应的颜色。</p></li><li><p><code>transparent</code>：透明。</p></li></ul><h2 id="5-9-网站背景图">5.9 网站背景图</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Website Background (設置網站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可設置圖片 或者 顔色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="comment"># 颜色（HEX 值/ RGB 值/ 颜色单词/ 渐变色）</span></span><br><span class="line"><span class="comment"># 图片，格式为 url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> </span><br></pre></td></tr></table></figure><h2 id="5-10-文章的封面">5.10 文章的封面</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span> </span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span> <span class="comment"># 主页是否显示文章封面</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span> <span class="comment"># 侧边栏是否显示文章封面</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span> <span class="comment"># 归档页面是否显示文章封面</span></span><br><span class="line">  <span class="comment"># When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)</span></span><br><span class="line">  <span class="attr">default_cover:</span> <span class="comment"># 当配置多张图片时，会随机选择一张作为 cover</span></span><br><span class="line">    <span class="comment"># - xxx.jpg</span></span><br></pre></td></tr></table></figure><ul><li>为每篇文章单独设置封面，需要在文章的 <code>Fort-matter</code> 中添加 <code>cover</code>：<code>cover: xxx.jpg</code></li></ul><h2 id="5-11-替换无法显示的图片">5.11 替换无法显示的图片</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replace Broken Images (替換無法顯示的圖片)</span></span><br><span class="line"><span class="attr">error_img:</span></span><br><span class="line">  <span class="attr">flink:</span> <span class="string">/img/friend_404.gif</span> <span class="comment"># 友链头像替换</span></span><br><span class="line">  <span class="attr">post_page:</span> <span class="string">/img/404.jpg</span> <span class="comment"># 文章封面替换</span></span><br></pre></td></tr></table></figure><h2 id="5-12-404-页面">5.12 404 页面</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span><span class="comment"># 是否开启404页面</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;Page Not Found&#x27;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">/img/error-page.png</span></span><br></pre></td></tr></table></figure><h2 id="5-13-文章-meta-显示">5.13 文章 meta 显示</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page 主页</span></span><br><span class="line">    <span class="comment"># Choose: created / updated / both</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># created or updated or both 主页文章日期显示创建日期 / 更新日期 / 两者都显示</span></span><br><span class="line">    <span class="comment"># Choose: date / relative</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 主页文章显示日期还是相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主页文章是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页文章是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 主页文章是否显示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span> <span class="comment"># 文章页</span></span><br><span class="line">    <span class="comment"># Choose: left / center</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># 文章页 meta 显示的位置，可选 left / center</span></span><br><span class="line">    <span class="comment"># Choose: created / updated / both</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># created or updated or both 文章页日期显示创建日期 / 更新日期 / 两者都显示</span></span><br><span class="line">    <span class="comment"># Choose: date / relative</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 显示日期还是相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 显示描述性文字</span></span><br></pre></td></tr></table></figure><ol class="series-items"><li><a href="/posts/hexo/butterfly/01" title="Hexo 框架 + Butterfly 主题打造个人博客">Hexo 框架 + Butterfly 主题打造个人博客</a></li><li><a href="/posts/hexo/butterfly/02" title="Hexo 框架全局配置文件">Hexo 框架全局配置文件</a></li><li><a href="/posts/hexo/butterfly/03" title="Butterfly 主题配置文件（一）">Butterfly 主题配置文件（一）</a></li><li><a href="/posts/hexo/butterfly/04" title="Butterfly 主题配置文件（二）">Butterfly 主题配置文件（二）</a></li><li><a href="/posts/hexo/butterfly/05" title="Butterfly 主题配置文件（三）">Butterfly 主题配置文件（三）</a></li><li><a href="/posts/hexo/butterfly/06" title="Butterfly 主题自带美化效果">Butterfly 主题自带美化效果</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 框架全局配置文件</title>
      <link href="/posts/hexo/butterfly/02.html"/>
      <url>/posts/hexo/butterfly/02.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、引入 butterfly 主题</h1><ul><li><p>在博客目录中下载 <code>butterfly</code> 主题：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">http.proxy</span> <span class="string">&quot;127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">https.proxy</span> <span class="string">&quot;127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">-b</span> <span class="string">master</span> <span class="string">https://github.com/jerryc127/hexo-theme-butterfly.git</span> <span class="string">themes/butterfly</span></span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/02/01.png" width=799/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/02/02.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/02/03.png" width=666/></div></li><li><p>在 <strong>博客目录</strong> 中安装 <code>pug</code> 和 <code>stylus</code> 的渲染器：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-pug</span> <span class="string">hexo-renderer-stylus</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/02/04.png" width=520/></div></li><li><p>博客采用 <code>butterfly</code> 主题：修改 <code>Hexo</code> 根目录下的 <code>_config.yml</code>，将主题 <code>theme</code> 对应的内容修改为 <code>butterfly</code>。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/02/05.png" width=333/></div></li><li><p>执行命令 <code>hexo clean</code>、<code>hexo generate</code> 和 <code>hexo deploy</code> 部署到 <code>GitHub</code> 之后的网站效果。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/02/06.png" width=888/></div></li></ul><h1>二、全局配置文件 _config.yml</h1><h2 id="2-1-基础信息配置">2.1 基础信息配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Mr.DONG</span> <span class="comment"># 网站主标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">冬天的冬</span> <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">个人学习记录</span> <span class="comment"># 网站描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Python,</span> <span class="string">Java,</span> <span class="string">C++</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">DONG</span>  <span class="comment"># 作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 网站使用的语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span> <span class="comment"># 网站使用的时区</span></span><br></pre></td></tr></table></figure><h2 id="2-2-网址链接配置">2.2 网址链接配置</h2><h3 id="2-2-1-基础配置">2.2.1 基础配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># 用于设置文章在静态文件生成后的路径，最后一个斜线 / 不要忘记</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><ul><li><p><code>hexo</code> 提供了以下变量来生成永久链接 <code>permalink</code>：</p></li><li><p><code>:year</code>：发表年份（<code>4</code> 位数字）</p></li><li><p><code>:month</code>：发表月份（<code>2</code> 位数字）</p></li><li><p><code>:i_month</code>：发表月份（没有前置 <code>0</code>）</p></li><li><p><code>:day</code>：发表日（<code>2</code> 位数字）</p></li><li><p><code>:i_day</code>：发表日（没有前置 <code>0</code>）</p></li><li><p><code>:hour</code>：文章发表时的小时 (<code>2</code> 位数字)</p></li><li><p><code>:minute</code>：文章发表时的分钟 (<code>2</code> 位数字)</p></li><li><p><code>:second</code>：文章发表时的秒钟 (<code>2</code> 位数字)</p></li><li><p><code>:title</code>：文件名</p></li><li><p><code>:name</code>：文件名</p></li><li><p><code>:layout</code>：布局</p></li><li><p><code>:post_title</code>：文章标题</p></li><li><p><code>:id</code>：文章 <code>ID</code>（清除缓存 <code>hexo clean</code> 时不具有持久性）</p></li><li><p><code>:category</code>：类别。若无分类，则使用 <code>default_category</code> 的值。</p></li><li><p><code>:hash</code>：文件名（与 <code>:title</code> 相同）和日期的 <code>SHA1</code> 哈希值（<code>12</code> 位 <code>16</code> 进制数）</p></li></ul><h3 id="2-2-2-利用-hexo-abbrlink-插件生成永久链接">2.2.2 利用 hexo-abbrlink 插件生成永久链接</h3><ul><li><p>在网站目录使用 <code>npm install hexo-abbrlink --save</code> 安装插件。</p></li><li><p>修改 <code>_config.yml</code> 配置文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## permalink: :year/:month/:day/:title/</span></span><br><span class="line">permalink: posts/:abbrlink.html  <span class="comment">## 或 :/abbrlink/</span></span><br><span class="line"><span class="comment"># 可以自定义 &#x27;posts&#x27; 处，如：posts:year/:abbrlink.html 或 :abbrlink.html</span></span><br></pre></td></tr></table></figure><ul><li><strong>注</strong>：如果使用 <code>:/abbrlink/</code>，<code>abbrlink</code> 后须带 <code>/</code>，否则点击链接不会跳转到文章页，而是会触发浏览器下载页面代码操作或跳转到空白链接页面。</li></ul></li><li><p>在 <code>_config.butterfly.yml</code> 配置文件中添加下面内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## abbrlink config</span></span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32      <span class="comment"># support crc16(default) and crc32 进制</span></span><br><span class="line">  rep: dec        <span class="comment"># support dec(default) and hex  算法</span></span><br><span class="line">  drafts: false   <span class="comment"># (true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment">## Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment">## depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  auto_category:</span><br><span class="line">     enable: true  <span class="comment"># true(default)</span></span><br><span class="line">     depth:        <span class="comment"># 3(default)</span></span><br><span class="line">     over_write: false </span><br><span class="line">  auto_title: false <span class="comment"># enable auto title, it can auto fill the title by path</span></span><br><span class="line">  auto_date: false <span class="comment"># enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  force: false <span class="comment"># enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span></span><br></pre></td></tr></table></figure><ul><li><code>alg</code>：算法（目前支持 <code>crc16</code> 和 <code>crc32</code> 算法，默认值是 <code>crc16</code>）</li><li><code>rep</code>：形式（生成的链接可以是十六进制格式也可以是十进制格式，默认值是十进制格式）</li></ul></li></ul><h2 id="2-3-目录配置">2.3 目录配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>  <span class="comment"># 存放 hexo 文章的目录，默认值是 source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>  <span class="comment"># 存放通过 hexo g 生成的文件的目录，默认值是 public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span> <span class="comment"># 按标签存放文章的目录，默认值是 tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span> <span class="comment"># 归档文件夹，存放归档文件，默认值是 archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span>  <span class="comment"># 按分类存放文章的目录，默认值是 categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span>  <span class="comment"># 内部代码文件夹，默认值是 source_dir 的子文件夹 downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span>  <span class="comment"># 指定文件跳过渲染，该文件将会被直接复制到 public 文件夹下</span></span><br></pre></td></tr></table></figure><h2 id="2-4-文章写作配置">2.4 文章写作配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>  <span class="comment"># 新文章的默认名</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span>  <span class="comment"># 点击文章时在新标签页内打开</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 如果想在本标签页内打开文章则设置为 false</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># 对整页有用</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span>  <span class="comment"># 把文件名转换为小写（1）、大写（2），默认不转换（0）</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span>  <span class="comment"># 是否渲染草稿文件，默认为 false 不渲染</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span>  <span class="comment"># 是否显示当前时间之后的文章，默认为 true</span></span><br><span class="line"><span class="attr">highlight:</span>  <span class="comment"># 代码高光</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 是否开启，默认为 true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span> <span class="comment"># 行号显示，默认为 true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span> <span class="comment"># 自动检测代码语言，默认为 false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span> <span class="string">【替换tab】</span></span><br></pre></td></tr></table></figure><ul><li><p>可以使用 <code>hexo new [layout] &lt;title&gt;</code> 创建一篇新文章或新页面，文件名默认为 <code>title.md</code>。可以通过修改 <code>new_post_name</code> 的值 <code>:title.md</code> 来改变默认文件名。</p><ul><li><p>当 <code>title</code> 中包含空格时，需要使用引号将 <code>&quot;title&quot;</code> 包括起来。</p></li><li><p><code>hexo</code> 会根据 <code>scaffolds</code> 模板文件夹中对应的模板文件来创建文件。</p></li></ul></li><li><p>布局 <code>layout</code> 默认为 <code>post</code>，可以通过修改 <code>default_layout</code> 的值 <code>post</code> 来改变默认布局。</p></li><li><p><code>hexo</code> 有三种布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，在创建这三种不同类型的文件时，它们会被保存到不同的路径：<code>post</code> 保存到 <code>source/_posts</code>、<code>page</code> 保存到 <code>source</code>、<code>draft</code> 保存到 <code>source/_drafts</code>。</p><ul><li>自定义布局的存储路径与 <code>post</code> 相同。</li></ul></li><li><p>使用 <code>hexo new draft &lt;title&gt;</code> 创建的草稿在建立时会被保存到 <code>source/_drafts</code> 文件夹，因此 <code>hexo generate</code> 并不会将其编译到 <code>public</code> 目录下，所以 <code>hexo deploy</code> 也不会将其部署到 <code>GitHub</code>。</p><ul><li><p>可以通过 <code>hexo publish &lt;title&gt;</code> 将草稿移动到 <code>source/_posts</code> 文件夹。</p></li><li><p>草稿默认不会显示在页面中，但是可以在执行 <code>hexo server</code> 时加上 <code>--draft</code> 参数，或将 <code>_config.yml</code> 文件中 <code>render_drafts</code> 参数的值设为 <code>true</code> 来预览草稿。</p></li></ul></li><li><p>使用 <code>hexo new page &lt;title&gt;</code> 创建新的界面，会在 <code>source</code> 文件夹中创建一个名为 <code>title</code> 的文件夹，文件夹中自动创建一个 <code>index.md</code> 文件。</p></li></ul><h2 id="2-5-主页配置">2.5 主页配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span>  <span class="comment"># 主页对应的路径，默认为 &#x27;&#x27;，即 url 根目录</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span> <span class="comment"># 每页显示的文章数量，默认为 10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span> <span class="comment"># 文章的排序，默认为 -date，即按日期倒序</span></span><br></pre></td></tr></table></figure><h2 id="2-6-类别-标签">2.6 类别 &amp; 标签</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span> <span class="comment"># 默认类别</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br></pre></td></tr></table></figure><ul><li><p><code>category_map</code> 表示类别映射，例：中文类别映射到英文类别。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">数学:</span> <span class="string">math</span></span><br><span class="line">  <span class="string">编程:</span> <span class="string">programming</span></span><br></pre></td></tr></table></figure></li><li><p><code>tag_map</code> 表示标签映射，与 <code>category_map</code> 类似。</p></li></ul><h2 id="2-7-元数据元素">2.7 元数据元素</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><p>是否在页面开头的 <code>head</code> 元素中插入 <code>meta</code> 标签，默认为 <code>true</code>。</p></li><li><p><code>&lt;meta&gt;</code> 标签提供关于 <code>HTML</code> 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 <code>web</code> 服务。</p></li></ul><h2 id="2-8-日期-时间">2.8 日期 &amp; 时间</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-9-分页">2.9 分页</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>  <span class="comment"># 分页时每页的文章数，如果为 0 则不分页，默认为 10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>  <span class="comment"># 分页的目录，默认为 page，对应于 public 文件夹下的 archives 文件夹下的 page 文件夹，如果只有一页则不会生成这个文件夹</span></span><br></pre></td></tr></table></figure><ol class="series-items"><li><a href="/posts/hexo/butterfly/01" title="Hexo 框架 + Butterfly 主题打造个人博客">Hexo 框架 + Butterfly 主题打造个人博客</a></li><li><a href="/posts/hexo/butterfly/02" title="Hexo 框架全局配置文件">Hexo 框架全局配置文件</a></li><li><a href="/posts/hexo/butterfly/03" title="Butterfly 主题配置文件（一）">Butterfly 主题配置文件（一）</a></li><li><a href="/posts/hexo/butterfly/04" title="Butterfly 主题配置文件（二）">Butterfly 主题配置文件（二）</a></li><li><a href="/posts/hexo/butterfly/05" title="Butterfly 主题配置文件（三）">Butterfly 主题配置文件（三）</a></li><li><a href="/posts/hexo/butterfly/06" title="Butterfly 主题自带美化效果">Butterfly 主题自带美化效果</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 框架 + Butterfly 主题打造个人博客</title>
      <link href="/posts/hexo/butterfly/01.html"/>
      <url>/posts/hexo/butterfly/01.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>一、安装 Node.js</h1><h2 id="1-1-下载-node-js-安装包">1.1 下载 Node.js 安装包</h2><ul><li><p>官网下载地址：<a href="https://nodejs.cn/download/">https://nodejs.cn/download/</a></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/01.png" width=666/></div></li></ul><h2 id="1-2-安装-node-js">1.2 安装 Node.js</h2><ul><li><p>双击 <code>msi</code> 文件，一路 <code>Next</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/02.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/03.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/04.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/05.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/06.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/07.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/08.png" width=399/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/09.png" width=399/></div></li></ul><h2 id="1-3-查看-node-js-是否安装成功">1.3 查看 Node.js 是否安装成功</h2><ul><li><p><code>node -v</code></p></li><li><p><code>npm -v</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/10.png" width=333/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/11.png" width=333/></div></li></ul><h2 id="1-4-配置-node-js-环境变量">1.4 配置 Node.js 环境变量</h2><ul><li><p>当不配置 <code>Node.js</code> 环境变量，在使用命令安装 <code>node.js</code> 全局模块时（例：<code>npm install -g hexo</code>），会默认安装到路径 <code>C:\Users\DONG\AppData\Roaming\npm</code> 中，缓存默认存放在 <code>C:\Users\DONG\AppData\Local\npm-cache</code>。</p></li><li><p>因此，需要配置 <strong>全局模块安装路径</strong> <code>node_global</code> 和 <strong>缓存路径</strong> <code>node_cache</code>。</p><ul><li><p>新建文件夹 <code>node_global</code> 和 <code>node_cache</code>。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/12.png" width=500/></div></li><li><p>设置全局模块安装路径和缓存路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置全局模块安装路径，默认 C:\Users\DONG\AppData\Roaming\npm</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\Software\nodejs\node_global&quot;</span></span><br><span class="line"><span class="comment"># 设置全局缓存存放路径，默认 C:\Users\DONG\AppData\Local\npm-cache</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\Software\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/13.png" width=500/></div></li><li><p>配置环境变量：</p><ul><li><p>新建一个名为 <code>NODE_PATH</code> 的 <strong>系统变量</strong>，值为全局模块安装路径 + <code>\node_modules</code>（<code>D:\Software\nodejs\node_global\node_modules</code>）</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/14.png" width=520/></div></li><li><p>修改名为 <code>Path</code> 的 <strong>用户变量</strong>：将 <code>npm</code> 的路径 <code>C:\Users\DONG\AppData\Roaming\npm</code> 改为 <code>D:\Software\nodejs\node_global</code>。</p></li><li><p>在 <strong>用户变量</strong> <code>Path</code> 中新建一个 <code>%NODE_PATH%</code> 变量。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/15.png" width=500/></div></li></ul></li></ul></li><li><p>测试环境变量是否配置成功：</p><ul><li><p><code>npm install -g npm</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/16.png" width=500/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/17.png" width=500/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/18.png" width=399/></div></li></ul></li></ul><h2 id="1-5-npm-配置国内源">1.5 npm 配置国内源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更换 npm 源为国内淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h2 id="1-6-npm-配置文件">1.6 npm 配置文件</h2><ul><li><p><code>npm</code> 全局配置文件（<code>.npmrc</code>）默认位于 <code>C:\Users\用户名</code>。</p></li><li><p><code>npm</code> 内置配置文件（<code>.npmrc</code>）位于 <code>C:\Program Files\nodejs\node_modules\npm</code>。</p></li></ul><h2 id="1-7-npm-install-安装的四种方法">1.7 npm install 安装的四种方法</h2><ul><li><p><code>npm install moduleName</code>：将模块安装到 <strong>当前项目</strong> 的 <code>node_modules</code> 目录中。</p><ul><li><p><code>npm 5.0.0</code> 之前版本不会将模块依赖写入 <code>package.json</code> 文件的 <code>devDependencies</code> 或 <code>dependencies</code> 节点。</p></li><li><p>从 <code>npm 5.0.0</code> 开始，模块依赖写入到运行时依赖（<code>dependencies</code>）中，因此可以不再添加 <code>--save</code> 选项。</p></li><li><p>运行 <code>npm install</code> 初始化项目时不会下载模块 <code>moduleName</code>。</p></li></ul></li><li><p><code>npm install moduleName -g</code>：将模块安装到 <strong>全局</strong>，能够在本机的所有目录中使用。</p><ul><li><p>不会在当前项目的 <code>node_modules</code> 目录中保存模块。</p></li><li><p>具体安装到磁盘哪个位置，可以使用 <code>npm config get prefix</code> 查看。</p></li><li><p>不会将模块依赖写入 <code>devDependencies</code> 或 <code>dependencies</code> 节点。</p></li><li><p>运行 <code>npm install</code> 初始化项目时不会下载模块 <code>moduleName</code>。</p></li></ul></li><li><p><code>npm install moduleName --save</code>：</p><ul><li><p><code>--save</code> 或 <code>-S</code> 的意思是将模块安装到 <strong>当前项目</strong> 的 <code>node_modules</code> 目录中。</p></li><li><p>会将模块依赖写入 <code>package.json</code> 文件的运行时依赖（<code>dependencies</code>）中。</p></li><li><p>运行 <code>npm install</code> 初始化项目时，会将模块 <code>moduleName</code> 自动下载到项目的 <code>node_modules</code> 目录中。</p></li><li><p>运行 <code>npm install --production</code> 或注明 <code>NODE_ENV</code> 变量值为 <code>production</code> 时，<strong>会自动下载模块</strong> 到 <code>node_modules</code> 目录中。</p></li></ul></li><li><p><code>npm install moduleName --save-dev</code>：</p><ul><li><p><code>--save-dev</code> 或 <code>-D</code> 的意思是将模块安装到 <strong>当前项目</strong> 的 <code>node_modules</code> 目录中。</p></li><li><p>会将模块依赖写入 <code>package.json</code> 文件的开发时依赖（<code>devDependencies</code>）中。</p></li><li><p>运行 <code>npm install</code> 初始化项目时，会将模块 <code>moduleName</code> 自动下载到项目的 <code>node_modules</code> 目录中。</p></li><li><p>运行 <code>npm install --production</code> 或注明 <code>NODE_ENV</code> 变量值为 <code>production</code> 时，<strong>不会自动下载模块</strong> 到 <code>node_modules</code> 目录中。</p></li></ul></li></ul><h1>二、安装 Hexo</h1><h2 id="2-1-全局安装-hexo">2.1 全局安装 Hexo</h2><ul><li><p>使用命令进行全局安装 <code>hexo</code>：<code>npm install -g hexo-cli</code></p></li><li><p>报错</p><ul><li><p>错误：</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/19.png" width=666/></div></li><li><p>原因：<code>CERT_HAS_EXPIRED</code> 是一个由 <code>node.js</code> 和 <code>npm</code> 抛出的错误，表示你正在尝试访问的服务器的 <code>SSL</code> 证书已经过期。</p></li><li><p>解决：</p><ul><li>取消 <code>ssl</code> 验证：<code>npm config set strict-ssl false</code></li></ul></li></ul></li><li><p>查看安装的 <code>hexo</code> 版本：<code>hexo -v</code></p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/20.png" width=366/></div></li></ul><h2 id="2-2-npm-安装模块的流程">2.2 npm 安装模块的流程</h2><h3 id="2-2-1-查找-npm-的配置信息">2.2.1 查找 npm 的配置信息</h3><ul><li><p>执行 <code>npm install</code> 命令后，<code>npm</code> 会去查找 <code>npm</code> 的配置信息（例：<code>npm</code> 源）。</p><ul><li><p><code>npm</code> 先在 <strong>当前项目</strong> 中查找 <code>.npmrc</code> 文件，没找到会查找 <strong>全局配置</strong> 的 <code>.npmrc</code>，还没找到会使用 <code>npm</code> <strong>内置</strong> 的 <code>.npmrc</code> 文件。</p></li><li><p>优先级：项目级的 <code>.npmrc</code> 文件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 用户级的 <code>.npmrc</code> 文件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 全局级的 <code>.npmrc</code> 文件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>npm</code> 内置的 <code>.npmrc</code> 文件。</p></li></ul></li></ul><h3 id="2-2-2-构建依赖树">2.2.2 构建依赖树</h3><ul><li><p>获取 <code>.npmrc</code> 配置文件后，开始构建依赖树。先检查当前项目中是否存在 <code>package-lock.json</code> 文件。</p><ul><li><p>如果存在，会有两种情况。</p><ul><li><p>当 <code>package.json</code> 声明的依赖版本和 <code>package-lock.json</code> 版本兼容，则按照 <code>package-lock.json</code> 安装。</p></li><li><p>当 <code>package.json</code> 声明的依赖版本和 <code>package-lock.json</code> 版本不兼容，按照 <code>package.json</code> 安装，并更新 <code>package-lock.json</code>。</p></li></ul></li><li><p>如果不存在，则直接使用 <code>package.json</code> 中的信息生成依赖树并生成 <code>package-lock.json</code> 文件。</p></li></ul></li></ul><h3 id="2-2-3-下载完整的依赖资源">2.2.3 下载完整的依赖资源</h3><ul><li><p>构建依赖树后，可以根据依赖树下载完整的依赖资源。</p><ul><li><p>在下载之前，会先检查缓存目录（默认  <code>C:\Users\DONG\AppData\Local\npm-cache</code>）中是否存在缓存资源。</p><ul><li><p>如果存在缓存资源，则直接将缓存资源解压到 <code>node_modules</code> 中。</p></li><li><p>如果不存在缓存资源，则先将 <code>npm</code> 远程仓库（默认为 <code>npmjs.com</code>）中的包下载至本地，然后进行包的完整性校验，校验通过后将其添加到缓存目录并解压到 <code>node_modules</code> 中。</p></li></ul></li><li><p>通过 <code>npm config get cache</code> 可以查看缓存目录。</p></li></ul></li><li><p>缓存的包存放在缓存目录下的 <code>_cacache</code> 中，该目录下的 <code>content-v2</code> 用于缓存压缩文件 <code>tar</code>，<code>index-v5</code> 用于存储这个压缩包的 <code>hash</code>。</p><ul><li><code>npm</code> 在执行安装时，可以根据 <code>package-lock.json</code> 中存储的 <code>integrity</code>、<code>version</code>、<code>name</code> 生成一个唯一的 <code>key</code> 对应到 <code>index-v5</code> 目录下的缓存记录，从而找到 <code>tar</code> 包的 <code>hash</code>，然后根据 <code>hash</code> 再去 <code>content-v2</code> 中查找缓存的 <code>tar</code> 包直接使用。</li></ul></li></ul><h3 id="2-2-4-安装">2.2.4 安装</h3><ul><li>解压后，<code>npm</code> 会通过执行模块中的 <code>preinstall</code> 脚本（如果存在）进行预处理操作。如果没有 <code>preinstall</code> 脚本，或 <code>preinstall</code> 脚本执行成功，会执行包的 <code>main</code> 脚本（如果有的话），这个脚本通常用于执行一些初始化代码，例如引入模块、输出日志等。</li></ul><h1>三、初始化 Hexo 博客</h1><h2 id="3-1-初始化过程">3.1 初始化过程</h2><ul><li><p>创建博客文件夹 <code>blog</code>。</p></li><li><p>在 <code>blog</code> 文件夹下使用 <code>hexo init 博客名字</code> 初始化博客目录。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/21.png" width=500/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/22.png" width=500/></div></li><li><p>进入 <code>Mr.DONG</code> 文件夹，并使用 <code>npm install</code> 安装依赖。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/23.png" width=399/></div></li><li><p>使用 <code>hexo generate</code>（<code>hexo g</code>）在当前目录下生成一个名为 <code>public</code> 的文件夹。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/24.png" width=500/></div><ul><li><p><code>public</code> 文件夹内容：将 <code>source</code> 文件夹中的 <code>Markdown</code> 文档，转换成 <code>index.html</code>。再结合主题进行渲染，就是我们最终看到的博客。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/25.png" width=599/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/26.png" width=500/></div></li></ul></li><li><p>使用 <code>hexo server</code>（<code>hexo s</code>）启动本地 <code>web</code> 服务，在浏览器打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可预览 <code>hexo</code> 博客。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/27.png" width=555/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/28.png" width=799/></div></li></ul><h2 id="3-2-博客目录">3.2 博客目录</h2>  <div align=center>    <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/22.png" width=666/>  </div><h3 id="3-2-1-概述">3.2.1 概述</h3><ul><li><p>初始化的博客目录结构如下：</p><ul><li><p><code>_config.yml</code>：全局配置文件，可以配置博客的名称、副标题、描述、作者、语言、主题等。</p></li><li><p><code>package.json</code>：用来描述项目及项目所依赖的模块信息（只记录主模块）。</p></li><li><p><code>package-lock.json</code>：锁定所有模块的版本号，包括主模块和所有依赖子模块。</p></li><li><p><code>db.json</code>：执行 <code>hexo g</code> 时与 <code>public</code> 文件夹一同生成的缓存文件。使用 <code>hexo clean</code> 命令会清除该文件。</p></li><li><p><code>scaffolds</code>：模版文件夹。</p></li><li><p><code>source</code>：存放用户资源（文章、图片），有 <code>_drafts</code> 和 <code>_posts</code> 两个子目录。</p></li><li><p><code>_posts</code>：默认 <code>source</code> 文件夹下只有一个 <code>_post</code> 文件夹，存放文章的 <code>markdown</code> 源文件。</p></li><li><p><code>_discarded</code>：删除的博客存放在这里。</p></li><li><p><code>categories</code>：分类文件夹，有 <code>index.md</code> 文件，由 <code>hexo new page categories</code> 生成。</p></li><li><p><code>tags</code>：由 <code>hexo new page tags</code> 生成的标签文件夹，内自动生成 <code>index.md</code>。</p></li><li><p><code>_drafts</code>：由 <code>hexo new draft &quot;草稿名字&quot;</code> 创建一篇草稿，默认放到 <code>_drafts</code> 目录下。</p><ul><li>该功能正好提供了一个私密空间（文章仅自己可见），可以利用该特性保留一下不想删除但又不想发布在博客上的文章。</li></ul></li><li><p><code>node_modules</code>：存放 <code>hexo</code> 扩展模块的文件夹。</p></li><li><p><code>themes</code>：主题文件夹。该文件下，每一个子文件夹就是一个主题。</p></li></ul></li></ul><h3 id="3-2-2-package-json">3.2.2 package.json</h3><ul><li><p>在使用 <code>npm init</code>（<code>hexo init</code>）初始化项目时会自动生成。</p></li><li><p>版本格式：<code>major</code>.<code>minor</code>.<code>patch</code>，依次为主版本号、次版本号、补丁版本号。</p><ul><li><p><code>major</code>（主版本号）：发生重大变化时修改。包括但不限于新增特性、修改机制、删除功能， 一般不兼容上一个主版本号。</p></li><li><p><code>minor</code>（次版本号）：发生一些小变化（例：新增、修改功能等）时修改，必须是向前兼容的，意味着不能直接删除某项功能。</p></li><li><p><code>patch</code>（补丁版本号）：仅修复或调整一些小问题时，可以修改补丁版本号。</p></li></ul></li><li><p>版本符号：</p><ul><li><p><code>&gt;</code>：大于某个版本。例：<code>&gt;7.0.0</code> 表示大于 <code>7.0.0</code> 版本。</p></li><li><p><code>&gt;=</code>：大于等于某个版本。例：<code>&gt;=7.0.0</code> 表示大于等于 <code>7.0.0</code> 版本。</p></li><li><p><code>&lt;</code>：小于某个版本。例：<code>&lt;7.0.0</code> 表示小于 <code>7.0.0</code> 版本。</p></li><li><p><code>&lt;=</code>：小于等于某个版本。例：<code>&lt;=7.0.0</code> 表示小于等于 <code>7.0.0</code> 版本。</p></li><li><p><code>-</code>：介于两个版本之间。例：<code>5.0.0 - 7.0.0</code> 表示大于等于 <code>5.0.0</code> 版本，小于等于 <code>7.0.0</code> 版本。</p></li><li><p><code>||</code>：表示满足多个条件。例：<code>7.0.0||&gt;5.0.0</code> 表示 <code>7.0.0</code> 版本或大于 <code>5.0.0</code> 版本。</p></li><li><p><code>x</code>：不固定的版本号。例：<code>5.3.x</code> 只要保证主版本号是 <code>5</code>，次版本号是 <code>3</code> 即可。</p></li><li><p><code>~</code>：补丁版本号可增。例：<code>~5.3.4</code> 保证主版本号是 <code>5</code>，次版本号是 <code>3</code>，补丁版本号大于等于 <code>4</code>。</p></li><li><p><code>^</code>：次版本号和补丁版本号可增。例：<code>^5.3.4</code> 保证主版本号是 <code>5</code>，次版本号可以大于等于 <code>3</code>，补丁版本号可以大于等于 <code>4</code>。</p></li><li><p><code>*</code>：最新版本。例：<code>*</code> 始终安装最新版本。</p></li><li><p><code>无符号</code>：版本号之前不带任何标记表示必须依赖这个版本。</p></li></ul></li></ul><h3 id="3-2-3-package-lock-json">3.2.3 package-lock.json</h3><ul><li><p><code>npm install</code> 执行后，会生成一个 <code>node_modules</code> 树，在理想情况下， 希望对于同一个 <code>package.json</code>，总是生成完全相同的 <code>node_modules</code> 树。但在多数情况下，<code>npm</code> 无法做到这一点。因为 <code>package.json</code> 只能指定要安装的依赖的版本，但不能指定安装的依赖的依赖的版本。</p></li><li><p><code>package-lock.json</code> 的产生就是来对整个依赖树进行版本固定的（锁死）。</p></li><li><p><code>package-lock.json</code> 会在 <code>npm</code> 更改 <code>node_modules</code> 树（<code>npm install</code>）或编辑 <code>package.json</code> 时自动生成。</p></li><li><p><code>npm 5</code> 之前的版本没有 <code>package-lock.json</code> 这个文件，当安装模块并保存依赖信息时，需要加上 <code>--save</code> 参数。</p></li><li><p><code>npm 5</code> 之后的版本加入了 <code>package-lock.json</code> 文件。当安装模块时，无需添加 <code>--save</code> 参数，就会自动保存依赖信息，且会生成或更新 <code>package-lock.json</code> 文件。</p></li></ul><h1>四、部署至 Github Pages</h1><h2 id="4-1-创建仓库">4.1 创建仓库</h2><ul><li><p>在 <code>GitHub</code> 上创建一个新的仓库用于保存我们使用 <code>hexo generate</code>（<code>hexo g</code>）生成的网页。</p><ul><li><p>仓库名的格式必须为 <code>&lt;用户名&gt;.github.io</code>，然后点击 <code>Create repository</code>。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/29.png" width=666/></div></li></ul></li></ul><h2 id="4-2-安装依赖">4.2 安装依赖</h2><ul><li><p>进入 <code>Mr.DONG</code> 文件夹，并使用 <code>npm install hexo-deployer-git --save</code> 安装依赖。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/30.png" width=399/></div></li><li><p><code>--save</code> 的意思是将模块安装到项目目录下，并在 <code>package</code> 文件的 <code>dependencies</code> 节点写入依赖。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/31.png" width=266/></div></li></ul><h2 id="4-3-修改-config-yml-文件">4.3 修改 _config.yml 文件</h2><ul><li><p>修改 <code>_config.yml</code> 文件中的 <code>deploy</code> 部分，<code>type</code> 填写 <code>git</code>，<code>repository</code> 填写仓库地址 <code>https://github.com/xindong2020/xindong2020.github.io</code>，分支 <code>branch</code> 选择 <code>main</code>。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/32.png" width=500/></div></li><li><p>依次执行命令 <code>hexo clean</code>、<code>hexo generate</code> 和 <code>hexo deploy</code>。</p><ul><li>当出现警告 <code>LF will be replaced by CRLF the next time Git touches it</code> 时，执行命令 <code>git config --global core.autocrlf false</code>。</li></ul><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/33.png" width=555/></div><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/34.png" width=555/></div></li></ul><h2 id="4-4-预览网站">4.4 预览网站</h2><ul><li><p>在浏览器中访问 <a href="https://xindong2020.github.io">https://xindong2020.github.io</a>，即可预览网站。</p><div align=center>  <img src="https://fastly.jsdelivr.net/gh/xindong2020/Mr.DONG_PicBed/Hexo/Butterfly/01/35.png" width=799/></div></li></ul><ol class="series-items"><li><a href="/posts/hexo/butterfly/01" title="Hexo 框架 + Butterfly 主题打造个人博客">Hexo 框架 + Butterfly 主题打造个人博客</a></li><li><a href="/posts/hexo/butterfly/02" title="Hexo 框架全局配置文件">Hexo 框架全局配置文件</a></li><li><a href="/posts/hexo/butterfly/03" title="Butterfly 主题配置文件（一）">Butterfly 主题配置文件（一）</a></li><li><a href="/posts/hexo/butterfly/04" title="Butterfly 主题配置文件（二）">Butterfly 主题配置文件（二）</a></li><li><a href="/posts/hexo/butterfly/05" title="Butterfly 主题配置文件（三）">Butterfly 主题配置文件（三）</a></li><li><a href="/posts/hexo/butterfly/06" title="Butterfly 主题自带美化效果">Butterfly 主题自带美化效果</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站</title>
      <link href="/posts/hexo/butterfly/index.html"/>
      <url>/posts/hexo/butterfly/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="01.html">01.Hexo 框架 + Butterfly 主题打造个人博客</a></li><li><a href="02.html">02.Hexo 框架全局配置文件</a></li><li><a href="03.html">03.Butterfly 主题配置文件（一）</a></li><li><a href="04.html">04.Butterfly 主题配置文件（二）</a></li><li><a href="05.html">05.Butterfly 主题配置文件（三）</a></li><li><a href="06.html">06.Butterfly 主题自带美化效果</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 正则表达式</title>
      <link href="/posts/Python/Python20.html"/>
      <url>/posts/Python/Python20.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-正则表达式">一、正则表达式</h2><h3 id="1-1-概述">1.1 概述</h3><ul><li>正则表达式，又称规则表达式（<code>Regular Expression</code>），一个正则表达式通常被称为一个模式（<code>pattern</code>），是用来描述、匹配某个 <strong>句法规则</strong> 的 <strong>字符串</strong>，常被用来检索、替换那些符合某个模式（规则）的文本。</li><li>执行匹配时，是字符串匹配正则表达式，而不是正则表达式匹配字符串。</li><li>正则表达式匹配完全了，才算是一次成功的匹配。</li><li>因为正则表达式和 <code>Python</code> 字符串都使用反斜杠字符（<code>\</code>）来转义，有时就需要使用更多的反斜杠才能达到想要的效果，而这很麻烦，所以建议在书写正则表达式时，使用原始字符串。<ul><li>注：在正则表达式中，四个反斜杠（<code>\\\\</code>）才会表示一个反斜杠（<code>\</code>）。<ul><li>解析：<code>Python</code> 字符串中反斜杠需要转义，因此使用两个反斜杠才会表示一个反斜杠，而在正则表达式的 <code>compile</code> 方法中，反斜杠同样需要进行转义，因此四个反斜杠才会表示一个反斜杠。</li></ul></li></ul></li></ul><h3 id="1-2-语法">1.2 语法</h3><ul><li>完整的正则表达式由两种字符构成：<strong>特殊字符</strong>（元字符）和 <strong>普通字符</strong>。</li></ul><h4 id="1-2-1-普通字符">1.2.1 普通字符</h4><ul><li>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。</li><li><strong>注</strong>：<strong>普通字符只会和自身匹配</strong>。</li></ul><h4 id="1-2-2-特殊字符-元字符">1.2.2 特殊字符（元字符）</h4><ul><li>一共含有 <code>11</code> 个特殊字符：<code>.</code>, <code>^</code>, <code>$</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;&#125;</code>, <code>[]</code>, <code>\</code>, <code>|</code>, <code>()</code></li></ul><h5 id="1-基本元字符">（1）基本元字符 . | [ ] \ ( )</h5><ul><li><p><code>.</code>：</p><ul><li><p>匹配除了换行符 <code>\n</code>、<code>\r</code> 之外的任何单字符。</p></li><li><p>当 <code>compile</code> 方法的 <code>flags</code> 参数设置为 <code>re.S</code> / <code>re.DOTALL</code> 时，<code>.</code> 可以匹配包括换行符在内的所有字符，没有设置时 <code>.</code> 不能匹配换行符。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;.&quot;</span>)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;abc&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;a&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;9bc&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;9&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;@bc&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;@&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;.bc&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;.&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;\tbc&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;\t&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;\nbc&quot;</span>))  <span class="comment"># None</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;.&quot;</span>, flags=re.DOTALL)</span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;\nbc&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;\n&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>|</code>：逻辑或操作符，任意个正则表达式都可以使用 <code>|</code> 连接，例：<code>A|B</code> 表示匹配正则表达式 <code>A</code> 或 <code>B</code>，一旦有一个先匹配成功，另外的就不会再进行匹配。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;d|e|b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;abc&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(1, 2), match=&#x27;b&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;aebcd&quot;</span>))    <span class="comment"># &lt;re.Match object; span=(1, 2), match=&#x27;e&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>[]</code>：表示匹配在 <code>[]</code> 中的字符，并且只匹配一次。例：<code>[(a,b,c)]</code>，表示 <code>5</code> 个字符 <code>(</code>、<code>a</code>、<code>b</code>、<code>c</code>、<code>)</code> 的集合。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[(a,c,e)]&quot;</span>)</span><br><span class="line"><span class="comment"># [&#x27;(&#x27;, &#x27;a&#x27;, &#x27;)&#x27;, &#x27;,&#x27;, &#x27;(&#x27;, &#x27;c&#x27;, &#x27;)&#x27;, &#x27;,&#x27;, &#x27;(&#x27;, &#x27;e&#x27;, &#x27;)&#x27;, &#x27;,&#x27;, &#x27;(&#x27;, &#x27;)&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;(ab),(cd),(ed),(gh)&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>可以在 <code>[]</code> 中使用 <code>-</code> 表示一个区间。例：<code>[0-9]</code> 表示 <code>0 - 9</code> 中的一个数字。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a-y]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;ahzyqAHZYQ&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;h&#x27;, &#x27;y&#x27;, &#x27;q&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[0-5][A-Y]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a0hzyq125A6HZYQ&quot;</span>)) <span class="comment"># [&#x27;5A&#x27;]</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[0-590]&quot;</span>) <span class="comment"># 匹配的是 [0-5]|9|0</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a0hzyq125A609HZ70YQ&quot;</span>)) <span class="comment"># [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;5&#x27;, &#x27;0&#x27;, &#x27;9&#x27;, &#x27;0&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>[]</code> 中首字符是 <code>^</code> 代表非，表示匹配的字符不在 <code>[]</code> 中。<code>^</code> 如果不在字符集首位，就没有特殊含义。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[^5]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;5a b512!5&quot;</span>))   <span class="comment"># [&#x27;a&#x27;, &#x27; &#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;!&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[^^]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;5a^b512!5&quot;</span>))   <span class="comment"># [&#x27;5&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;5&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;!&#x27;, &#x27;5&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>如果要匹配 <code>[</code> 和 <code>]</code>，可以在它之前加上反斜杠。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\[\]]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;[]&quot;</span>))  <span class="comment"># [&#x27;[&#x27;, &#x27;]&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>特殊字符写在 <code>[]</code> 中会被当成普通字符来匹配。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[.+]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abc&quot;</span>)) <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a.b+c.d+&quot;</span>))    <span class="comment"># [&#x27;.&#x27;, &#x27;+&#x27;, &#x27;.&#x27;, &#x27;+&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>特殊序列，例：<code>\d</code>、<code>\s</code>、<code>\w</code>，写在 <code>[]</code> 中可以被接受。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\d]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a1234b&quot;</span>))  <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\d+]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a1234b+&quot;</span>)) <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;+&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a\sb]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;adb a bc&quot;</span>))    <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27; &#x27;, &#x27;a&#x27;, &#x27; &#x27;, &#x27;b&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\w]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;adb_a b!c&quot;</span>))   <span class="comment"># [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;_&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>\</code>：表示对下一个字符进行转义。例：<code>\.</code> 表示对 <code>.</code> 进行转义，匹配点 <code>.</code> 这个符号，而不是匹配除换行符之外的任何单字符了。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 只匹配*号</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;*&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;*&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 只匹配+号</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;+&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;+&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 只匹配?号</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;?&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;?&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>特殊序列</strong>：<code>\number</code>、<code>\d</code>、<code>\D</code>、<code>\b</code>、<code>\B</code>、<code>\s</code>、<code>\S</code>、<code>\w</code>、<code>\W</code>、<code>\A</code>、<code>\Z</code> 。</p><ul><li><p><code>\number</code>：与 <code>(...)</code> 捕获分组搭配使用，表示按照数字 <code>number</code> 指定的分组里面的正则表达式进行匹配（每个括号是一个子组，子组从 <code>1</code> 开始编号），在 <code>[</code> 和 <code>]</code> 字符集内，任何数字转义都被看作是字符。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># \1匹配的内容和第1组一定一样</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;(.+) \1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;ab abc&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(0, 5), match=&#x27;ab ab&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;5 5&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(0, 3), match=&#x27;5 5&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 两个组匹配的内容不一定一样</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;(.+) (.+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;ab abc&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(0, 6), match=&#x27;ab abc&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;5 5&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(0, 3), match=&#x27;5 5&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\d</code>：匹配任意一个数字字符，等价于 <code>[0-9]</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;a1234b&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(1, 2), match=&#x27;1&#x27;&gt;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;a1234b&quot;</span>))   <span class="comment"># &lt;re.Match object; span=(1, 5), match=&#x27;1234&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\D</code>：匹配任意一个非数字字符，等价于 <code>[^0-9]</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\D&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;ab1234c&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(0, 1), match=&#x27;a&#x27;&gt;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\D+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;ab1234c&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(0, 2), match=&#x27;ab&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\b</code>：匹配单词的边界（开头或结尾），即字与空格、符号之间的位置。例：<code>er\b</code> 可以匹配 <code>never say goodbye</code> 中的 <code>er</code>，但不匹配 <code>everyday</code> 中的 <code>er</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;er\b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;never&quot;</span>))    <span class="comment"># &lt;re.Match object; span=(3, 5), match=&#x27;er&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;verb&quot;</span>))     <span class="comment"># None</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\ba\b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;I have a dog&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(7, 8), match=&#x27;a&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;I have a+ dog&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(7, 8), match=&#x27;a&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;I have a- dog&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(7, 8), match=&#x27;a&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;I have a？ dog&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(7, 8), match=&#x27;a&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\B</code>：匹配非单词边界。例：<code>er\B</code> 可以匹配 <code>everyday</code> 中的 <code>er</code>，但不匹配 <code>never say goodbye</code> 中的 <code>er</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;er\B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;never&quot;</span>))    <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;verb&quot;</span>))     <span class="comment"># &lt;re.Match object; span=(1, 3), match=&#x27;er&#x27;&gt;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\Ba\B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;I have a dog&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(3, 4), match=&#x27;a&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\s</code>：匹配任何一个空白符。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;a\sb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;adb a bc&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(4, 7), match=&#x27;a b&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\S</code>：匹配任何一个非空白符。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;a\Sb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;adb a bc&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(0, 3), match=&#x27;adb&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\w</code>：匹配一个字母或一个数字或一个下划线，等价于 <code>[a-zA-Z0-9_]</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;a\wb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;adba9ba_ba b&quot;</span>))    <span class="comment"># [&#x27;adb&#x27;, &#x27;a9b&#x27;, &#x27;a_b&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>\W</code>：匹配一个非字母非数字非下划线的字符，等价于 <code>[^a-zA-Z0-9_]</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;a\Wb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;adba9ba_ba b&quot;</span>))    <span class="comment"># [&#x27;a b&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><code>(...)</code>：表示捕获分组，匹配括号内的任意正则表达式，并标识出该分组的开始和结尾。</p><ul><li><p>组 <code>0</code> 表示整个正则表达式，所以 <code>Match</code> 的对象方法都将组 <code>0</code> 作为默认参数。</p></li><li><p>子组从左到右编号，从 <code>1</code> 开始编号。</p></li><li><p><strong>注</strong>：<strong>就算是做了捕获分组</strong>，<strong>在执行匹配时</strong>，<strong>也需要优先考虑</strong> <code>0</code> <strong>组匹配</strong>，<strong>然后再考虑子组在</strong> <code>0</code> <strong>组匹配的过程中所捕获的内容</strong>。</p></li><li><p>对捕获分组使用数量元字符，相当于有 <code>n</code> 个相同的子组，<code>findall</code> 等方法获取时仅显示最后一个获取内容。</p></li><li><p>分组匹配的内容可以在之后其他分组用 <code>\number</code> 进行再次引用。</p></li><li><p>要匹配字符 <code>(</code> 或 <code>)</code>，可以使用 <code>\(</code> 或 <code>\)</code>，或者把它们包含在字符集里：<code>[(]</code>，<code>[)]</code> 。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(.+)a(.+)e&quot;</span>)</span><br><span class="line">m = p.<span class="keyword">match</span>(<span class="string">&quot;babacdefg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m)    <span class="comment"># &lt;re.Match object; span=(0, 7), match=&#x27;babacde&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">1</span>), m.group(<span class="number">2</span>))   <span class="comment"># ab cd</span></span><br><span class="line"><span class="built_in">print</span>(m.span(<span class="number">1</span>), m.span(<span class="number">2</span>)) <span class="comment"># (1, 3) (4, 6)</span></span><br><span class="line"><span class="built_in">print</span>(m.start(<span class="number">1</span>), m.end(<span class="number">1</span>)) <span class="comment"># 1 3</span></span><br><span class="line"><span class="built_in">print</span>(m.start(<span class="number">2</span>), m.end(<span class="number">2</span>)) <span class="comment"># 4 6</span></span><br><span class="line"><span class="comment"># 多个分组，返回元组列表</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;babacdefg&quot;</span>))   <span class="comment"># [(&#x27;ab&#x27;, &#x27;cd&#x27;)]</span></span><br><span class="line"><span class="comment"># 引用第1组匹配的内容</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(.+)a(\1)e&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;babaabefg&quot;</span>))   <span class="comment"># [(&#x27;ab&#x27;, &#x27;ab&#x27;)]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?:...)</code>：非捕获分组，并不产生子组，所匹配的子字符串不能在执行匹配后被获取或是之后在模式中被引用。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(?:.+)a(?:.+)e&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;babacdefg&quot;</span>)) <span class="comment"># &lt;re.Match object; span=(0, 7), match=&#x27;babacde&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-数量元字符">（2）数量元字符 { } * + ?</h5><ul><li><p><strong>贪婪匹配</strong>：正则表达式通常的行为是（在使整个表达式能得到匹配的前提下）匹配 <strong>尽可能多</strong> 的字符。例：<code>a.*b</code>，它将会匹配 <strong>最长</strong> 的以 <code>a</code> 开始，以 <code>b</code> 结束的字符串。如果用它来搜索 <code>aabab</code> 的话，它会匹配整个字符串 <code>aabab</code>。</p><ul><li><p><code>&#123;n&#125;</code>：匹配前面的子表达式 <strong>确定的</strong> <code>n</code> <strong>次</strong>，<code>n</code> 是一个非负整数。例：<code>o&#123;2&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但是能匹配 <code>food</code> 中的两个 <code>o</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab&#123;2&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abc&quot;</span>)) <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbc&quot;</span>))    <span class="comment"># [&#x27;abb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;abb&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&#123;n,m&#125;</code>：匹配前面的子表达式最少 <code>n</code> 次且最多 <code>m</code> 次，<code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n &lt;= m</code>。例：<code>o&#123;1,3&#125;</code> 将匹配 <code>fooooood</code> 中的前三个 <code>o</code>。</p><ul><li><p><strong>注</strong>：<strong>在逗号和两个数之间不能有空格</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab&#123;2,4&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abc&quot;</span>)) <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbc&quot;</span>))    <span class="comment"># [&#x27;abb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;abbb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbbc&quot;</span>))  <span class="comment"># [&#x27;abbbb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbbbc&quot;</span>)) <span class="comment"># [&#x27;abbbb&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&#123;n,&#125;</code>：匹配前面的子表达式 <code>n</code> 次或 <strong>多次</strong>，<code>n</code> 是一个非负整数。例：<code>o&#123;2,&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但是能匹配 <code>foooood</code> 中的所有 <code>o</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab&#123;2,&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abc&quot;</span>)) <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbc&quot;</span>))    <span class="comment"># [&#x27;abb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;abbb&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&#123;,m&#125;</code>：匹配前面的子表达式最少 <code>0</code> 次且最多 <code>m</code> 次，<code>n</code> 是一个非负整数。例：<code>o&#123;2,&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但是能匹配 <code>foooood</code> 中的所有 <code>o</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab&#123;,3&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abc&quot;</span>)) <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbc&quot;</span>))    <span class="comment"># [&#x27;abb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;abbb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbbc&quot;</span>))  <span class="comment"># [&#x27;abbb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbbbc&quot;</span>)) <span class="comment"># [&#x27;abbb&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>*</code>：匹配前面的子表达式 <strong>零次</strong> 或 <strong>多次</strong>，等价于 <code>&#123;0,&#125;</code>。例：<code>zo*</code> / <code>zo&#123;0,&#125;</code> 能匹配 <code>z</code>、<code>zo</code>、<code>zoo</code> 等。<code>*</code> ，即 <code>zo</code> 等价于 <code>zo&#123;0,&#125;</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a&quot;</span>))   <span class="comment"># [&#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;ab&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abb&quot;</span>)) <span class="comment"># [&#x27;abb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;abbb&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>+</code>：匹配前面的子表达式 <strong>一次</strong> 或 <strong>多次</strong>，等价于 <code>&#123;1,&#125;</code>。例：<code>zo+</code> / <code>zo&#123;1,&#125;</code> 能匹配 <code>zo</code>、<code>zoo</code> 等，但是不能匹配 <code>z</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a&quot;</span>))   <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;ab&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abb&quot;</span>)) <span class="comment"># [&#x27;abb&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;abbb&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>?</code>：匹配前面的子表达式 <strong>零次</strong> 或 <strong>一次</strong>，等价于 <code>&#123;0,1&#125;</code>。例：<code>do(es)?</code> / <code>do(es)&#123;0, 1&#125;</code> 可以匹配 “<code>do</code>” 、&quot;<code>does</code>&quot;、&quot;<code>dong</code>&quot;。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;a&quot;</span>))   <span class="comment"># [&#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;ab&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abb&quot;</span>)) <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbabbb&quot;</span>))    <span class="comment"># [&#x27;ab&#x27;, &#x27;ab&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>惰性匹配</strong>：惰性匹配也就是 <strong>匹配尽可能少</strong> 的字符，在能使整个表达式匹配成功的前提下使用最少的字符进行匹配。只要在贪婪匹配的元字符后面加上一个问号 <code>?</code> 即可变成惰性匹配元字符。例：<code>a.*b</code>，它将会匹配 <strong>最长</strong> 的以 <code>a</code> 开始，以 <code>b</code> 结束的字符串。如果用它来搜索 <code>aabab</code> 的话，它会匹配整个字符串 <code>aabab</code>。例：<code>a.*?b</code>，它将会匹配 <strong>最短</strong> 的以 <code>a</code> 开始，以 <code>b</code> 结束的字符串。如果用它来搜索 <code>aabab</code> 的话，它会匹配字符串 <code>aab</code>。</p><ul><li><p><code>*?</code>、<code>+?</code>、<code>??</code> 都是惰性匹配。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;.*&gt;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&#x27;&lt;a&gt; b &lt;c&gt;&#x27;</span>))   <span class="comment"># [&#x27;&lt;a&gt; b &lt;c&gt;&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;.*?&gt;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&#x27;&lt;a&gt; b &lt;c&gt;&#x27;</span>))   <span class="comment"># [&#x27;&lt;a&gt;&#x27;, &#x27;&lt;c&gt;&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab+?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abbbc&quot;</span>))   <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;ab??&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abc&quot;</span>)) <span class="comment"># [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="3-位置元字符">（3）位置元字符 ^ $</h5><ul><li><p><code>^</code>：匹配字符串开始的位置。</p><ul><li><p>如果 <code>compile</code> 方法的 <code>flags</code> 参数设置了多行属性 <code>re.M</code> 或 <code>re.MULTILINE</code>，<code>^</code> 也可以匹配 <code>\n</code> 或 <code>\r</code> <strong>之后</strong> 字符串开始的位置。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;^ab&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nabfg&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;^ab&quot;</span>, flags=re.MULTILINE)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nabfg&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;, &#x27;ab&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>\A</code> 也会匹配字符串开始的位置，与 <code>^</code> 区别在于， <code>MULTILINE</code> 模式下 <code>\A</code> 不能识别 <code>\n</code> 和 <code>\r</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\Aab&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nabfg&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\Aab&quot;</span>, flags=re.MULTILINE)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nabfg&quot;</span>))  <span class="comment"># [&#x27;ab&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;^&quot;</span>)</span><br><span class="line"><span class="comment"># 会找到一个（空的）匹配：在字符串的开头</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nabfg&quot;</span>))  <span class="comment"># [&#x27;&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;^&quot;</span>, flags=re.MULTILINE)</span><br><span class="line"><span class="comment"># 会找到两个（空的）匹配：一个在字符串的开头，一个在换行符之后</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nabfg&quot;</span>))  <span class="comment"># [&#x27;&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>$</code>：匹配字符串结尾换行符（<code>\n</code> 或 <code>\r</code>）前的位置。</p><ul><li><p>如果 <code>compile</code> 方法的 <code>flags</code> 参数设置了多行属性 <code>re.M</code> 或 <code>re.MULTILINE</code>，<code>^</code> 也可以匹配 <code>\n</code> 或 <code>\r</code> <strong>之前</strong> 字符串结尾的位置。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;cd$&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\n&quot;</span>))  <span class="comment"># [&#x27;cd&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;cd$&quot;</span>, flags=re.MULTILINE)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\nefcd&quot;</span>))  <span class="comment"># [&#x27;cd&#x27;, &#x27;cd&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;$&quot;</span>)</span><br><span class="line"><span class="comment"># 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\n&quot;</span>))  <span class="comment"># [&#x27;&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>\Z</code> 也会匹配输入字符串结尾的位置，与 <code>$</code> 区别在于，<code>MULTILINE</code> 模式下 <code>$</code> 不能识别 <code>\n</code> 或 <code>\r</code>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;cd\Z&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd&quot;</span>))    <span class="comment"># [&#x27;cd&#x27;]</span></span><br><span class="line"><span class="comment"># 结尾是&#x27;\n&#x27;，不是&#x27;cd&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\n&quot;</span>))  <span class="comment"># []</span></span><br><span class="line"><span class="comment"># MULTILINE 模式下，\Z 不识别换行</span></span><br><span class="line">p2 = re.<span class="built_in">compile</span>(<span class="string">r&quot;cd\Z&quot;</span>, flags=re.MULTILINE)</span><br><span class="line"><span class="built_in">print</span>(p2.findall(<span class="string">&quot;abcd\nef&quot;</span>))   <span class="comment"># []</span></span><br><span class="line"><span class="comment"># 只会找到一个（空的）匹配</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\Z&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;abcd\n&quot;</span>))  <span class="comment"># [&#x27;&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="3-非打印字符">（3）非打印字符</h5><ul><li><p>非打印字符指在计算机中有一些字符是确确实实存在,但是它们不能够显示或者打印出来。以 <code>ASCII</code> 码表为例，<code>ASCII</code> 码值在 <code>0 ~ 31</code> 的为控制字符，无法显示和打印。</p><ul><li><p><code>\cx</code>：匹配由 <code>x</code> 指明的 <strong>控制字符</strong>。<code>x</code> 的值必须为 <code>A-Z</code> 或 <code>a-z</code> 之一，否则将 <code>c</code> 视为一个原义的 <code>c</code> 字符。例：<code>\cM</code> 匹配一个 <code>Control-M</code> 或回车符。</p></li><li><p><code>\f</code>：匹配一个 <strong>换页符</strong>。等价于 <code>\x0c</code>。</p></li><li><p><code>\n</code>：匹配一个 <strong>换行符</strong>。等价于 <code>\x0a</code>。</p></li><li><p><code>\r</code>：匹配一个 <strong>回车符</strong>。等价于 <code>\x0d</code>。</p></li><li><p><code>\s</code>：匹配任何 <strong>空白字符</strong>，包括空格、制表符、换页符等。等价于 <code>[\f\n\r\t\v]</code>。</p></li><li><p><code>\S</code>：匹配任何 <strong>非空白字符</strong>。等价于 <code>[^\f\n\r\t\v]</code>。</p></li><li><p><code>\t</code>：匹配一个制表符。等价于 <code>\x09</code>。</p></li><li><p><code>\v</code>：匹配一个垂直制表符。等价于 <code>\x0b</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\f&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;\f&quot;</span>))  <span class="comment"># [&#x27;\x0c&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;\n&quot;</span>))  <span class="comment"># [&#x27;\n&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;\r&quot;</span>))  <span class="comment"># [&#x27;\r&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\x0d&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;\r&quot;</span>))  <span class="comment"># [&#x27;\r&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\s&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot; &quot;</span>))  <span class="comment"># [&#x27; &#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\t&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;\t&quot;</span>))  <span class="comment"># [&#x27;\t&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\\&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;\\&quot;</span>))  <span class="comment"># [&#x27;\\&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;&#x27;&quot;</span>))   <span class="comment"># [&quot;&#x27;&quot;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&#x27;&quot;&#x27;</span>))   <span class="comment"># [&#x27;&quot;&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二-re-模块">二、re 模块</h2><h3 id="2-1-概述">2.1 概述</h3><ul><li><p><code>Python</code> 自 <code>1.5</code> 版本起增加了 <code>re</code> 模块，使 <code>Python</code> 语言拥有全部的正则表达式功能。</p></li><li><p><code>Python</code> 自带的 <code>re</code> 模块主要包含如下 <code>6</code> 种方法：</p><ul><li><p><code>re.compile</code>：编译一个正则表达式模式（<code>pattern</code>）。</p></li><li><p><code>re.match</code>：从头开始匹配，使用 <code>group()</code> 方法可以获取第一个匹配值。</p></li><li><p><code>re.search</code>：用包含方式匹配，使用 <code>group()</code> 方法可以获取第一个匹配值。</p></li><li><p><code>re.findall</code>：用包含方式匹配，把所有匹配到的字符放到以列表中的元素返回多个匹配值。</p></li><li><p><code>re.sub</code>：匹配字符并替换。</p></li><li><p><code>re.split</code>：以匹配到的字符当做列表分隔符，返回列表。</p></li></ul></li></ul><h3 id="2-2-re-compile-方法">2.2 re.compile 方法</h3><ul><li><p>格式：<code>re.compile(pattern[, flags])</code>，用于编译正则表达式，生成一个正则表达式对象（<code>Pattern</code>），供 <code>match()</code> 和 <code>search()</code> 这两个函数使用。</p><ul><li><p><code>pattern</code>：一个字符串形式的正则表达式。</p></li><li><p><code>flags</code>：可选参数，表示编译模式，用于控制正则表达式的匹配方式，参数值为：</p><ul><li><p><code>re.I</code> / <code>re.IGNORECASE</code>：忽略大小写。</p></li><li><p><code>re.M</code> / <code>re.MULTILINE</code>：多行匹配，影响 <code>^</code> 和 <code>$</code>。</p></li><li><p><code>re.S</code> / <code>re.DOTALL</code>：使 <code>.</code> 匹配包括换行符在内的所有字符，没有设置时 <code>.</code> 不能匹配换行符。</p></li><li><p><code>re.X</code> / <code>re.VERBOSE</code>：为了增加可读性，允许正则表达式中书写空格、分段、注释。</p></li><li><p><code>re.L</code> / <code>re.IGNORECASE</code>：表示特殊字符集 <code>\w</code>、<code>\W</code>、<code>\b</code>、<code>\B</code>、<code>\s</code>、<code>\S</code> 依赖于当前环境。</p></li><li><p><code>re.U</code> / <code>re.IGNORECASE</code>：表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库。</p></li></ul></li></ul></li></ul><h3 id="2-3-pattern-实例对象方法">2.3 Pattern 实例对象方法</h3><h4 id="2-3-1-pattern-match-方法">2.3.1 Pattern.match 方法</h4><ul><li><p>格式：<code>Pattern.match(string[, pos[, endpos]])</code>，该方法尝试从字符串 <code>string</code> 的 <code>pos</code> 起始位置（默认起始位置）到 <code>endpos</code> 结束位置（默认为 <code>len(string)</code>）匹配一个模式。</p><ul><li>如果匹配成功，返回 <code>Match</code> 类的实例对象（该实例对象包含匹配相关的信息：起始和结束位置、匹配的子串等等）。</li><li>如果字符串开始就不符合正则表达式 <code>pattern</code>，则匹配失败，函数返回 <code>None</code>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">&#x27;og&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;dog&quot;</span>))   <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(p.<span class="keyword">match</span>(<span class="string">&quot;dog&quot;</span>,<span class="number">1</span>)) <span class="comment"># &lt;re.Match object; span=(1, 3), match=&#x27;og&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-pattern-search-方法">2.3.2 Pattern.search 方法</h4><ul><li><p>格式：<code>Pattern.search(string[, pos[, endpos])</code>，该方法从字符串 <code>string</code> 的 <code>pos</code> 起始位置（默认起始位置）到 <code>endpos</code> 结束位置（默认为 <code>len(string)</code>）进行匹配。</p><ul><li>匹配成功则返回 <strong>第一个成功匹配</strong> 的 <code>Match</code> 类实例对象（该实例对象包含匹配相关的信息：起始和结束位置、匹配的子串等等）。</li><li>匹配失败则返回 <code>None</code>。</li></ul></li><li><p><code>re.search</code> <strong>与</strong> <code>re.match</code> <strong>区别</strong>：<code>re.match</code> 只匹配字符串的开始，如果字符串开始就不符合正则表达式，则匹配失败，函数返回 <code>None</code>；而 <code>re.search</code> 匹配直到找到第一个匹配的对象，最后找不到才返回 <code>None</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">&#x27;og&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;dog&quot;</span>))  <span class="comment"># &lt;re.Match object; span=(1, 3), match=&#x27;og&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;dog&quot;</span>, <span class="number">2</span>))   <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;dog&quot;</span>, endpos=<span class="number">2</span>))    <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(p.search(<span class="string">&quot;dog&quot;</span>, endpos=<span class="number">3</span>))    <span class="comment"># &lt;re.Match object; span=(1, 3), match=&#x27;og&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-3-pattern-fullmatch-方法">2.3.3 Pattern.fullmatch 方法</h4><ul><li><p>格式：<code>Pattern.fullmatch(string[, pos[, endpos]])</code>，该方法从字符串 <code>string</code> 的 <code>pos</code> 起始位置（默认起始位置）到 <code>endpos</code> 结束位置（默认为 <code>len(string)</code>）进行匹配。</p><ul><li>当 <strong>整个字符串都匹配成功</strong>，返回 <code>Match</code> 类的实例对象（该实例对象包含匹配相关的信息：起始和结束位置、匹配的子串等等），否则返回 <code>None</code>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">&#x27;o[gh]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;ogh&quot;</span>))   <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;og&quot;</span>))    <span class="comment"># &lt;re.Match object; span=(0, 2), match=&#x27;og&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;oh&quot;</span>))    <span class="comment"># &lt;re.Match object; span=(0, 2), match=&#x27;oh&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;dog&quot;</span>))   <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(p.fullmatch(<span class="string">&quot;dog&quot;</span>, <span class="number">1</span>))    <span class="comment"># &lt;re.Match object; span=(1, 3), match=&#x27;og&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-4-pattern-findall-方法">2.3.4 Pattern.findall 方法</h4><ul><li><p>格式：<code>Pattern.findall(string[, pos[, endpos]])</code>，用于从字符串 <code>string</code> 的 <code>pos</code> 起始位置（默认起始位置）到 <code>endpos</code> 结束位置（默认为 <code>len(string)</code>）从左往右进行扫描，找到所有 <strong>不重复匹配</strong>，以列表的形式返回，如果有子组，那么 <strong>只保留子组的捕获内容</strong>，如果子组多个（至少两个子组），则以元组形式构建列表，如果没有找到匹配的，则返回空列表。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;Ten years ago, Three dogs&quot;</span>))   <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;10 years ago, 3 dogs&quot;</span>))    <span class="comment"># [&#x27;1&#x27;, &#x27;0&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"><span class="comment"># 多个分组，返回元组列表</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\d+)-(\D)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;Ten-years ago, Three-dogs&quot;</span>))   <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;101-years ago, 3-dogs&quot;</span>))   <span class="comment"># [(&#x27;101&#x27;, &#x27;y&#x27;), (&#x27;3&#x27;, &#x27;d&#x27;)]</span></span><br><span class="line"><span class="comment"># 当捕获分组被重复时, 组号也重复了, 所以后面组的结果会把前面组的结果覆盖</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;(\d)(\d)&#123;2&#125;&quot;</span>) <span class="comment"># 等价于 (\d)(\d)(\d) 且后面两个组号都为 2</span></span><br><span class="line"><span class="built_in">print</span>(p.findall(<span class="string">&quot;1234567890&quot;</span>))  <span class="comment"># [(&#x27;1&#x27;, &#x27;3&#x27;), (&#x27;4&#x27;, &#x27;6&#x27;), (&#x27;7&#x27;, &#x27;9&#x27;)]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-5-pattern-split-方法">2.3.5 Pattern.split 方法</h4><ul><li><p>格式：<code>Pattern.split(string, maxsplit=0)</code> 用于将字符串 <code>string</code> 按照 <code>Pattern</code> 匹配到的子串进行分割，并以列表形式返回。</p><ul><li><p><code>maxsplit</code>：最大分割次数，默认为 <code>0</code>，表示不限制次数。</p></li><li><p>如果有捕获分组，那么分组里匹配的内容也会包含在结果中。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\W+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.split(<span class="string">&#x27;Words, words, words.&#x27;</span>))  <span class="comment"># [&#x27;Words&#x27;, &#x27;words&#x27;, &#x27;words&#x27;, &#x27;&#x27;]</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;(\W+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.split(<span class="string">&#x27;Words, words, words.&#x27;</span>))  <span class="comment"># [&#x27;Words&#x27;, &#x27;, &#x27;, &#x27;words&#x27;, &#x27;, &#x27;, &#x27;words&#x27;, &#x27;.&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;&#x27;, &#x27;...&#x27;, &#x27;Words&#x27;, &#x27;, &#x27;, &#x27;words&#x27;, &#x27;, &#x27;, &#x27;words&#x27;, &#x27;...&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.split(<span class="string">&#x27;...Words, words, words...&#x27;</span>))</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;(\W)+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.split(<span class="string">&#x27;Words, words, words.&#x27;</span>))  <span class="comment"># [&#x27;Words&#x27;, &#x27; &#x27;, &#x27;words&#x27;, &#x27; &#x27;, &#x27;words&#x27;, &#x27;.&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;&#x27;, &#x27;.&#x27;, &#x27;Words&#x27;, &#x27; &#x27;, &#x27;words&#x27;, &#x27; &#x27;, &#x27;words&#x27;, &#x27;.&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(p.split(<span class="string">&#x27;...Words, words, words...&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-6-pattern-sub-方法">2.3.6 Pattern.sub 方法</h4><ul><li><p>格式：<code>Pattern.sub(repl, string, count=0)</code> 用于将字符串 <code>string</code> 中的匹配项替换为 <code>repl</code>。</p><ul><li><p><code>count</code>：模式匹配后替换的最大次数，默认 <code>0</code> 表示替换所有的匹配。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;blue|white|red&#x27;</span>)</span><br><span class="line"><span class="comment"># 把每一个从左开始非重叠匹配的字符串用其他字符串替换</span></span><br><span class="line"><span class="comment"># colour socks and colour shoes</span></span><br><span class="line"><span class="built_in">print</span>(p.sub(<span class="string">&#x27;colour&#x27;</span>, <span class="string">&#x27;blue socks and red shoes&#x27;</span>))</span><br><span class="line"><span class="comment"># colour socks and red shoes</span></span><br><span class="line"><span class="built_in">print</span>(p.sub(<span class="string">&#x27;colour&#x27;</span>, <span class="string">&#x27;blue socks and red shoes&#x27;</span>, count=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">matchobj</span>):</span><br><span class="line">    <span class="keyword">if</span> matchobj.group() == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">把每一个从左开始非重叠匹配的对象作为参数传入函数调用</span></span><br><span class="line"><span class="string">这个函数只能有一个 匹配对象 参数, 并返回一个替换字符串</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;-&#123;1,2&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.sub(func, <span class="string">&#x27;pro----gram-files&#x27;</span>)) <span class="comment"># pro--gram files</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-4-match-实例对象方法">2.4 Match 实例对象方法</h3><h4 id="2-4-1-match-group-方法">2.4.1 Match.group 方法</h4><ul><li><p>格式：<code>Match.group(*groupN)</code> 返回一个或者多个子组的匹配结果，如果有多个参数，结果就是一个元组。</p><ul><li><p><code>groupN</code>：对应的组号，默认为 <code>0</code>，返回整个匹配结果。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(.+)a(.+)e&quot;</span>)</span><br><span class="line">m = p.<span class="keyword">match</span>(<span class="string">&quot;babacdefg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m)    <span class="comment"># &lt;re.Match object; span=(0, 7), match=&#x27;babacde&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.group())    <span class="comment"># babacde</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">0</span>))   <span class="comment"># babacde</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">1</span>))   <span class="comment"># ab</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">2</span>))   <span class="comment"># cd</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="comment"># (&#x27;cd&#x27;, &#x27;ab&#x27;, &#x27;babacde&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-4-2-match-start-方法">2.4.2 Match.start 方法</h4><ul><li><p>格式：<code>Match.start([group])</code> 返回对应 <code>group</code> 匹配开始的位置，<code>group</code> 默认为 <code>0</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(.+)a(.+)e&quot;</span>)</span><br><span class="line">m = p.<span class="keyword">match</span>(<span class="string">&quot;babacdefg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m.start(<span class="number">0</span>))   <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(m.start(<span class="number">1</span>))   <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(m.start(<span class="number">2</span>))   <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-3-match-end-方法">2.4.3 Match.end 方法</h4><ul><li><p>格式：<code>Match.end([group])</code> 返回对应 <code>group</code> 匹配结束的位置，<code>group</code> 默认为 <code>0</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(.+)a(.+)e&quot;</span>)</span><br><span class="line">m = p.<span class="keyword">match</span>(<span class="string">&quot;babacdefg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m.end(<span class="number">0</span>))   <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(m.end(<span class="number">1</span>))   <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(m.end(<span class="number">2</span>))   <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-4-match-span-方法">2.4.4 Match.span 方法</h4><ul><li><p>格式：<code>Match.span([group])</code> 返回一个元组，包含 <code>(Match.start([group]),Match.end([group]))</code>，<code>group</code> 默认为 <code>0</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">r&quot;b(.+)a(.+)e&quot;</span>)</span><br><span class="line">m = p.<span class="keyword">match</span>(<span class="string">&quot;babacdefg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m)    <span class="comment"># &lt;re.Match object; span=(0, 7), match=&#x27;babacde&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.span()) <span class="comment"># (0, 7)</span></span><br><span class="line"><span class="built_in">print</span>(m.span(<span class="number">0</span>))    <span class="comment"># (0, 7)</span></span><br><span class="line"><span class="built_in">print</span>(m.span(<span class="number">1</span>))    <span class="comment"># (1, 3)</span></span><br><span class="line"><span class="built_in">print</span>(m.span(<span class="number">2</span>))    <span class="comment"># (4, 6)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 常用文件模块</title>
      <link href="/posts/Python/Python.html"/>
      <url>/posts/Python/Python.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-os-模块：实现-python-程序与操作系统进行交互">一、os 模块：实现 Python 程序与操作系统进行交互</h2><ul><li><p><code>os</code> 就是 “<code>operating system</code>” 的缩写，顾名思义，<code>os</code> 模块提供的就是各种 <code>Python</code> 程序与操作系统进行交互的接口。通过使用 <code>os</code> 模块，一方面可以方便地与操作系统进行交互，另一方面也可以极大增强代码的可移植性。如果该模块中相关功能出错，会抛出 <code>OSError</code> 异常及其子类异常。</p></li><li><p>不要使用 <code>from os import *</code> 来导入 <code>os</code> 模块；否则 <code>os.open()</code> 将会覆盖内置函数 <code>open()</code>。</p></li><li><p><code>os</code> 模块中大多数接受路径作为参数的函数也可以接受 “文件描述符” 作为参数。</p><ul><li>文件描述符：<code>file descriptor</code>，在 <code>Python</code> 文档中简记为 <code>fd</code>，是一个与某个打开的文件对象绑定的非负整数，打开已有文件或新建文件时，系统内核会返回一个文件描述符。</li></ul></li></ul><h3 id="1-1-属性">1.1 属性</h3><ul><li><p><code>os.name</code> 属性返回当前操作系统的类型，返回值 <code>posix</code>，<code>nt</code>，<code>java</code> 分别对应 <code>linux</code>/<code>Mac OS</code>，<code>Windows</code>，<code>Java虚拟机</code>。</p></li><li><p><code>os.environ</code> 属性返回 <strong>字典类型</strong> 的环境变量。</p></li></ul><h3 id="1-2-路径相关操作">1.2 路径相关操作</h3><h4 id="1-2-1-os-getcwd">1.2.1 os.getcwd()</h4><ul><li><p><code>getcwd</code> 是 <code>get the current working directory</code> 的缩写，用于获取当前工作路径，返回一个 <strong>字符串</strong>。在交互式环境中，返回的就是交互终端打开的位置，而在 <code>Python</code> 文件中，返回的则是文件所在的位置。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())  <span class="comment"># E:\PythonFiles\dong</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(os.getcwd()))  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-2-os-listdir-path">1.2.2 os.listdir(path)</h4><ul><li><p><code>listdir</code> 是 <code>list directories</code> 的缩写，用于返回一个由指定文件夹目录（<code>path</code>）下的文件和文件夹名字组成的 <strong>列表</strong>。<strong>注</strong>：只返回指定文件夹下的名称，不包含子目录下的名称。</p><ul><li><code>path</code> 表示需要列出的目录路径，可以是相对或绝对路径。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># [&#x27;Python深度学习基于PyTorch&#x27;, &#x27;Python深度学习基于PyTorch.pdf&#x27;, &#x27;动手学深度学习.pdf&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">r&quot;E:\电子书&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-3-os-mkdir-path-mode-0777">1.2.3 os.mkdir(path, mode=0777)</h4><h5 id="1-用法">（1）用法</h5><ul><li><p><code>mkdir</code> 是 <code>make directory</code> 的缩写，用于以数字权限模式创建目录（单级目录），<strong>无返回值</strong>。</p><ul><li><p><code>path</code> 表示要创建的目录，可以是相对或者绝对路径。</p></li><li><p><code>mode</code> 表示要为目录设置的数字权限模式。默认为 <code>0777</code> (<code>0</code> 开头表示八进制)。</p></li></ul></li><li><p><code>mkdir</code> 只会创建 <code>path</code> 中的 <strong>最后一级目录</strong>，否则（即新建多级路径）会抛出 <code>FileNotFoundError</code> 异常。所以要保证所需要的中间目录是存在的，如果最后一级目录已存在，则抛出 <code>FileExistsError</code> 异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">&quot;./test&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-权限位说明">（2）权限位说明</h5><ul><li><p>文件或目录的权限位是由 <code>9</code> 个权限位来控制，每三位为一组，它们分别是文件所有者（<code>user</code>）的读、写、执行，用户组（<code>group</code>）的读、写、执行和其他用户（<code>other</code>）的读、写、执行，所有用户（<code>all</code>）的读、写、执行。</p><ul><li><p><code>r</code> <code>read</code> 可读权限 对应数字 <code>4</code>。</p></li><li><p><code>w</code> <code>write</code> 可写权限 对应数字 <code>2</code>。</p></li><li><p><code>x</code> <code>excute</code> 执行权限 对应数字 <code>1</code>。</p></li><li><p><code>-</code> 没有任何权限 对应数字 <code>0</code>。</p></li></ul></li></ul><h4 id="1-2-4-os-makedirs-path-mode-0777-exist-ok-false">1.2.4 os.makedirs(path, mode=0777, exist_ok=False)</h4><ul><li><p><code>os.makedirs()</code> 方法用于递归创建目录。在需要新建多级目录的场景下，就可以使用 <code>os.makedirs()</code>，<strong>无返回值</strong>。如果 <code>exist_ok</code> 为 <code>False</code>（默认值），则子目录创建失败或已经存在时，会抛出一个 <code>FileExistsError</code> 的异常，为 <code>True</code> 则不会抛出异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(<span class="string">&quot;./mid/test&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-5-os-remove-path">1.2.5 os.remove(path)</h4><ul><li><p><code>os.remove()</code> 方法用于删除指定路径下的文件，<strong>无返回值</strong>。如果指定的路径是一个目录，将抛出 <code>PermissionError</code> 异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">&quot;./test.txt&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-6-os-rmdir-path">1.2.6 os.rmdir(path)</h4><ul><li><p><code>os.rmdir()</code> 方法用于删除指定路径的目录，<strong>无返回值</strong>。仅当这个文件夹 <strong>为空</strong> 时才可以被删除，否则抛出 <code>OSError</code> 异常。目录不存在则抛出 <code>FileNotFoundError</code> 异常。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rmdir(<span class="string">&quot;./test&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-7-os-removedirs-path">1.2.7 os.removedirs(path)</h4><ul><li><p><code>os.removedirs()</code> 方法用于递归删除目录，<strong>无返回值</strong>。该函数会从最下级目录开始，逐级删除指定的路径，一旦遇到非空目录即停止。仅当最下级目录 <strong>为空</strong> 时才可以被删除。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.removedirs(<span class="string">&quot;../dong/mid/test&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-8-os-rename-src-dst">1.2.8 os.rename(src, dst)</h4><ul><li><p><code>os.rename()</code> 方法用于将文件或目录重命名，<strong>无返回值</strong>。一般调用格式为 <code>os.rename(src, dst)</code>，即将 <code>src</code> 指向的文件或目录重命名为 <code>dst</code> 指定的名称。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rename(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;dong&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-9-os-renames-old-new">1.2.9 os.renames(old, new)</h4><ul><li><p><code>os.renames()</code> 方法用于递归重命名目录或文件，该方法能够创建缺失的中间目录，<strong>无返回值</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.renames(<span class="string">&quot;dong&quot;</span>, <span class="string">&quot;./test/xin&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-10-os-path-abspath-path">1.2.10 os.path.abspath(path)</h4><ul><li><p><code>os.path.abspath()</code> 方法用于返回路径 <code>path</code> 的 <strong>绝对路径</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&quot;.&quot;</span>))  <span class="comment"># E:\PythonFiles\test</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-11-os-path-basename-path">1.2.11 os.path.basename(path)</h4><ul><li><p><code>os.path.basename()</code> 方法用于返回路径 <code>path</code> 中最后一级的名称，通常用来返回文件名。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.basename(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># test.txt</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-12-os-path-dirname-path">1.2.12 os.path.dirname(path)</h4><ul><li><p><code>os.path.dirname()</code> 方法用于返回路径 <code>path</code> 的目录名称。即除了最后一级名称之外的全部名称。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.dirname(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># E:\PythonFiles\dong</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-13-os-path-split-path">1.2.13 os.path.split(path)</h4><ul><li><p><code>os.path.split()</code> 方法用于将路径分割成 <code>dirname</code> 和 <code>basename</code>，返回一个 <strong>元组</strong>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.split(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># (&#x27;E:\\PythonFiles\\dong&#x27;, &#x27;test.txt&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-14-os-path-splitext-path">1.2.14 os.path.splitext(path)</h4><ul><li><p><code>os.path.splitext()</code> 方法用于将路径中的扩展名分割出来，返回一个元组。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.splitext(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># (&#x27;E:\\PythonFiles\\dong\\test&#x27;, &#x27;.txt&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-15-os-path-exists-path">1.2.15 os.path.exists(path)</h4><ul><li><p><code>os.path.exists()</code> 方法用于判断路径是否存在，<code>path</code> 路径存在则返回 <code>True</code>，不存在或失效则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-16-os-path-isabs-path">1.2.16 os.path.isabs(path)</h4><ul><li><p><code>os.path.exists()</code> 方法用于判断路径 <strong>形式上</strong> 是否为绝对路径，不会判断是否存在。返回 <code>True</code> 或 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.isabs(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-17-os-path-isfile-path">1.2.17 os.path.isfile(path)</h4><ul><li><p><code>os.path.isfile()</code> 方法用于判断路径是否为文件，路径是文件且 <strong>文件存在</strong> 时返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">r&quot;E:\PythonFiles\dong\test.txt&quot;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-18-os-path-isdir-path">1.2.18 os.path.isdir(path)</h4><ul><li><p><code>os.path.isdir()</code> 方法用于判断路径是否为目录，路径是目录且 <strong>目录存在</strong> 时返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(<span class="string">r&quot;E:\PythonFiles\dong&quot;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-19-os-path-join-path-paths">1.2.19 os.path.join(path, *paths)</h4><ul><li><p><code>os.path.join()</code> 方法可以将多个传入路径组合为一个路径。</p><ul><li><p>该方法是将传入的几个字符串用系统的 <strong>分隔符</strong>（<code>\</code>）<strong>拼接</strong> 起来，组合成一个新的字符串，所以一般的用法是将第一个参数作为父目录，之后每一个参数作为下一级目录，从而组合成一个新的符合逻辑的路径。</p></li><li><p>如果传入路径中存在一个 “<strong>绝对路径</strong>” 格式的字符串，且这个字符串不是函数的第一个参数，那么在这个参数之前的所有参数都会被丢弃，余下的参数再进行拼接。更准确地说，只有最后一个 “绝对路径” 及其之后的参数才会体现在返回结果中。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&quot;E:/PythonFiles/dong&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;xin.py&quot;</span>))  <span class="comment"># E:/PythonFiles/dong\test\xin.py</span></span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">r&quot;E:\PythonFiles\dong&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;xin.py&quot;</span>))  <span class="comment"># E:\PythonFiles\dong\test\xin.py</span></span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">r&quot;E:\PythonFiles\dong&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">r&quot;E:\Project\xin&quot;</span>, <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;test.py&quot;</span>))  <span class="comment"># E:\Project\xin\dong\test.py</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-pickle-模块：实现-python-对象的持久化存储">2.1 pickle 模块：实现 Python 对象的持久化存储</h3><ul><li><p><code>pickle</code> 模块能够实现任意对象与文本之间的相互转化，也可以实现任意对象与二进制之间的相互转化。也就是说，<code>pickle</code> 可以实现 <code>Python</code> 对象的存储及恢复。</p></li><li><p><code>pickle</code> 模块提供了 <code>dumps()</code>、<code>loads()</code>、<code>dump()</code> 和 <code>load()</code> 这 <code>4</code> 个函数供我们使用。</p><ul><li><p><code>dumps</code> 和 <code>loads</code> 函数实现了基于内存的 <code>Python</code> 对象与二进制之间的相互转化。</p></li><li><p><code>dump</code> 和 <code>loads</code> 函数实现了基于文件的 <code>Python</code> 对象与二进制之间的相互转化。</p></li></ul></li></ul><h4 id="2-1-1-pickle-dumps-函数">2.1.1 pickle.dumps() 函数</h4><ul><li><p><code>pickle.dumps()</code> 函数用于将 <code>Python</code> 对象转换为二进制对象，返回值为二进制对象。语法格式：<code>dumps(obj, protocol=None, *, fix_imports=True)</code>。</p><ul><li><p><code>obj</code>：表示要转换的 <code>Python</code> 对象。</p></li><li><p><code>protocol</code>：<code>pickle</code> 的转码协议，取值为 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，其中 <code>0</code>、<code>1</code>、<code>2</code> 对应 <code>Python</code> 早期的版本，<code>3</code> 和 <code>4</code> 则对应 <code>Python 3.x</code> 版本及之后的版本。未指定情况下，默认为 <code>3</code>。</p></li><li><p><code>其它参数</code>：为了兼容 <code>Python 2.x</code> 版本而保留的参数，<code>Python 3.x</code> 中可以忽略。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;dong&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(person)) <span class="comment"># 输出：b&#x27;\x80\x04\x95\x1b\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x04dong\x94\x8c\x03age\x94K\x12u.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-2-pickle-loads-函数">5.1.2 pickle.loads() 函数</h4><ul><li><p><code>pickle.loads()</code> 函数用于将二进制对象转换成 <code>Python</code> 对象，返回值为 <code>Python</code> 对象。语法格式：<code>loads(data, *, fix_imports=True, encoding='ASCII', errors='strict')</code>。</p><ul><li><p><code>data</code>：表示要转换的二进制对象。</p></li><li><p><code>其它参数</code>：为了兼容 <code>Python 2.x</code> 版本而保留的参数，<code>Python 3.x</code> 中可以忽略。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">bp = <span class="string">b&#x27;\x80\x04\x95\x1b\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x04dong\x94\x8c\x03age\x94K\x12u.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(bp)) <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;dong&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-3-pickle-dump-函数">5.1.3 pickle.dump() 函数</h4><ul><li><p><code>pickle.dump()</code> 函数用于将 <code>Python</code> 对象转换成二进制文件，无返回值。语法格式：<code>dump(obj, file, protocol=None, *, fix mports=True)</code></p><ul><li><p><code>obj</code>：表示要转换的 <code>Python</code> 对象。</p></li><li><p><code>file</code>：转换到指定的二进制文件中，要求该文件必须是以 “<code>wb</code>” 的打开方式进行操作。</p></li><li><p><code>protocol</code>：和 <code>dumps()</code> 函数中 <code>protocol</code> 参数的含义完全相同，因此这里不再重复描述。</p></li><li><p><code>其它参数</code>：为了兼容 <code>Python 2.x</code> 版本而保留的参数，<code>Python 3.x</code> 中可以忽略。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> pf:</span><br><span class="line">    pickle.dump(person, pf)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-4-pickle-load-函数">5.1.4 pickle.load() 函数</h4><ul><li><p><code>pickle.load()</code> 函数用于将二进制文件转换成 <code>Python</code> 对象，返回值为 <code>Python</code> 对象。语法格式：<code>load(file, *, fix_imports=True, encoding='ASCII', errors='strict')</code></p><ul><li><p><code>file</code>：表示要转换的二进制文件，要求该文件必须是以 “<code>rb</code>” 的打开方式进行操作。</p></li><li><p><code>其它参数</code>：为了兼容 <code>Python 2.x</code> 版本而保留的参数，<code>Python 3.x</code> 中可以忽略。</p></li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> bf:</span><br><span class="line">    pickle.dump(person, bf)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;test.txt&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> pf:</span><br><span class="line">    <span class="built_in">print</span>(pickle.load(pf))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 文件操作</title>
      <link href="/posts/Python/Python.html"/>
      <url>/posts/Python/Python.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 和其它编程语言一样，<code>Python</code> 也具有操作文件（<code>I/O</code>）的功能，例：打开文件、读取和追加数据、插入和删除数据、关闭文件、删除文件等。除了提供文件操作基本的函数之外，<code>Python</code> 还提供了很多模块，例：<code>fileinput</code> 模块、<code>pathlib</code> 模块等。</p><h2 id="一-python-文件">一、Python 文件</h2><h3 id="1-1-文件">1.1 文件</h3><ul><li><p>从文件的编码方式来看，文件可以分为 <strong>文本文件</strong> 和 <strong>二进制文件</strong>。</p><ul><li><p>文本文件：<code>txt</code>、<code>html</code>、<code>json</code> 等。</p></li><li><p>二进制文件：图片、音频、视频等</p></li></ul></li><li><p>从计算机物理内存来看，所有文件都是 <strong>二进制形式</strong> 存放的。因此文本文件也可以用二进制格式读取，而 <strong>二进制文件是不能用文本格式读取</strong> 的。</p></li></ul><h3 id="1-2-基本操作">1.2 基本操作</h3><ul><li><p>文件的基本操作可以分为以下 <code>3</code> 步，每一步都需要借助对应的函数实现：</p><ul><li><p>打开文件：使用 <code>open()</code> 函数，该函数会返回一个 <strong>文件对象</strong>。</p></li><li><p>对已打开文件做读/写操作：</p><ul><li><p>读取文件，可以使用 <code>read()</code>、<code>readline()</code> 以及 <code>readlines()</code> 函数。</p></li><li><p>写入文件，可以使用 <code>write()</code> 函数。</p></li></ul></li><li><p>关闭文件：完成对文件的读 / 写操作之后，最后需要关闭文件，可以使用 <code>close()</code> 函数。</p></li></ul></li></ul><h2 id="二-open-内置函数">二、open() 内置函数</h2><ul><li><p><code>open()</code> 函数用于创建或打开一个文件，并返回该 <strong>文件对象</strong>。如果该文件无法被打开，会抛出 <code>OSError</code>。</p></li><li><p>文件对象是一个可迭代对象，并且是一个迭代器。实现了迭代器协议（<code>__iter__</code>和<code>__next__</code>），没有实现序列协议（<code>__getitem__</code>）。</p></li><li><p><code>open()</code> 函数语法格式：<code>file = open(file_name[, mode='r'][, buffering=-1][, encoding=None])</code></p><ul><li><p><code>file</code>：表示函数返回的文件对象。</p></li><li><p><code>file_name</code>：必选参数，字符串类型，用于设定创建 / 打开的文件名。</p><ul><li><p>如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可。</p></li><li><p>如果要打开的文件和当前执行的代码文件不位于同一目录，则需要指定文件所在的完整路径。</p></li></ul></li><li><p><code>mode</code>：可选参数，用于设置文件的打开模式，需要使用 <strong>单引号</strong> / <strong>双引号</strong> 包裹，默认以文本格式（<code>t</code>）、采用只读模式（<code>r</code>）打开文件。</p><table><tr><th align="center">模式</th><th>用法</th><th>备注</th></tr><tr><td align="center"><b>r</b> / <b>rt</b><br>（可以不写<b>t</b>）</td><td>以 <b>文本格式（t）</b>、采用 <b>只读模式</b> 打开文件，读文件内容的指针会放在文件的首位。</td><td rowspan="4">操作的文件必须存在。</td></tr><tr><td align="center"><b>rb</b></td><td>以 <b>二进制格式（b）</b>、采用 <b>只读模式</b> 打开文件，一般用于非文本文件，如图片文件、音频文件等。</td></tr><tr><td align="center"><b>r</b>+ / <b>rt</b>+<br>（可以不写<b>t</b>）</td><td>以 <b>文本格式</b>、采用 <b>读写模式</b> 打开文件，<b>读写文件的指针会放在文件的首位</b>。既可以从首位开始读取文件内容，也可以从首位开始向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。</td></tr><tr><td align="center"><b>rb</b>+</td><td>以 <b>二进制格式</b>、采用 <b>读写模式</b> 打开文件，一般用于非文本文件，如图片文件、音频文件等。</td></tr><tr><td align="center"><b>w</b> / <b>wt</b><br>（可以不写<b>t</b>）</td><td>以 <b>文本格式</b>、采用 <b>只写模式</b> 打开文件。</td><td rowspan="4">若文件存在，创建文件对象时会清空文件原有内容；反之，创建新文件。<tr><td align="center"><b>wb</b></td><td>以 <b>二进制格式</b>、采用 <b>只写模式</b> 打开文件。</td></tr><tr><td align="center"><b>w</b>+ / <b>wt</b>+<br>（可以不写<b>t</b>）</td><td>以 <b>文本格式</b>、采用 <b>读写模式</b> 打开文件。</td></tr><tr><td align="center"><b>wb</b>+</td><td>以 <b>二进制格式</b>、采用 <b>读写模式</b> 打开文件。</td></tr><tr><td align="center"><b>a</b> / <b>at</b><br>（可以不写<b>t</b>）</td><td>以 <b>文本格式</b>、采用 <b>追加模式</b> 打开文件。对文件只有写入权限。</td><td rowspan="4">若文件存在，创建文件对象时会将 <b>文件指针放在文件末尾</b>；反之，创建新文件。</td></tr><tr><td align="center"><b>ab</b></td><td>以 <b>二进制格式</b>、采用 <b>追加模式</b> 打开文件。对文件只有写权限。</td></tr><tr><td align="center"><b>a</b>+ / <b>at</b>+<br>（可以不写<b>t</b>）</td><td>以 <b>文本格式</b>、采用 <b>读写模式</b> 打开文件。对文件只有写权限。</td></tr><tr><td align="center"><b>ab</b>+</td><td>以 <b>二进制格式</b>、采用 <b>读写模式</b> 打开文件。对文件只有写权限。</td></tr><tr><td align="center"><b>x</b></td><td><b>新建</b> 一个文件只用于 <b>写入</b>，如果该文件已存在则会报错。</td><td>操作的文件必须不存在。</td></tr></table></li><li><p><code>buffering</code>：可选参数，用于指定对文件做读写操作时使用缓冲区的大小，建议不做修改。</p><ul><li><p>如果 <code>buffering</code> 参数的值为 <code>0</code>（或者 <code>False</code>），则表示在打开指定文件时不使用缓冲区。</p></li><li><p>如果 <code>buffering</code> 参数值为大于等于 <code>1</code> 的整数，则表示使用指定的缓冲区大小（单位：字节）。</p></li><li><p>如果 <code>buffering</code> 参数的值为负数，则表示使用默认的缓冲区大小。</p></li></ul></li><li><p><code>encoding</code>：可选参数，用于设定打开 <strong>文本文件</strong> 时所使用的编码格式，一般使用 <code>utf8</code>。</p><ul><li>目标文件使用的编码格式和 <code>open()</code> 函数使用的编码格式必须匹配，否则会抛出 <code>UnicodeDecodeError</code> 异常。</li></ul></li></ul></li></ul><h2 id="三-file-文件对象">三、file 文件对象</h2><ul><li>通过 <code>open</code> 函数打开文件时会返回 <code>file</code> 文件对象，可以通过文件对象调用自身拥有的属性及方法。</li></ul><h3 id="3-1-文件对象常用的属性">3.1 文件对象常用的属性</h3><ul><li><p><code>file.name</code>：返回打开文件的名称。</p></li><li><p><code>file.mode</code>：返回打开文件时使用的文件打开模式。</p></li><li><p><code>file.encoding</code>：返回打开文件时使用的编码格式。</p></li><li><p><code>file.closed</code>：判断文件是否关闭。</p></li></ul><h3 id="3-2-文件对象常用的方法">3.2 文件对象常用的方法</h3><h4 id="3-2-1-file-read">3.2.1 file.read()</h4><ul><li><p>语法格式：<code>file.read([size=-1])</code></p><ul><li><p><code>size</code>：可选参数。从文件中读取的字符数（文本模式 <code>t</code>）或字节数（二进制模式 <code>b</code>），默认为 <code>-1</code>，表示读取整个文件。</p><ul><li>如果 <code>size</code> 为负值或 <code>None</code>，则读取至 <code>EOF</code>（<code>End Of File</code>）。</li></ul></li><li><p>返回值：从文件中读取的内容。</p></li></ul></li><li><p>作用：从文件读取指定的字符数（文本模式 <code>t</code>）或字节数（二进制模式 <code>b</code>），如果未给定参数 <code>size</code> 或 <code>size</code> 为负数则读取文件所有内容。</p></li><li><p>注意事项：必须以可读模式（包括 <code>r</code>、<code>r+</code>、<code>rb</code>、<code>rb+</code>）打开文件，否则会抛出 <code>io.UnsupportedOperation</code> 异常。</p></li></ul><h4 id="3-2-2-file-readline">3.2.2 file.readline()</h4><ul><li><p>语法格式：<code>file.readline(size=-1)</code></p><ul><li><p><code>size</code>：限制读取每一行时 <strong>最多</strong> 读取的 <strong>字符数</strong>（文本模式 <code>t</code>）或 <strong>字节数</strong>（二进制模式 <code>b</code>），默认 <code>-1</code>，表示读取完整的一行。</p></li><li><p>返回值：从文件中读取的一行内容。</p></li></ul></li><li><p>作用：和 <code>read()</code> 方法不同，<code>readline()</code> 方法以 “行” 作为读取单位，即每次都读取目标文件中的一行。</p><ul><li><p>对于读取以文本格式打开的文件，读取一行很好理解。</p></li><li><p>对于读取以二进制格式打开的文件，它们会以 <code>\n</code> 作为读取一行的标志。</p></li></ul></li><li><p>注意事项：</p><ul><li><p>必须以可读模式（包括 <code>r</code>、<code>r+</code>、<code>rb</code>、<code>rb+</code>）打开文件，否则会抛出 <code>io.UnsupportedOperation</code> 异常。</p></li><li><p><code>readline()</code> 方法在读取文件中一行的内容时，会读取最后的换行符 <code>\n</code>，使用 <code>print()</code> 函数输出文件内容时会看到多出了一个空行（<code>print()</code> 函数默认换行）。</p></li><li><p>当指定的 <code>size</code> 正好到换行符 <code>\n</code> 时，默认读取到下一行。</p></li></ul></li></ul><h4 id="3-2-3-file-readlines">3.2.3 file.readlines()</h4><ul><li><p>语法格式：<code>file.readlines(hint=-1)</code></p><ul><li><p><code>hint</code>：默认为 <code>-1</code>，代表读取所有行（也可以指定读取的字符数，如果要读取的字符数不足一行，则按照一行读取；超过一行，则按照两行读取；超过两行则按照三行读取，依次类推）。</p></li><li><p>返回值：文件每行内容形成的 <strong>字符串列表</strong>。</p></li></ul></li><li><p>作用：<code>readlines()</code> 方法用于读取文件中的所有行（直到结束符 <code>EOF</code>），它和不指定 <code>size</code> 参数的 <code>read()</code> 方法类似，只不过该方法返回是一个字符串列表，列表中的每个元素为文件中的一行内容。</p></li><li><p>注意事项：</p><ul><li><p>必须以可读模式（包括 <code>r</code>、<code>r+</code>、<code>rb</code>、<code>rb+</code>）打开文件，否则会抛出 <code>io.UnsupportedOperation</code> 异常。</p></li><li><p><code>readlines()</code> 方法和 <code>readline()</code> 方法相同，在读取每一行时，会连同行尾的换行符一起读取。</p></li></ul></li></ul><h4 id="3-2-4-file-readable">3.2.4 file.readable()</h4><ul><li><p>语法格式：<code>file.readable()</code></p><ul><li>返回值：<code>True</code> 或 <code>False</code>。</li></ul></li><li><p>作用：判断 <code>file</code> 是否可读。</p></li></ul><h4 id="3-2-5-file-write">3.2.5 file.write()</h4><ul><li><p>语法格式：<code>file.write(string)</code></p><ul><li><p><code>string</code>：写入文件的字符串（文本模式 <code>t</code>）或字节串（二进制模式 <code>b</code>）。</p></li><li><p>返回值：写入的内容长度。</p></li></ul></li><li><p>作用：向文件中写入字符串（文本模式 <code>t</code>）或字节串（二进制模式 <code>b</code>）。</p></li><li><p>注意事项：</p><ul><li><p>必须以 <code>r+</code>、<code>w</code>、<code>w+</code>、<code>a</code> 或 <code>a+</code> 的模式打开文件，否则会抛出 <code>io.UnsupportedOperation</code> 异常。</p></li><li><p>在文件关闭（<code>close()</code>）或缓冲区刷新（<code>flush()</code>）之前，字符串内容存储在缓冲区中，这时在文件中看不到新写入的内容。</p></li><li><p>如果以文本格式打开文件，那么写入字节串时，要使用字节串的 <code>decode</code> 方法将字节串转换为文本形式，否则报错：<code>TypeError: write() argument must be str, not bytes</code>。</p></li><li><p>如果以二进制格式打开文件，那么写入字符串时，要使用字符串的 <code>encode</code> 方法将字符串转换为二进制形式，否则报错：<code>TypeError: a bytes-like object is required, not 'str'</code>。</p></li><li><p>对于以二进制格式打开的文件，可以不使用缓冲区（<code>buffering</code> 为 <code>0</code>），写入的数据会直接进入磁盘文件；但对于以文本格式打开的文件，必须使用缓冲区，否则会抛出 <code>ValueError</code> 异常。</p></li></ul></li></ul><h4 id="3-2-6-file-writelines">3.2.6 file.writelines()</h4><ul><li><p>语法格式：<code>file.writelines([strIterable])</code></p><ul><li><p><code>strIterable</code>：由字符串（文本模式 <code>t</code>）或字节串（二进制模式 <code>b</code>）组成的可迭代对象。</p></li><li><p>返回值：无。</p></li></ul></li><li><p>作用：向文件中写入字符串（文本模式 <code>t</code>）或字节串（二进制模式 <code>b</code>）列表。</p></li><li><p>注意事项：<code>write()</code> 方法要注意的点在 <code>writelines()</code> 方法中同样需要注意。</p><ul><li>使用 <code>writelines()</code> 方法向文件中写入序列时，<strong>不会自动为可迭代对象中的各元素添加换行符</strong>。</li></ul></li></ul><h4 id="3-2-7-file-writable">3.2.7 file.writable()</h4><ul><li><p>语法格式：<code>file.writable()</code></p><ul><li>返回值：<code>True</code> 或 <code>False</code>。</li></ul></li><li><p>作用：判断 <code>file</code> 是否可写。</p></li></ul><h4 id="3-2-8-file-tell">3.2.8 file.tell()</h4><ul><li><p>语法格式：<code>file.tell()</code></p><ul><li>返回值：文件指针所在位置。</li></ul></li><li><p>作用：返回文件指针当前位置。</p></li></ul><h4 id="3-2-9-file-seek">3.2.9 file.seek()</h4><ul><li><p>语法格式：<code>file.seek(offset[, whence])</code></p><ul><li><p><code>whence</code>：可选参数。用于指定文件指针要放置的位置，该参数的参数值有 <code>3</code> 个选择：</p><ul><li><p><code>io.SEEK_SET</code> 或 <code>0</code> 代表文件头（默认值）。</p></li><li><p><code>io.SEEK_CUR</code> 或 <code>1</code> 代表当前位置。</p></li><li><p><code>io.SEEK_END</code> 或 <code>2</code> 代表文件尾。</p></li></ul></li><li><p><code>offset</code>：表示相对于 <code>whence</code> 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。</p></li><li><p>返回值：如果操作成功，则返回新的文件位置，如果操作失败，则函数返回 <code>-1</code>。</p></li></ul></li><li><p>作用：将文件指针移动至指定位置。</p></li><li><p>注意事项：</p><ul><li><code>Pyhon3</code> 在使用文本模式（<code>t</code>）打开文件时，只允许从文件头开始计算相对位置，从文件尾计算时会抛出 <code>io.UnsupportedOperation</code> 异常。</li><li>换行符 <code>\n</code> 在文件指针中占用 <code>2</code> 个字符。</li></ul></li></ul><h4 id="3-2-10-file-truncate">3.2.10 file.truncate()</h4><ul><li><p>语法格式：<code>file.truncate([size])</code></p><ul><li><p><code>size</code>：可选参数。用于指定从文件头开始要截断的字节数。</p></li><li><p>返回值：截断的字节长度。</p></li></ul></li><li><p>作用：用于从文件头开始截断文件并返回截断的字节长度。</p></li><li><p>注意事项：</p><ul><li>必须以 <code>r+</code>、<code>w</code>、<code>w+</code>、<code>a</code> 或 <code>a+</code> 的模式打开文件，否则会抛出 <code>io.UnsupportedOperation</code> 异常。</li></ul></li></ul><h4 id="3-2-11-file-close">3.2.11 file.close()</h4><ul><li><p>语法格式：<code>file.close()</code></p><ul><li>返回值：无。</li></ul></li><li><p>作用：用于关闭一个已打开的文件。</p></li><li><p>注意事项：</p><ul><li><p><code>close()</code> 方法允许被调用多次。</p></li><li><p>关闭后的文件不能再进行读写操作， 否则会抛出 <code>ValueError</code> 异常。</p></li><li><p>当 <code>file</code> 对象指向另一个文件时，<code>Python</code> 会自动关闭之前的 <code>file</code> 对象。</p></li></ul></li></ul><h4 id="3-2-12-file-flush">3.2.12 file.flush()</h4><ul><li><p>语法格式：<code>file.flush()</code></p><ul><li>返回值：无。</li></ul></li><li><p>作用：刷新缓冲区，即将缓冲区中的数据立刻写入文件，同时清空缓冲区。</p><ul><li>注：<code>file.read()</code> 和 <code>file.close()</code> 方法会自动刷新缓冲区。</li></ul></li></ul><h2 id="四-with-用法及原理">四、with 用法及原理</h2><h3 id="4-1-上下文管理器">4.1 上下文管理器</h3><ul><li><p>上下文即执行当前代码所需的相关环境。</p></li><li><p>只要一个类实现了 <code>__enter__(self)</code> 和 <code>__exit__(self, exc_type, exc_valye, traceback)</code> 方法，就可以被称为上下文管理器。</p></li><li><p>上下文管理器顾名思义是用于管理上下文（即环境）的，模式为 “上文 - 操作 - 下文”，即执行代码之前做一些预处理工作，执行之后做一些清理工作。</p></li><li><p>上下文管理器的常见使用场景：</p><ul><li><p>打开一个文件，然后进行操作，操作完成后关闭文件。</p></li><li><p>连接一个数据库，然后进行操作，操作完成后关闭连接。</p></li><li><p>连接一台服务器，然后获取数据上传数据，操作完成后关闭连接。</p></li></ul></li><li><p><code>Python</code> 引入 <code>with as</code> 语句，让我们用简单的代码实现上下文的管理，省去 <code>try</code> / <code>finally</code> 的繁琐操作，让代码简化。同时，<code>with as</code> 语句解决了异常发生时，资源无法及时被释放的问题。</p></li></ul><h3 id="4-2-with-as-语句">4.2 with as 语句</h3><ul><li><p><code>with as</code> 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的 “清理” 操作，释放资源，例：文件使用后自动关闭、线程中锁的自动获取和释放等。</p></li><li><p><code>with as</code> 语句语法格式（<code>as</code> 可选）：</p><ul><li><p>格式 <code>1</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> target]:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure></li><li><p>格式 <code>2</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> A() <span class="keyword">as</span> a, B() [<span class="keyword">as</span> b]:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure></li><li><p>格式 <code>3</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    A() [<span class="keyword">as</span> a],</span><br><span class="line">    B() [<span class="keyword">as</span> b],</span><br><span class="line">):</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>with as</code> 语句要求 <code>with</code> 后面的 <code>expression</code> 实现了 “<strong>上下文管理协议</strong>”，即实现了下面两个方法。实现这两个方法的类便是上下文管理器。</p><ul><li><p><code>__enter__(self)</code>：执行 <code>with</code> 后面的 <code>expression</code>时，上下文管理类中的 <code>__enter__()</code> 方法被调用，通常返回一个 <strong>实例化对象</strong>。</p></li><li><p><code>__exit__(self, exc_type, exc_valye, traceback)</code>：当 <code>with</code> 后面的代码块全部执行完毕后，将调用前面返回的实例化对象的 <code>__exit__()</code> 方法，一般用作 <strong>异常处理</strong>。</p></li></ul></li><li><p><code>Python</code> 内置了一些支持上下文管理协议的对象：</p><ul><li><p><code>file</code></p></li><li><p><code>decimal.Context</code></p></li><li><p><code>thread.LockType</code></p></li><li><p><code>threading.Lock</code></p></li><li><p><code>threading.RLock</code></p></li><li><p><code>threading.Condition</code></p></li><li><p><code>threading.Semaphore</code></p></li><li><p><code>threading.BoundedSemaphore</code></p></li></ul></li><li><p><code>with as</code> 语句的执行过程如下：</p><ul><li><p>执行上下文表达式（<code>expression</code>）以获得上下文管理器。</p></li><li><p>载入上下文管理器的 <code>__exit__()</code> 方法以便后续使用。</p></li><li><p>载入上下文管理器的 <code>__enter__()</code> 方法以便后续使用。</p></li><li><p>调用上下文管理器的 <code>__enter__()</code> 方法。如果指定了 <code>[as variable]</code> 说明符，将 <code>__enter__()</code> 的返回值赋给 <code>variable</code>。</p></li><li><p>执行 <code>with</code> 内的代码块。</p></li><li><p>调用上下文管理器的 <code>__exit__()</code> 方法。 如果代码块的退出是由异常导致的，那么该异常的 <code>type</code>（异常类型）、<code>value</code>（异常信息）和 <code>traceback</code>（堆栈）会作为参数传给 <code>__exit__()</code> 方法，否则传三个 <code>None</code>。如果 <code>__exit__()</code> 函数内部引发了异常，则会覆盖掉代码块的中的异常。<code>__exit_()</code> 方法返回 <code>True</code> 或 <code>False</code>，表示异常有没有被处理。</p><ul><li><p>如果代码块的退出是由异常导致的，并且来自 <code>__exit__()</code> 方法的返回值为 <code>False</code>（默认），则该异常会被重新抛出，中断代码块及代码块之后语句执行。</p></li><li><p>如果代码块的退出是由异常导致的，并且来自 <code>__exit__()</code> 方法的返回值为 <code>True</code>，则该异常会被忽略，停止执行代码块的剩余语句，但是会继续执行代码块后面的语句。</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 模块、包和库</title>
      <link href="/posts/Python/Python18.html"/>
      <url>/posts/Python/Python18.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-模块-py-文件">一、模块（.py 文件）</h2><h3 id="1-1-模块定义">1.1 模块定义</h3><ul><li><p>模块（<code>Modules</code>）是使用 <code>Python</code> 实现某一特定功能，包含所有定义的函数和变量的代码文件，其文件名是模块名加后缀名（<code>.py</code>）。</p></li><li><p>模块的类型为 <code>'module'</code>，即使用 <code>type(模块名)</code> 的返回值为 <code>&lt;class 'module'&gt;</code>。</p></li></ul><h3 id="1-2-import-使用">1.2 import 使用</h3><ul><li><p>在 <code>Python</code> 编程时，有些功能可以借助 <code>Python</code> 现有的标准库或者其他人提供的第三方库来实现。使用这些第三方库之前需要使用 <code>import</code> 关键字将其导入到自己的模块中。</p></li><li><p>当导入某个模块时，被导入的模块会被执行后再导入。</p></li><li><p>一个模块只会被另一个程序导入一次，也只会被执行一次。</p></li><li><p>使用 <code>import</code> 导入的语法主要有两种：</p><ul><li><p>方式一：<code>import 模块名1 [as 别名1], 模块名2 [as 别名2], ...</code></p><ul><li><p>可以直接导入 <strong>整个模块</strong>，不设置别名。例：<code>import math</code>。</p></li><li><p>导入 <strong>整个模块</strong> 时，也可以为模块指定别名。例：<code>import math as m</code>。</p></li><li><p><code>import</code> 支持一次导入多个模块，多个模块之间用逗号隔开。例：<code>import math, os</code>。</p></li><li><p><code>import</code> 导入多个模块时，也可以为模块指定别名。例：<code>import math as m, os as o</code>。</p></li><li><p>使用这种语法格式的 <code>import</code> 语句，会导入指定模块中的所有成员（变量、函数、类等）。</p></li><li><p>当需要使用模块中的成员时，需用该模块名（或别名）作为前缀，否则 <code>Python</code> 解释器会报错。例：<code>math.pi</code>（或<code>m.pi</code>）。</p></li></ul></li><li><p>方式二：<code>from  模块名 import 成员名1 as [as 别名1], 成员名2 [as 别名2], ...</code></p><ul><li><p>可以直接导入 <strong>模块成员</strong>，不设置别名。例：<code>from math import pi</code>。</p></li><li><p>导入模块成员时，也可以为成员指定别名。例：<code>from math import pi as p</code>。</p></li><li><p><code>form...import...</code> 支持一次导入多个成员，多个成员之间用逗号隔开。例：<code>from math import pi, inf</code>。</p></li><li><p><code>form...import...</code> 导入多个成员时，也可以为成员指定别名。例：<code>from math import pi as p, inf as i</code>。</p></li><li><p>使用 <code>form...import...</code> 语句会导入指定模块中的指定成员（变量、函数、类等）。当需要使用模块中的成员时，不需要再添加前缀。</p></li><li><p><code>from...import</code> 可以一次导入指定模块内的所有成员。例：<code>from math import *</code>。</p><ul><li>不推荐使用这种方式，因为当同时导入两个模块内的所有成员时，如果存在同名函数，程序运行时会报错。</li></ul></li></ul></li></ul></li><li><p><code>Python</code> 内置函数 <code>dir()</code> 可以查看模块内定义的所有成员（<strong>变量</strong>、<strong>函数</strong> 和 <strong>类</strong>），以字符串列表的形式返回。这里所指的所有成员，不仅包含外部可调用的模块成员，还包含所有名称以双下划线 “<code>__</code>” 开头和结尾的成员，而这些 “特殊” 命名的成员，是为了在本模块中使用的，并不希望被其它文件调用。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(math))</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;comb&#x27;</span>, <span class="string">&#x27;copysign&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;degrees&#x27;</span>, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;erf&#x27;</span>, <span class="string">&#x27;erfc&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;fabs&#x27;</span>, <span class="string">&#x27;factorial&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;frexp&#x27;</span>, <span class="string">&#x27;fsum&#x27;</span>, <span class="string">&#x27;gamma&#x27;</span>, <span class="string">&#x27;gcd&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;inf&#x27;</span>, <span class="string">&#x27;isclose&#x27;</span>, <span class="string">&#x27;isfinite&#x27;</span>, <span class="string">&#x27;isinf&#x27;</span>, <span class="string">&#x27;isnan&#x27;</span>, <span class="string">&#x27;isqrt&#x27;</span>, <span class="string">&#x27;lcm&#x27;</span>, <span class="string">&#x27;ldexp&#x27;</span>, <span class="string">&#x27;lgamma&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log2&#x27;</span>, <span class="string">&#x27;modf&#x27;</span>, <span class="string">&#x27;nan&#x27;</span>, <span class="string">&#x27;nextafter&#x27;</span>, <span class="string">&#x27;perm&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;prod&#x27;</span>, <span class="string">&#x27;radians&#x27;</span>, <span class="string">&#x27;remainder&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>, <span class="string">&#x27;tau&#x27;</span>, <span class="string">&#x27;trunc&#x27;</span>, <span class="string">&#x27;ulp&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-3-自定义模块">1.3 自定义模块</h3><ul><li><p><code>Python</code> 模块就是 <code>Python</code> 程序，换句话说，只要是 <code>Python</code> 程序，都可以作为模块导入。</p></li><li><p>下面定义了一个模块（编写在 <code>demo.py</code> 文件中）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;dong&quot;</span></span><br><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;info 函数&quot;</span>)</span><br><span class="line"><span class="comment"># 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,add</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.age)</span><br><span class="line"><span class="comment"># 测试语句</span></span><br><span class="line">info()</span><br><span class="line">person = Person(<span class="string">&quot;xin&quot;</span>, <span class="number">18</span>)</span><br><span class="line">person.info()</span><br></pre></td></tr></table></figure></li><li><p><code>test.py</code> 文件中仅有导入 <code>demo</code> 模块语句，不存在其他语句：<code>import demo</code>。</p></li><li><p>运行 <code>test.py</code> 文件，其执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dong <span class="number">19</span></span><br><span class="line">info 函数</span><br><span class="line">xin <span class="number">19</span></span><br></pre></td></tr></table></figure><ul><li><p>可以看到，当执行 <code>test.py</code> 文件时，它同样会执行 <code>demo.py</code> 中的测试语句，这显然不是我们想要的效果。正常的效果应该是，只有直接运行模板文件时，测试语句才会被执行；反之，如果是其它程序以引入的方式执行模板文件，则测试语句不应该被执行。</p></li><li><p>要实现上述效果，可以借助 <code>Python</code> 内置的 <code>__name__</code> <strong>属性</strong>，该属性记录当前运行的模块或脚本的名称。当直接运行一个模块时，<code>__name__</code> 属性的值为 <code>__main__</code>，而以引入（<code>import</code>）的方式执行模板文件时，处于模块中的 <code>__name__</code> 属性的值就变成了当前模块名。因此，如果希望测试语句只有在直接运行模块文件时才被执行，则可在调用测试函数时增加判断，即只有当 <code>__name__ =='__main__'</code> 时才执行测试语句。测试语句修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    info()</span><br><span class="line">    person = Person(<span class="string">&quot;xin&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    person.info()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以在自定义模块开头部分添加多行注释用作说明文档，让用户知道模块功能。</p><ul><li>可以通过 <code>模板名.__doc__</code> 的方式来访问模板的说明文档。例：<code>demo.__doc__</code></li></ul></li></ul><h3 id="1-4-模块查找路径">1.4 模块查找路径</h3><ul><li><p>对于用 <code>import</code> 语句导入的模块，<code>Python</code> 会按照以下顺序查找指定的模块文件：</p><ul><li><p>执行 <code>import</code> 语句的文件所在路径。</p></li><li><p>项目的根目录（<code>pycharm</code> 会默认将项目的根目录添加到 <code>sys.path</code> 中）。</p></li><li><p><code>Pycharm</code> 相关路径。</p></li><li><p><code>python path</code> 环境变量的每一个目录。</p><ul><li><p>查询 <code>pycharm</code> 的 <code>python path</code> 环境变量：<code>File</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Settings...</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Project:XXX</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Python Interpreter</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 设置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>show all</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Show paths for the selected interpreter</code></p><div align=center><img src="https://cdn.jsdelivr.net/gh/fandong93/PictureBed/python_module/01.png"/></div><ul><li><p><code>Lib</code> 目录：内置模块、包存放路径。</p></li><li><p><code>Lib\site-packages</code> 目录：下载的第三方库存放路径。</p></li></ul></li></ul></li><li><p>当前 <code>Python</code> 解释器所在路径。</p></li></ul></li><li><p>对于用 <code>import</code> 语句导入的模块所查找的路径，可以通过标准模块 <code>sys</code> 的 <code>sys.path</code> 变量进行查询（返回一个 <strong>列表</strong>）。换句话说，如果要导入的模块没有存储在 <code>sys.path</code> 显示的目录中，那么导入该模块并运行程序时，<code>Python</code> 解释器会抛出 <code>ModuleNotFoundError</code>（未找到模块）异常。</p></li><li><p>解决 <code>ModuleNotFoundError</code> 异常的方法有 <code>3</code> 种，分别是：</p><ul><li><p>使用 <code>sys.path.append</code> 函数向 <code>sys.path</code> 变量中 <strong>临时添加</strong> 模块文件所在的完整路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;D:\xxx\yyy&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>注：路径中的 ‘<code>\</code>’ 需要使用 <code>r</code> 保持原始字符串或使用 <code>\</code> 进行转义，否则会导致语法错误。</li></ul></li><li><p>将模块移动到 <code>sys.path</code> 变量中已包含的路径中。</p></li><li><p>将模块所在路径加入到 <code>path</code> 环境变量。</p></li></ul></li></ul><h3 id="1-5-all-属性">1.5 __all__属性</h3><ul><li><p>当我们向文件导入某个模块时，导入的是该模块中不以下划线（单下划线 “<code>_</code>” 或 双下划线“<code>__</code>”）开头的变量、函数和类。因此，如果我们不想自定义模块中的某个成员被引入到其它文件中，可以在其名称前添加下划线。</p></li><li><p>除此之外，我们还可以借助模块提供的 <code>__all__</code> 属性，该变量的值是一个列表，其中存储的是当前模块中一些成员（变量、函数或者类）的名称。通过在模块文件中设置 <code>__all__</code> 属性，当其它文件以 “<code>from 模块名 import *</code>” 的形式导入该模块时，该文件中只能使用 <code>__all__</code> 列表中指定的成员。</p></li><li><p><code>__all__</code> 属性仅限于在其它文件中以 “<code>from 模块名 import *</code>” 的方式引入。如果使用以下 <code>2</code> 种方式引入模块，则 <code>__all__</code> 属性的设置是无效的。</p><ul><li><p>以 “<code>import 模块名</code>” 的形式导入模块。通过该方式导入模块后，总可以通过模块名（别名）前缀来调用模块内的所有成员（除了以下划线开头命名的成员）。</p></li><li><p>以 “<code>from 模块名 import 成员</code>” 的形式直接导入指定成员（非下划线开头命名的成员）。使用此方式导入的模块，<code>__all__</code> 属性的设置无效。</p></li></ul></li><li><p>除了上述功能之外，还可以使用 <code>__all__</code> 属性查看模块内包含的所有成员。和 <code>dir()</code> 函数相比，<code>__all__</code> 属性在查看指定模块时，它不会显示模块中的特殊成员，同时还会根据成员的名称进行排序显示。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string.__all__)</span><br></pre></td></tr></table></figure><ul><li><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;ascii_letters&#x27;</span>, <span class="string">&#x27;ascii_lowercase&#x27;</span>, <span class="string">&#x27;ascii_uppercase&#x27;</span>, <span class="string">&#x27;capwords&#x27;</span>, <span class="string">&#x27;digits&#x27;</span>, <span class="string">&#x27;hexdigits&#x27;</span>, <span class="string">&#x27;octdigits&#x27;</span>, <span class="string">&#x27;printable&#x27;</span>, <span class="string">&#x27;punctuation&#x27;</span>, <span class="string">&#x27;whitespace&#x27;</span>, <span class="string">&#x27;Formatter&#x27;</span>, <span class="string">&#x27;Template&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>并非所有的模块都支持使用 <code>__all__</code> 属性（例：<code>math</code> 模块），因此对于获取有些模块的成员，就只能使用 <code>dir()</code> 函数。</p></li></ul></li></ul><h3 id="1-6-doc-属性">1.6 __doc__属性</h3><ul><li><p><code>__doc__</code> 是 <code>python</code> 模块的内置属性，使用 <code>模块名.__doc__</code> 可以返回模块说明文档（本质是字符串，位于该成员内部开头的位置）。如果模块是包的话，则返回包的 <code>__init__.py</code> 文件的说明文档。</p></li><li><p>使用内置函数 <code>help(object)</code> 同样可以查看模块说明文档，<code>help()</code> 函数底层是借助 <code>__doc__</code> 实现的。</p></li></ul><h3 id="1-7-file-属性">1.7 __file__属性</h3><ul><li><p><code>__file__</code> 是 <code>python</code> 模块的内置属性，使用 <code>模块名.__file__</code> 可以返回模块文件的绝对路径，如果模块是包的话，则返回包的 <code>__init__.py</code> 文件的绝对路径。</p></li><li><p>并不是所有模块都提供 <code>__file__</code> 属性，因为并不是所有模块都采用 <code>Python</code> 实现，有些模块采用的是其它编程语言（例：<code>C</code> 语言）。</p></li></ul><h2 id="二-包-存放多个模块的文件夹">二、包（存放多个模块的文件夹）</h2><h3 id="2-1-包的概述">2.1 包的概述</h3><ul><li><p>包是存在一个名为 “<code>__init__.py</code>” 的文件（<code>Python 3</code> 中非必须）的文件夹。</p><ul><li>当一个包被导入（<code>import</code>）时，<code>__init__.py</code> 文件会自动被执行。</li></ul></li><li><p>包的本质还是模块，因此使用 <code>type(包名)</code> 的返回值为 <code>&lt;class 'module'&gt;</code>。</p></li><li><p>和文件夹一样，包里面还可以装其他的包。</p></li></ul><h3 id="2-2-包的作用">2.2 包的作用</h3><ul><li><p>避免相同命名冲突：在同一个包内，不允许两个模块命名相同，但是不在同一个包中是可以的。</p></li><li><p>模块分区：把不同功能的模块归类到不同的包中，方便查询和修改。在比较大型的项目中需要编写大量的模块，此时我们可以使用包来对这些模块进行管理。</p></li></ul><h3 id="2-3-创建包">2.3 创建包</h3><ul><li><p>创建一个包，需进行以下 <code>2</code> 步操作：</p><ul><li><p>新建一个文件夹，文件夹的名称就是新建包的包名。</p></li><li><p>在该文件夹中，创建一个 <code>__init__.py</code> 文件（前后各有 <code>2</code> 个下划线 “<code>_</code>”），该文件中可以不编写任何代码。当然，也可以编写一些 <code>Python</code> 初始化代码，当有其它程序文件导入包时，会自动执行该文件中的代码。</p></li></ul></li><li><p>创建包后，可以向包中继续添加模块（也可以添加包）。</p></li></ul><h3 id="2-4-导入包">2.4 导入包</h3><ul><li>包的本质还是模块，因此导入模块的语法同样也适用于导入包。</li></ul><h4 id="2-4-1-import-包名-模块名-as-别名">2.4.1 import 包名.模块名 as 别名</h4><ul><li><p><code>import 包名[.模块名 [as 别名]]</code>，用 <code>[]</code> 括起来的部分是可选部分。</p></li><li><p>通过此语法格式导入包中指定模块后，在使用该模块中的成员（变量、函数、类）时，需添加 “<code>包名.模块名（别名）</code>” 作为前缀。</p></li><li><p>当导入指定模块时，程序会自动执行该包所对应文件夹下的 <code>__init__.py</code> 文件中的代码。</p></li><li><p>直接导入包名，并不会将包中所有模块全部导入到程序中，它的作用仅仅是导入并执行包中的 <code>__init__.py</code> 文件，后续使用包中成员时会抛出 <code>AttributeError</code> 异常。</p></li><li><p><code>import 包名.*</code> 会抛出 <code>SyntaxError: invalid syntax</code> 异常。</p></li></ul><h4 id="2-4-2-from-包名-import-模块名-as-别名">2.4.2 from 包名 import 模块名 as 别名</h4><ul><li><p><code>from 包名 import 模块名 [as 别名]</code>，使用 <code>[]</code> 括起来的部分是可选部分。</p></li><li><p>通过此语法格式导入包中指定模块后，在使用该模块中的成员时不需要添加包名前缀，但需要添加 “<code>模块名（别名）</code>” 作为前缀。</p></li><li><p><code>from 包名 import *</code> 与 <code>import 包名</code> 的作用一样，都只是将该包中的 <code>__init__.py</code> 文件导入并执行，后续使用包中成员时会抛出 <code>AttributeError</code> 异常。</p></li></ul><h4 id="2-4-3-from-包名-模块名-import-成员名-as-别名">2.4.3 from 包名.模块名 import 成员名 as 别名</h4><ul><li><p><code>from 包名.模块名 import 成员名 [as 别名]</code>，使用 <code>[]</code> 括起来的部分是可选部分。</p></li><li><p>通过此语法格式导入 “<code>包名.模块名</code>” 中的指定成员（变量、函数或类），在使用该成员时可以直接使用成员的名字（变量名、函数名或类名）进行调用，不需要添加任何前缀。</p></li><li><p>通过此种语法格式导入指定包中的指定模块时，可以使用 <code>*</code> 代替该模块中的成员名，表示加载该模块下的所有成员。</p></li></ul><h4 id="2-4-4-all-属性">2.4.4 __all__属性</h4><ul><li><code>__all__</code> 属性可以用于模块中，<code>__init__.py</code> 本质也是一个模块，在包的 <code>__init__.py</code> 中使用 <code>__all__</code> 属性可以指定使用 “<code>from 包名.模块名 import *</code>” 的形式导入包中模块时，只能导入 <code>__all__</code> 列表中指定的模块。</li></ul><h2 id="三-库">三、库</h2><ul><li><p>在 <code>Python</code> 中，具有某些 <strong>相关功能</strong> 的模块和包的 <strong>集合</strong> 都可以被称作库。</p></li><li><p><code>Python</code> 标准库就是下载安装的 <code>python</code> 中 <strong>自带</strong> 的所有模块的总称，可以称为 <strong>第一方库</strong>。</p></li><li><p><strong>第二方库</strong> 就是我们 <strong>自己编写</strong> 的所有模块的总称。</p></li><li><p><strong>第三方库</strong> 就是 <strong>别人提供</strong> 的模块的总称。我们可以通过下列三种方式安装（卸载）第三方库：</p><ul><li><p>方式一：使用 <code>PyCharm</code> 进行安装（卸载）</p><ul><li><p>安装：<code>File</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Settings...</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Project:XXX</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Python Interpreter</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 关闭 <code>ues Conda Package manger</code> （绿色按钮）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 加号 <code>+</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 搜索要下载的库名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>install package</code></p><div align=center><img src="https://cdn.jsdelivr.net/gh/fandong93/PictureBed/python_module/02.png"/></div><ul><li><p>第三方库安装位置为：<code>..\anaconda\envs\py39torch\Lib\site-packages</code></p></li><li><p>点击下方 <code>Manage Repositories</code> 可以更换国内源（选择下方一个）：</p><ul><li><p>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple</code></p></li><li><p>豆瓣：<code>http://pypi.douban.com/simple/</code></p></li><li><p>阿里：<code>http://mirrors.aliyun.com/pypi/simple/</code></p></li><li><p>腾讯：<code>http://mirrors.cloud.tencent.com/pypi/simple</code></p></li></ul></li></ul></li><li><p>卸载：<code>File</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Settings...</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Project:XXX</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>Python Interpreter</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 关闭 <code>ues Conda Package manger</code> （绿色按钮）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 选中要删除的库名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 减号 <code>+</code></p><div align=center><img src="https://cdn.jsdelivr.net/gh/fandong93/PictureBed/python_module/03.png"/></div></li></ul></li><li><p>方式二：使用命令行安装（卸载）</p><ul><li><p>安装：打开 <code>anaconda</code> 的命令行 “<code>Anaconda Prompt (anaconda)</code>” 或 “<code>Anaconda Prompt (虚拟环境)</code>”，输入 <code>pip install PackageName</code> 或 <code>conda install PackageName</code>，即可安装第三方库。</p><ul><li><p>“<code>Anaconda Prompt (anaconda)</code>” 安装位置为：<code>..\anaconda\Lib\site-packages</code></p></li><li><p>“<code>Anaconda Prompt (虚拟环境)</code>” 安装位置为：<code>..\anaconda\envs\虚拟环境名\Lib\site-packages</code></p></li></ul></li><li><p>卸载：<code>pip uninstall PackageName</code> 或 <code>conda uninstall PackageName</code>。</p></li></ul></li><li><p>方式三：先把要安装的第三方库文件（<code>.whl</code> 后缀文件）下载到本地再进行安装。</p><ul><li><p>推荐网址：<code>https://www.lfd.uci.edu/~gohlke/pythonlibs/</code>， 打开网站 <code>ctrl + F</code> 搜索要下载的库。</p></li><li><p>打开 <code>anaconda</code> 的命令行 “<code>Anaconda Prompt (anaconda)</code>” 或 “<code>Anaconda Prompt (虚拟环境)</code>”，输入 <code>pip install .whl文件所在路径 + whl文件名</code> 或 <code>conda install .whl文件所在路径 + whl文件名</code>，即可安装第三方库。例：<code>pip install D:\GoogleDownload\wordcloud-1.8.1-cp39-cp39-win_amd64.whl</code></p><div align=center><img src="https://cdn.jsdelivr.net/gh/fandong93/PictureBed/python_module/04.png"/></div><ul><li>“<code>Anaconda Prompt</code>” 中安装的第三方库，都会被安装在 <code>..\Lib\site-packages</code> 文件夹中。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 生成器和迭代器</title>
      <link href="/posts/language/python/python3/python17.html"/>
      <url>/posts/language/python/python3/python17.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E4%B8%80%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1">一、可迭代对象</a><ul><li><a href="#11-%E6%A6%82%E8%BF%B0">1.1 概述</a></li><li><a href="#12-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA-iterable">1.2 判断是否为 Iterable</a></li><li><a href="#14-__iter__-%E6%96%B9%E6%B3%95">1.4 __iter__ 方法</a></li><li><a href="#14-__getitem__-%E6%96%B9%E6%B3%95">1.4 __getitem__ 方法</a></li></ul></li><li><a href="#%E4%BA%8C%E8%BF%AD%E4%BB%A3%E5%99%A8">二、迭代器</a></li></ul><h2 id="一-可迭代对象">一、可迭代对象</h2><h3 id="1-1-概述">1.1 概述</h3><ul><li><p>在 <code>Python</code> 中，任意实现了 <strong>迭代协议</strong>（<code>__iter__</code> 方法）或 <strong>序列协议</strong>（<code>__getitem__</code>方法）的对象（<code>Python</code> 一切皆对象）都是可迭代对象（<code>Iterable</code>）。</p></li><li><p>我们把可以通过 <code>for...in...</code> 语句迭代读取每一条数据元素的对象也称之为可迭代对象。</p></li><li><p>可迭代对象不一定会是迭代器。</p></li><li><p>常见的可迭代对象（不是迭代器）：字典（<code>dict</code>）、集合（<code>set</code>）、序列（<code>list</code>、<code>tuple</code>、<code>str</code>）、<code>range</code> 对象。</p><div align=center>  <img src="https://cdn.jsdelivr.net/gh/fandong93/PictureBed/Python/17/01.png" width="399"/></div></li></ul><h3 id="1-2-判断是否为-iterable">1.2 判断是否为 Iterable</h3><ul><li><p>使用 <code>isinstance(self, Iterable)</code> / <code>issubclass(cls, Iterable)</code> 函数检测一个实例对象（<code>self</code>）/ 类对象（<code>cls</code>）是否为可迭代对象的方式 <strong>不是十分准确</strong>。</p><ul><li><p><strong>不准确原因</strong>：<code>isinstance</code> 和 <code>issubclass</code> 判断一个对象是否为可迭代对象只检查 <code>__iter__</code> 方法是否被实现，而不会检查 <code>__getitem__</code> 方法。</p></li><li><p><strong>推荐方式</strong>：检查 <code>__iter__</code> 方法或 <code>__getitem__</code> 方法是否被实现。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>) <span class="keyword">or</span> <span class="string">&quot;__getitem__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-iter-方法">1.4 __iter__ 方法</h3><ul><li><p><code>__iter__(self)</code> 方法返回一个特殊的迭代器对象，这个迭代器对象实现了 <code>__next__(self)</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。</p></li><li><p>在对一个对象进行迭代操作时（例：<code>for...in...</code>），会自动调用 <code>__iter__</code> 方法，返回一个迭代器对象，然后每一次迭代，都会使用该迭代器对象调用一次 <code>__next__</code> 方法，直到抛出 <code>StopIteration</code> 异常。</p></li><li><p><code>Python</code> 语言内部会自动处理 <code>for</code> 循环和其他迭代上下文中的 <code>StopIteration</code> 异常。</p><ul><li>迭代上下文包括for循环，列表推导，内置in运算符，内置函数sorted,sum,any,all，除此之外还包括list,tuple,字符串join方法以及序列赋值运算，所有这些都使用了迭代协议来一次处理一个元素。</li></ul></li></ul><h3 id="1-4-getitem-方法">1.4 __getitem__ 方法</h3><ul><li><p><code>__getitem__</code> 方法可以让对象实现 <strong>迭代功能</strong>，返回与指定键相关联的值。</p><ul><li><p>对于序列来说，键应该是整数类型。</p></li><li><p>对于映射来说，键可以是任何类型。</p></li></ul></li><li><p>在对一个对象进行迭代操作时（例：<code>for...in...</code>），会自动调用 <code>__iter__</code> 方法。如果对象没有实现 <code>__iter__</code> 迭代协议，<code>Python</code> 解释器会去寻找 <code>__getitem__</code> 方法（序列协议）来迭代对象，如果 <code>__getitem__</code> 没有被实现，解释器就会抛出异常 <code>TypeError: 'xxx' object is not iterable</code>。</p></li><li><p>如果一个类实现了 <code>__getitem__(self, item)</code> 方法，每一次迭代都会自动调用 <code>__getitem__</code> 方法，<code>item</code> 从 <code>0</code> 开始依次递增，直到发生 <code>IndexError</code> 为止。</p></li></ul><h2 id="二-迭代器">二、迭代器</h2><ul><li><p>在 <code>Python</code> 中，一个对象是迭代器，那它一定是可迭代对象，反之不然。一个对象拥有 <code>__iter__</code> 方法就能够成为可迭代对象，但是迭代器必须实现 <strong>迭代器协议</strong>，即 <strong>同时实现</strong> <code>__iter__</code> 和 <code>__next__</code> 方法。</p><ul><li>一个对象是迭代器，那它一定实现了 <code>__iter__</code>方法，实现了 <code>__iter__</code>方法就一定是可迭代对象。</li></ul></li><li><p>常见的迭代器：<code>reversed</code>、<code>zip</code>、<code>enumerate</code>、<code>filter</code>、<code>map</code>。</p></li><li><p>可以使用 <code>isinstance(self, Iterator)</code> / <code>issubclass(cls, Iterator)</code> 函数检测一个实例对象（<code>self</code>）/ 类对象（<code>cls</code>）是否为迭代器。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator</span><br><span class="line">obj = <span class="built_in">reversed</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(obj, Iterator))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">reversed</span>, Iterator))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><ul><li><code>Iterator</code> 是 <code>typing</code> 模块提供的一种数据类型，使用前需要导入。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 闭包和装饰器</title>
      <link href="/posts/language/python/python3/python16.html"/>
      <url>/posts/language/python/python3/python16.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-闭包">一、闭包</h2><h3 id="1-1-概述">1.1 概述</h3><ul><li>在 <code>Python</code> 中，函数可以（嵌套）定义另一个函数中，如果内部函数引用了外部函数的变量，并且外部函数的返回值是内部函数的引用，那么内部函数就被认为是 <strong>闭包</strong>（<code>closure</code>）<strong>函数</strong>。</li></ul><h3 id="1-2-自由变量">1.2 自由变量</h3><ul><li><p>闭包函数中被引用的非全局变量被称为 <strong>自由变量</strong>，自由变量是指未被绑定到本地作用域的变量。</p><ul><li><p>如果自由变量绑定的值是可变的，该变量仍然可以在闭包函数中操作。</p></li><li><p>如果自由变量绑定的值是不可变的(例：数字、字符串、元组等)，在闭包函数中重新绑定自由变量会抛出异常。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    free = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        free *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> free</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># UnboundLocalError: local variable &#x27;free&#x27; referenced before assignment</span></span><br><span class="line"><span class="built_in">print</span>(outer()())</span><br></pre></td></tr></table></figure></li><li><p>可以使用 <code>nonlocal</code> 关键字将变量标记为自由变量。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    free = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> free</span><br><span class="line">        free *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> free</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(outer()())</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-3-closure-属性">1.3 __closure__属性</h3><ul><li><p>闭包函数比普通函数多了一个 <code>__closure__</code> 属性，该属性存储着记录自由变量值的 <code>cell</code> 对象。当闭包函数被调用时，系统就会根据该属性找到对应的自由变量，完成函数的调用。</p></li><li><p>正是因为闭包函数的 <code>__closure__</code> 属性，使得外部函数调用结束之后，自由变量依然可以被闭包函数使用。</p></li><li><p><code>__closure__</code> 属性的类型是一个 <strong>元组</strong>，元组中的每个元素都是 <code>cell</code> 对象，每一个 <code>cell</code> 对象都用来保存自由变量的值。我们可以使用索引获取到一个 <code>cell</code> 对象，然后调用它的 <code>cell_contents</code> 属性就可以获取到自由变量的值。</p></li><li><p>示例 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">var1, var2</span>):</span><br><span class="line">    free1 = <span class="number">2</span></span><br><span class="line">    free2 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">in_var</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> free1, free2</span><br><span class="line">        <span class="keyword">return</span> (free1 * free2 * var1 ** var2) // in_var</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = outer(<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> o.__closure__:</span><br><span class="line">    <span class="built_in">print</span>(ele.cell_contents, end=<span class="string">&quot;,&quot;</span>)  <span class="comment"># 2,3,5,7,</span></span><br></pre></td></tr></table></figure></li><li><p>示例 <code>2</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    funcs = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">            <span class="keyword">return</span> k * k</span><br><span class="line">        funcs.append(inner)</span><br><span class="line">    <span class="keyword">return</span> funcs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = outer()</span><br><span class="line"><span class="built_in">print</span>(f1.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line"><span class="built_in">print</span>(f2.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line"><span class="built_in">print</span>(f3.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line"><span class="built_in">print</span>(f1())</span><br><span class="line"><span class="built_in">print</span>(f2())</span><br><span class="line"><span class="built_in">print</span>(f3())</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-闭包作用">1.4 闭包作用</h3><ul><li><p>作用 <code>1</code>：实现函数外部代码读取外层函数内部的自由变量。</p><ul><li>外部代码可以调用外层函数，然后利用外层函数返回的闭包函数引用读取外层函数内部的自由变量。</li></ul></li><li><p>作用 <code>2</code>：将外层函数的自由变量持久地保存在内存中。</p><ul><li>一般来说，函数内部的局部变量在这个函数运行完以后，就会被 <code>Python</code> 的垃圾回收机制从内存中清除掉。如果我们希望这个局部变量能够长久的保存在内存中，那么就可以用闭包来实现这个功能。</li></ul></li></ul><h2 id="二-装饰器">二、装饰器</h2><h3 id="2-1-概述">2.1 概述</h3><ul><li><p>装饰器（<code>Decorator</code>）从名字上理解，就是起到装饰作用的器件。装饰器的作用就是在不修改原有代码的情况下，为被装饰的 <strong>函数</strong> 增加额外的功能。</p></li><li><p>从装饰器的实现方式上可以分为 <strong>函数装饰器</strong> 和 <strong>类装饰器</strong>，也即分别使用函数或类对函数进行装饰，装饰器的返回值也是一个函数或类。</p></li><li><p>在 <code>Python</code> 中，一切皆对象，函数也是对象，也可以赋值给一个变量，可以像普通变量一样当做参数传递给另外一个函数。</p></li><li><p>装饰器的实现基础就是闭包，可以将被修饰的函数对象嵌入到另外一个函数对象中，并且通过闭包的概念，将扩展功能需要的参数，捕获到闭包内，从而实现装饰器属性的定制化设置。</p></li></ul><h3 id="2-2-语法糖">2.2 @ 语法糖</h3><ul><li><p><code>@</code> 符号用做函数的修饰符，可以在模块或者类的定义层内对函数进行修饰，出现在函数定义的前一行，不允许和函数定义在同一行。</p></li><li><p>一个修饰符就是一个函数，它将被修饰的函数作为参数，并返回修饰后的同名函数或其他可调用的东西（如果返回不是一个可调用的对象那么会报错）。</p></li></ul><h3 id="2-3-装饰器的引入">2.3 装饰器的引入</h3><ul><li><p>定义一个函数，循环 <code>10000000</code> 次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000000</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>现在有一个新的需求，希望可以计算一下函数运行消耗的时间。我们可以修改原函数，但是假如有很多个类似的函数，都需要更改需求，工作量就很大，而且增加了许多重复代码。我们可以重新定义一个函数，在函数中调用原函数，然后计算函数执行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_time</span>(<span class="params">func</span>):  <span class="comment"># 可以将 loop 函数传入</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    end = time.time()</span><br><span class="line">    cost_time = end - start</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;花费时间：<span class="subst">&#123;cost_time&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的不再真正的业务逻辑 <code>loop</code> 函数，而是换成了 <code>cal_time</code> 函数，这就破坏了原有的代码结构，现在我们不得不每次都要把 <code>loop</code> 函数作为参数传递给 <code>cal_time</code> 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p></li></ul><h3 id="2-4-函数装饰器">2.4 函数装饰器</h3><h4 id="2-4-1-无参函数装饰器">2.4.1 无参函数装饰器</h4><ul><li><p>使用函数作为装饰器的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_time</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        cost_time = end - start</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;花费时间：<span class="subst">&#123;cost_time&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000000</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">loop = cal_time(loop)</span><br><span class="line">loop()  <span class="comment"># 花费时间：0.08998990058898926秒</span></span><br></pre></td></tr></table></figure><ul><li>上述代码中的 <code>cal_time</code> 函数就是一个装饰器，它是一个普通的函数，它把执行真正业务逻辑的函数 <code>loop</code> 包裹在其中，看起来像 <code>loop</code> 被 <code>cal_time</code> <code>cal_time</code> 返回的也是一个函数，这个函数的名字叫 <code>wrapper</code>。有了装饰器，就可以抽离出大量与业务逻辑无关的重复代码。</li></ul></li><li><p>上面的写法还是不够简洁，<code>Python</code> 为装饰器专门提供了语法糖 <code>@</code> 符号。<code>@</code> 符号可以将被修饰的函数作为参数传入到 <code>@</code> 符号后面的函数中，返回一个与被修饰的函数同名的函数。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_time</span>(<span class="params">func</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        cost_time = end - start</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;花费时间：<span class="subst">&#123;cost_time&#125;</span>秒&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">  </span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000000</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">loop()  <span class="comment"># 花费时间：0.0899655818939209秒</span></span><br></pre></td></tr></table></figure><ul><li><p>上述代码说明，有了 <code>@</code> 符号就可以省去 <code>loop = cal_time(loop)</code>，直接调用 <code>loop()</code> 即可得到想要的结果。</p></li><li><p>执行顺序说明：</p><ul><li><p>代码从上向下执行，先导入 <code>time</code> 模块，定义 <code>cal_time</code> 函数，执行到 <code>@DecoratorClass</code> 装饰器。</p></li><li><p>该函数装饰器 <strong>没有被调用</strong>, 再定义 <code>function</code> 函数, 当被装饰的函数定义好了, 则将被装饰的函数作为参数传入装饰器函数并执行, 即 <code>cal_time(func)</code>, 返回 <code>wrapper</code> 函数的引用。因此被装饰后的函数 <code>loop</code> 实际上已经是 <code>wrapper</code> 函数的引用。</p></li><li><p>所以当最后执行 <code>loop</code> 时，其实等价于 <code>wrapper()</code>。</p></li></ul></li></ul></li></ul></li><li><p>当业务逻辑函数 <code>loop</code> <strong>需要参数</strong> 时，我们可以在定义 <code>wrapper</code> 函数的时候指定参数，这样 <code>loop</code> 函数定义的参数就可以定义在 <code>wrapper</code> 函数中。当 <code>wrapper</code> 函数不知道 <code>loop</code> 函数到底有多少个参数时，可以使用不定长参数 <code>*args</code>。关键字参数 <code>**kwargs</code> 同理。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args)</span><br><span class="line">        end = time.time()</span><br><span class="line">        cost_time = end - start</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;花费时间：<span class="subst">&#123;cost_time&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop(<span class="number">100000000</span>)  <span class="comment"># 花费时间：0.976708173751831秒</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-4-2-含参函数装饰器">2.4.2 含参函数装饰器</h4><ul><li><p>通过无参函数装饰器的例子，我们应该已经明白装饰器的价值和它的简单用法：通过闭包来实现装饰器，<strong>原始函数</strong> 作为外层函数的传入 <strong>参数</strong>，然后在内层函数中运行、增加功能，随后把内层函数的 <strong>引用</strong> 作为结果返回。</p></li><li><p>在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 <code>loop</code>。装饰器的语法允许我们在调用时，提供其它参数，例：<code>@cal_time(var)</code>。这样，就为装饰器的编写和使用提供了更大的灵活性。</p></li><li><p>为了让装饰器可以带参数，需要在原装饰器 <strong>外部</strong> 再 <strong>封装一层</strong>，最外层负责传入装饰器参数，内层负责传入业务函数的引用，最内层负责传入业务函数的参数。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop_times</span>(<span class="params">times=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_time</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">                func(*args)</span><br><span class="line">            end = time.time()</span><br><span class="line">            cost_time = end - start</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;花费时间：<span class="subst">&#123;cost_time&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> cal_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@loop_times(<span class="params">times=<span class="number">10</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop(<span class="number">10000000</span>)  <span class="comment"># 花费时间：0.9382853507995605秒</span></span><br></pre></td></tr></table></figure><ul><li><p>执行顺序说明：</p><ul><li><p>代码从上向下执行，先导入 <code>time</code> 模块，定义 <code>loop_times</code> 函数，执行到 <code>@loop_times(times=10)</code> 装饰器。</p></li><li><p>该函数装饰器此时 <strong>被调用</strong>, 再定义 <code>cal_time</code> 函数, 并返回其引用。</p></li><li><p>然后定义被修饰的函数 <code>loop</code>，当被装饰的函数定义好了, 则将被装饰的函数作为参数传入装饰器返回的 <code>cal_time</code> 函数并执行。</p></li><li><p>再定义 <code>wrapper</code> 函数并返回其引用。因此被装饰后的函数 <code>loop</code> 实际上已经是 <code>wrapper</code> 函数的引用。</p></li><li><p>所以当最后执行 <code>loop</code> 时，其实等价于 <code>wrapper()</code>。</p></li></ul></li></ul></li></ul><h3 id="2-5-类装饰器">2.5 类装饰器</h3><h4 id="2-5-1-无参类装饰器">2.5.1 无参类装饰器</h4><ul><li><p>装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有更大灵活性，高内聚，封装性等特点。使用类装饰器主要依靠类的 <code>__call__</code> 方法，类装饰器必须定义 <code>__call__</code> 方法，它将一个类的实例对象变成一个可被调用的方法。当使用 <code>@</code> 形式将类装饰器的实例对象附加到函数上时，调用函数实际上就是调用实例对象。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call DecoratorClass.__init__()&quot;</span>)</span><br><span class="line">        f()  <span class="comment"># Prove that function definition has completed</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call DecoratorClass.__call__()&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@DecoratorClass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;call func()&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DecoratorClass Finish&quot;</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><ul><li><p>上述代码中，函数 <code>func</code> 使用类 <code>DecoratorClass</code> 作为装饰器，输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call DecoratorClass.__init__()</span><br><span class="line">call <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">DecoratorClass Finish</span><br><span class="line">call DecoratorClass.__call__()</span><br></pre></td></tr></table></figure></li><li><p>执行顺序说明：</p><ul><li><p>代码从上向下执行，先定义 <code>DecoratorClass</code> 类和类中的方法，执行到 <code>@DecoratorClass</code> 装饰器时，该类装饰器 <strong>没有实例化</strong>。</p></li><li><p>继续向下，定义 <code>func</code> 函数，当被装饰的函数定义好之后，将被装饰的函数作为参数 <code>f</code> 传入类装饰器 <code>DecoratorClass</code> 的 <code>__new__()</code> 方法，创建了一个实例对象。然后继续将参数 <code>f</code> 传入 <code>__init__()</code> 方法。输出：<code>call DecoratorClass.__init__()</code>。</p></li><li><p><code>__init__()</code> 方法中调用了输入参数 <code>f()</code>，实际调用的就是 <code>func()</code> 方法。输出：<code>call func()</code>。</p></li><li><p><code>__init__()</code> 方法执行结束后，类装饰器返回给被装饰的 <code>func</code> 函数一个实例化的对象。因此被装饰后的函数 <code>func</code> 实际上已经是类 <code>DecoratorClass</code> 的实例。</p></li><li><p>至此 <code>func</code> 函数的声明完成，包括装饰器声明的部分，然后输出：<code>DecoratorClass Finish</code>。</p></li><li><p>最后执行 <code>func()</code> 时，可以看出实际上是执行了类 <code>DecoratorClass</code> 的 <code>__call__()</code> 方法（定义了 <code>__call__()</code> 方法的类的对象可以像函数一样被调用），输出：<code>call DecoratorClass.__call__()</code>。</p></li></ul></li></ul></li></ul><h4 id="2-5-2-带参类装饰器">2.5.2 带参类装饰器</h4><ul><li><p>带参数的类装饰器和不带参数的类装饰器有很大的不同。带参数的类装饰器中的 <code>__init__</code> 方法不再接收被装饰函数，而是接收传入参数。使用 <code>__call__</code> 方法接收被装饰函数，为了把函数的参数传入，必须在 <code>__call__()</code> 方法内部再封装一层，即实现封包。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;这是一个测试类，作者<span class="subst">&#123;self.name&#125;</span>，永远<span class="subst">&#123;self.age&#125;</span>岁&quot;</span>)</span><br><span class="line">            f(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@DecoratorClass(<span class="params"><span class="string">&quot;dong&quot;</span>, <span class="number">18</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">var</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;就随便传了个参数<span class="subst">&#123;var&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="string">&quot;挺随便的&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>上述代码中，函数 <code>func</code> 使用带参数的类装饰器，输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个测试类，作者dong，永远<span class="number">18</span>岁</span><br><span class="line">就随便传了个参数挺随便的</span><br></pre></td></tr></table></figure></li><li><p>执行顺序说明：</p><ul><li><p>代码从上向下执行，先定义 <code>DecoratorClass</code> 类和类中的方法, 执行到 <code>@DecoratorClass</code> 装饰器时，该类装饰器 <strong>进行实例化</strong>，调用 <code>__new__</code> 方法创建实例对象，使用 <code>__init__</code> 方法进行初始化，然后返回实例对象，再定义 <code>func</code> 函数。</p></li><li><p>当被装饰的函数 <code>func</code> 定义好了，则将被装饰的函数作为参数调用实例对象，即 <code>DecoratorClass(&quot;dong&quot;, 18)(func)</code>。</p></li><li><p>调用实例对象即调用 <code>__call__</code> 方法，定义了一个闭包函数 <code>wrapper</code> 并返回其引用。</p></li><li><p>最后执行 <code>func(&quot;挺随便的&quot;)</code> 时，可以看出实际上是执行了 <code>wrapper(&quot;挺随便的&quot;)</code> 方法，输出：<code>这是一个测试类，作者dong，永远18岁</code>。</p></li><li><p><code>wrapper</code> 方法内部又调用了一次 <code>func</code> 函数，输出：<code>就随便传了个参数挺随便的</code>。</p></li></ul></li></ul></li></ul><h3 id="2-6-多装饰器">2.6 多装饰器</h3><ul><li><p>一个函数可以同时定义多个装饰器，它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):  <span class="comment"># func: wrapper2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper1</span>(<span class="params">*args</span>):  <span class="comment"># args: (5, 6, 7)</span></span><br><span class="line">        res = func(*args)  <span class="comment"># res = wrapper2(5, 6, 7)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):  <span class="comment"># func: add</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper2</span>(<span class="params">*args</span>):  <span class="comment"># args: (5, 6, 7)</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args)  <span class="comment"># res = add(5, 6, 7)</span></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函数耗时:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(end_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">timer(add) =&gt; wrapper2</span></span><br><span class="line"><span class="string">deco(wrapper2) =&gt; wrapper1</span></span><br><span class="line"><span class="string">add = wrapper1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):  <span class="comment"># add = wrapper1</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   函数耗时:3.0080790519714355</span></span><br><span class="line"><span class="comment">#   18</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>))  <span class="comment"># wrapper1(5, 6, 7)</span></span><br></pre></td></tr></table></figure><ul><li><p>执行顺序说明：</p><ul><li><p>代码从上向下执行，先导入 <code>time</code> 模块，定义 <code>deco</code> 函数和 <code>timer</code> 函数, 执行到 <code>@deco</code> 和 <code>@timer</code>。</p></li><li><p>这两个装饰器都 <strong>没有被调用</strong>, 再定义 <code>add</code> 函数, 当被装饰的函数定义好了, 则将被装饰的函数作为参数传入装饰器函数 <code>timer</code> 并执行, 即 <code>timer(add)</code>。</p></li><li><p>定义 <code>wrapper2</code> 函数并返回其引用。将其引用作为参数继续向上传递给 <code>@deco</code> 装饰器，即执行 <code>deco</code> 函数 <code>deco(wrapper2)</code>。</p></li><li><p>定义 <code>wrapper1</code> 函数并返回其引用。因此被装饰后的函数 <code>add</code> 实际上已经是 <code>wrapper1</code> 函数的引用。</p></li><li><p>所以最后执行 <code>add(3, 4, 5)</code> 时，其实等价于 <code>wrapper1(3, 4, 5)</code>，而执行 <code>wrapper1(3, 4, 5)</code> 时，其中的参数 <code>func</code> 调用了 <code>deco</code> 的参数 <code>func</code>，即 <code>wrapper2</code>。</p></li><li><p><code>wrapper2</code> 函数中的 <code>func</code> 调用了 <code>timer</code> 的参数 <code>func</code>，即 <code>add</code>。</p></li><li><p>所以再调用 <code>add</code> 得到结果，<code>add</code> 运算的结果返回给 <code>wrapper2</code> 函数中的变量 <code>res</code>，<code>wrapper2</code> 中的 <code>res</code> 再返回给 <code>wrapper1</code> 中的 <code>res</code>，再最后返回。</p></li></ul></li></ul></li></ul><h3 id="2-7-内置装饰器">2.7 内置装饰器</h3><h4 id="2-7-1-staticmethod-定义类静态方法">2.7.1 @staticmethod 定义类静态方法</h4><ul><li><p><code>@staticmethod</code> 装饰器用于定义类中的静态方法，实现函数功能与实例的解绑。静态方法不需要创建类的实例，可以通过类名直接引用。</p></li><li><p>静态方法不会隐式传入参数，不需要传入 <code>self</code>，类似一个普通函数，只是可以通过类对象或实例对象来调用。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a static method!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test.static_method()  <span class="comment"># 类对象调用</span></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.static_method()  <span class="comment"># 实例对象调用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-7-2-classmethod-定义类静态方法">2.7.2 @classmethod 定义类静态方法</h4><ul><li><p><code>@classmethod</code> 装饰器用于定义类方法，类方法和类的静态方法非常相似，只是类方法会隐式传入一个类参数。类方法被哪个类调用，就传入哪个类作为第一个参数。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a class method!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ptest</span>(<span class="title class_ inherited__">Test</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test.class_method()  <span class="comment"># 类对象调用</span></span><br><span class="line">Ptest.class_method()  <span class="comment"># 子类对象调用</span></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.class_method()  <span class="comment"># 实例对象调用</span></span><br><span class="line">pt = Ptest()</span><br><span class="line">pt.class_method()  <span class="comment"># 子类实例对象调用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-7-3-property-实例方法属性化">2.7.3 @property 实例方法属性化</h4><h5 id="1-类对象-方法-参数">（1）类对象.方法(参数)</h5><ul><li><p>为了在不破坏类的封装性原则的基础上，能够有效操作类中的属性，类中应包含多个读（或写）类属性的 <code>getter</code>（或 <code>setter</code>）方法，这样就可以通过 <code>类对象.方法(参数)</code> 的方式操作属性，而不是直接使用 <code>类对象.属性</code> 的方式访问类中定义的属性。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line">        <span class="variable language_">self</span>.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">defname</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setage</span>(<span class="params">self, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.__age</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-property-方法">（2）property() 方法</h5><ul><li><p>类的内置方法 <code>property()</code> 可以将类中操作属性的实例方法属性化，让开发者依旧可以使用 <code>类对象.属性</code> 的方式操作类中的属性。</p><ul><li><p><code>property()</code> 函数的格式：<code>属性名 = property([fget[, fset[, fdel[, doc]]]])</code></p><ul><li><p><code>fget</code> 参数用于指定获取该属性值的实例方法。</p></li><li><p><code>fset</code> 参数用于指定设置该属性值的实例方法。</p><ul><li>如果不提供 <code>fset</code> 参数，则属性就变成只读的了。</li></ul></li><li><p><code>fdel</code> 参数用于指定删除该属性值的实例方法。</p></li><li><p><code>doc</code> 是一个文档字符串，用于说明此函数的作用。</p></li></ul></li><li><p>注：在使用 <code>property()</code> 函数时，<code>4</code> 个参数可以仅指定第 <code>1</code> 个、或前 <code>2</code> 个、或前 <code>3</code> 个，也可以全部指定。也就是说，<code>property()</code> 函数的参数并不是完全随意指定的。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delname</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line">    name = <span class="built_in">property</span>(fget=getname, fset=setname, fdel=delname, doc=<span class="string">&quot;name 属性的相关方法属性化&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="comment"># 获取说明文档 doc 的 2 种方式</span></span><br><span class="line"><span class="built_in">help</span>(Person.name)</span><br><span class="line"><span class="built_in">print</span>(Person.name.__doc__)</span><br><span class="line"><span class="comment"># 调用 getname() 方法</span></span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># dong</span></span><br><span class="line"><span class="comment"># 调用 setname() 方法</span></span><br><span class="line">person.name = <span class="string">&quot;xin&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># xin</span></span><br><span class="line"><span class="comment"># 调用 delname() 方法</span></span><br><span class="line"><span class="keyword">del</span> person.name</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   Help on property:</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#       name 属性的相关方法属性化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   name 属性的相关方法属性化</span></span><br><span class="line"><span class="comment">#   dong</span></span><br><span class="line"><span class="comment">#   xin</span></span><br></pre></td></tr></table></figure><ul><li>注：在此程序中，由于 <code>getname()</code> 方法中需要返回 <code>name</code> 属性，如果使用 <code>self.name</code> 的话，其本身又会调用 <code>getname()</code>，这将会陷入死循环。为了避免这种情况的出现，程序中的 <code>name</code> 属性必须设置为私有属性 <code>__name</code>。</li></ul></li></ul></li></ul><h5 id="3-property-装饰器">（3）@property 装饰器</h5><ul><li><p>既要保护类的封装特性，又要让开发者可以使用 <code>对象.属性</code> 的方式操作类属性，除了使用 <code>property()</code> 函数，<code>Python</code> 还提供了 <code>@property</code> 装饰器。</p></li><li><p>通过 <code>@property</code> 装饰器，可以直接通过 <strong>方法名</strong> 来访问方法，不需要在方法名后添加一对小括号 <code>()</code>。</p><ul><li><strong>注</strong>：方法名不是强制与属性相同，但是为了能够使用 <code>对象.属性</code> 的方式操作属性，<strong>建议方法名与属性名相同</strong>。</li></ul></li><li><p>如果类的某个实例对象属性是一个私有属性，且操作该属性的实例方法只有被 <code>@property</code> 装饰器修饰的方法，那么这个属性将是一个 <strong>只读属性</strong>。</p><ul><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># dong</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>要想实现 <strong>修改</strong> <code>name</code> 属性的值，还需要为 <code>name</code> 属性添加 <code>setter</code> 方法，并且将该方法使用 <code>setter</code> 装饰器进行装饰。</p><ul><li><p>语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@方法名.setter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self, value</span>):</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><ul><li>注：<code>@</code> <strong>后面的方法名要与被</strong> <code>@property</code> <strong>装饰器修饰的方法名称一致</strong>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;dong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># dong</span></span><br><span class="line">person.name = <span class="string">&quot;xin&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># xin</span></span><br></pre></td></tr></table></figure><ul><li><code>name</code> 属性拥有了 <code>getter</code> 和 <code>setter</code> 方法，该属性就变成了具有 <strong>读写功能</strong> 的属性。</li></ul></li></ul></li><li><p>如果我们要想 <strong>删除</strong> 实例对象的某个 <strong>私有属性</strong>，直接使用 <code>del</code> 关键字删除会抛出 <code>AttributeError</code> 异常，此时就可以使用 <code>deleter</code> 装饰器来装饰删除属性的方法。</p><ul><li><p>语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@方法名.deleter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self</span>):</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><ul><li>注：<code>@</code> <strong>后面的方法名要与被</strong> <code>@property</code> <strong>装饰器修饰的方法名称一致</strong>。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line">        <span class="variable language_">self</span>.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">&quot;dong&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># dong</span></span><br><span class="line">person.name = <span class="string">&quot;xin&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># xin</span></span><br><span class="line"><span class="keyword">del</span> person.name</span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;_Person__name&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 魔术方法</title>
      <link href="/posts/language/python/python3/python15.html"/>
      <url>/posts/language/python/python3/python15.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95">魔术方法</a><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-%E5%B8%B8%E7%94%A8%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95">2. 常用魔术方法</a><ul><li><a href="#21-__new__">2.1 __new__</a></li><li><a href="#22-__init__">2.2 __init__</a></li><li><a href="#23-__call__">2.3 __call__</a></li><li><a href="#24-__getitem__">2.4 __getitem__</a></li><li><a href="#25-__len__">2.5 __len__</a></li><li><a href="#26-__str__">2.6 __str__</a></li><li><a href="#27-__repr__">2.7 __repr__</a></li><li><a href="#28-__add____radd__">2.8 __add__/__radd__</a></li><li><a href="#29-__sub____rsub__">2.9 __sub__/__rsub__</a></li><li><a href="#210-__mul____rmul__">2.10 __mul__/__rmul__</a></li><li><a href="#211-__truediv____rtruediv__">2.11 __truediv__/__rtruediv__</a></li><li><a href="#212-__neg__">2.12 __neg__</a></li></ul></li></ul></li></ul><h2 id="魔术方法">魔术方法</h2><h3 id="1-概述">1. 概述</h3><ul><li><p>在 <code>Python</code> 中，魔术方法（<code>Magic Method</code>）是一种 <strong>官方定义好</strong>，以双下划线 <code>__</code> 包起来的 <strong>特殊方法</strong>。普通方法需要调用，而魔术方法在特定条件下可以 <strong>自动触发</strong>。</p></li><li><p>程序开发人员可以对魔术方法 <strong>重写</strong>，定制自己需要的功能。</p></li><li><p><code>Python</code> 中常用的运算符、for循环、以及类操作等都是运行在魔术方法之上的。</p></li></ul><h3 id="2-常用魔术方法">2. 常用魔术方法</h3><h4 id="2-1-new">2.1 __new__</h4><ul><li><p>格式：<code>__new__(cls, [...])</code>，是在一个对象实例化的时候所调用的第一个方法，用于实例化对象。它的第一个参数是当前类，其他的参数是用来直接传递给 <code>__init__</code> 方法。</p></li><li><p>触发条件：实例化对象时自动触发，即 <code>instance = MyClass(arg1, arg2)</code>。</p></li><li><p>返回值：实例对象。</p></li></ul><h4 id="2-2-init">2.2 __init__</h4><ul><li><p>格式：<code>__init__(self, [...])</code>，此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。</p></li><li><p>触发条件：实例化对象后，初始化对象时自动触发，即 <code>instance = MyClass(arg1, arg2)</code>。</p></li><li><p>返回值：无。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__ 方法被调用&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test()  <span class="comment"># __init__ 方法被调用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-call">2.3 __call__</h4><ul><li><p>格式：<code>__call__(self, [...])</code>，该方法允许一个类的实例像函数一样被调用。</p></li><li><p>触发条件：把对象当作函数调用的时候自动触发，即 <code>self(args)</code>。</p></li><li><p>返回值：根据需求决定。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__call__ 方法被调用, arg1: <span class="subst">&#123;arg1&#125;</span>, arg2: <span class="subst">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test()</span><br><span class="line"><span class="comment"># isinstance 和 issubclass 是判定类中是否重写了 __call__ 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(test, <span class="type">Callable</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Test, <span class="type">Callable</span>))  <span class="comment"># True</span></span><br><span class="line">test(<span class="number">10</span>, <span class="number">20</span>)  <span class="comment"># __call__ 方法被调用, arg1: 10, arg2: 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">int</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">float</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">complex</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">bool</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">str</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">tuple</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">set</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">range</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-getitem">2.4 __getitem__</h4><ul><li><p>格式：<code>__getitem__(self, item)</code>，该方法返回索引或键 <code>item</code> 对应的值。</p></li><li><p>触发条件：使用索引或键访问元素时自动触发，即 <code>self[item]</code>。</p></li><li><p>返回值：<code>item</code> 对应的元素值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        <span class="variable language_">self</span>.iterable = iterable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.iterable[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(test[<span class="number">2</span>])  <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># python 中 [start:stop:step] 形式都会调用 slice 类，返回一个 slice 对象</span></span><br><span class="line"><span class="built_in">print</span>(test[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># [6, 7]</span></span><br><span class="line">test = Test(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;dong&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(test[<span class="string">&quot;name&quot;</span>])  <span class="comment"># dong</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">str</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">tuple</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">range</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-5-len">2.5 __len__</h4><ul><li><p>格式：<code>__len__(self)</code>，该方法用于检测实例对象的长度。</p></li><li><p>触发条件：使用 <code>len(self)</code> 时自动触发。</p></li><li><p>返回值：必须是整数类型。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        <span class="variable language_">self</span>.iterable = iterable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.iterable])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(test))  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">str</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">tuple</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">set</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">range</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-6-str">2.6 __str__</h4><ul><li><p>格式：<code>__str__(self)</code>，该方法用于将实例对象以字符串形式显示。</p></li><li><p>触发条件：打印实例对象名，格式化字符串或 <code>str(self)</code> 时自动触发。</p></li><li><p>返回值：必须是字符串类型。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>, 年龄：<span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test(<span class="string">&quot;dong&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(test)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(test))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;test&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">int</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">float</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">complex</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">bool</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">str</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">tuple</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">set</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__str__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">range</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-7-repr">2.7 __repr__</h4><ul><li><p>格式：<code>__repr__(self)</code>，该方法用于将实例对象以字符串形式显示。</p></li><li><p>触发条件：使用 <code>repr(self)</code> 时自动触发。</p></li><li><p>返回值：必须是字符串类型。</p></li></ul><h4 id="2-8-add-radd">2.8 __add__/__radd__</h4><ul><li><p>格式：<code>__add__(self, other)</code>，实现了实例对象的加法操作。<code>__radd__(self, other)</code> ，实现了实例对象的反加法操作。大多数情况下，反运算的结果是与普通运算相同的。</p></li><li><p>触发条件：当加法运算符 <code>+</code> 左侧是当前类的实例对象时自动触发 <code>__add__</code>。当加法运算符 <code>+</code> 左侧不是当前类的实例对象且右侧是的时候自动触发 <code>__radd__</code></p></li><li><p>返回值：加法运算后的值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="variable language_">self</span>.num = num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__add__ 方法被调用&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.num + other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__radd__ 方法被调用&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.num + other</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># __add__ 方法被调用</span></span><br><span class="line"><span class="comment"># 17</span></span><br><span class="line"><span class="built_in">print</span>(test + <span class="number">7</span>)</span><br><span class="line"><span class="comment"># __radd__ 方法被调用</span></span><br><span class="line"><span class="comment"># 17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span> + test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">int</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">float</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">complex</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">bool</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">str</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__add__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">tuple</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-9-sub-rsub">2.9 __sub__/__rsub__</h4><ul><li>实例对象进行减法操作时会调用该方法，格式、触发条件、返回值与加法类似。</li></ul><h4 id="2-10-mul-rmul">2.10 __mul__/__rmul__</h4><ul><li>实例对象进行乘法操作时会调用该方法，格式、触发条件、返回值与加法类似。</li></ul><h4 id="2-11-truediv-rtruediv">2.11 __truediv__/__rtruediv__</h4><ul><li>实例对象进行除法操作时会调用该方法，格式、触发条件、返回值与加法类似。</li></ul><h4 id="2-12-neg">2.12 __neg__</h4><ul><li><p>格式：<code>__neg__(self)</code>，实现了实例对象的相反数操作。</p></li><li><p>触发条件：当 <code>-self</code> 时自动触发 <code>__neg__</code>。</p></li><li><p>返回值：相反数运算后的值。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="variable language_">self</span>.num = num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__neg__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> -<span class="variable language_">self</span>.num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(-test)  <span class="comment"># -10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__neg__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">int</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__neg__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">float</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__neg__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">complex</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__neg__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">bool</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 错误和异常</title>
      <link href="/posts/language/python/python3/python1.html"/>
      <url>/posts/language/python/python3/python1.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-语法错误">一、语法错误</h2><ul><li><p><code>Python</code> 的 <strong>语法错误</strong> 又称解析错误，也就是 <strong>解析代码时</strong> 出现的错误。当代码不符合 <code>Python</code> 语法规则时，<code>Python</code> 解释器在解析时就会报出 <code>SyntaxError</code> 语法错误，与此同时还会明确指出最早探测到错误的语句。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E:\Environment\Anaconda3\python.exe E:\PythonFiles\error.py </span><br><span class="line">  File <span class="string">&quot;E:\PythonFiles\error.py&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><ul><li><p><code>Python</code> 解析器会打印出存在语法错误的代码行，并用小“箭头”指向行内检测到的第一个错误。</p></li><li><p>本例中，在 <code>print()</code> 函数前检测到错误，是因为在它前面缺少了一个冒号（<code>:</code>）。</p></li><li><p><strong>错误信息</strong> 还会输出错误所在的文件名与行号，让我们知道去哪里排查错误。</p></li></ul></li><li><p><code>PyCharm</code> 是一款功能强大的 <code>Python</code> 集成开发环境（<code>IDE</code>），它内置了语法检查功能，能够帮助我们及时发现和修复代码中的语法错误。在 <code>PyCharm</code> 中，如果代码存在语法错误，它会立即在代码行下方显示一个红色的波浪线并显示错误信息。</p></li><li><p>常见语法错误：</p><ul><li><p><code>SyntaxError: invalid syntax</code>（无效语法），造成这种错误的原因通常是遗漏了标点符号、关键字拼写错误或遗漏、变量名或函数名使用了关键字等。</p></li><li><p><code>SyntaxError: invalid character in identifier</code>（标识符中有无效字符），造成这种错误的原因通常是代码中出现了无法识别的字符，检查一下是否有多余字符或中文字符。</p></li><li><p><code>SyntaxError: EOL while scanning string literal</code>（检查到不完整的字符串），造成这种错误的原因通常是遗漏了字符串两边的引号，或两边的引号不统一。</p></li></ul></li></ul><h2 id="二-异常">二、异常</h2><h3 id="2-1-什么是异常？">2.1 什么是异常？</h3><ul><li><p>即使 <code>Python</code> 程序在语法上都是正确的，但是在 <strong>运行时</strong> 仍可能发生错误，这种在 <strong>运行时</strong> 产生的错误被称之为 <strong>异常</strong>（<code>Exceptions</code>）。</p></li><li><p><code>Python</code> 集成开发环境（<code>IDE</code>）的语法检查功能不会发现异常。</p></li><li><p>大多数的异常都不会被程序处理，如果程序在运行时出现了异常，默认情况下，程序终止并打印错误信息。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E:\Environment\Anaconda3\python.exe E:\PythonFiles\error.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:\PythonFiles\error.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span> / <span class="number">0</span>)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><ul><li><p>错误信息的最后一行说明程序遇到了什么类型的错误（异常）。</p></li><li><p>异常有不同的类型，这些类型都会作为错误信息的一部分打印出来，上述示例打印出的错误类型为 <code>ZeroDivisionError</code>。</p></li><li><p>作为异常类型打印的字符串是内置异常的名称。</p></li></ul></li></ul><h3 id="2-2-内置异常">2.2 内置异常</h3><ul><li><p>在 <code>Python</code> 中，所有异常类型都继承自 <code>Exception</code> 类，<code>Exception</code> 类又继承自 <code>BaseException</code> 类。<code>Python</code> 中有许多内置的异常类来表示某种具体异常。</p></li><li><p>内置异常类型定义在 <code>builtins</code> 模块中，使用 <code>dir(builtins)</code> 可以查看。内置异常名称通常使用 <code>Error</code> 结尾。</p></li><li><p>常见内置异常类型：</p><ul><li><p><code>TypeError</code>：类型异常，在对不同类型数据之间进行非法操作时引发此异常。</p></li><li><p><code>ZeroDivisionError</code>：除零异常，除法运算中除数为 <code>0</code> 时引发此异常。</p></li><li><p><code>KeyError</code>：键异常，访问字典中不存在的键时引发此异常。</p></li><li><p><code>ValueError</code>：值异常，当传入无效参数时引发此异常。</p></li><li><p><code>IndexError</code>：索引异常，索引超出序列范围时引发此异常。</p></li><li><p><code>AttributeError</code>：属性异常，访问的对象属性不存在时引发此异常。</p></li><li><p><code>NameError</code>：名称异常，访问一个未声明的变量时引发此异常。</p></li><li><p><code>RecursionError</code>：递归异常，当递归深度超过 <code>1000</code> 时引发此异常。</p></li></ul></li></ul><h3 id="2-3-异常处理">2.3 异常处理</h3><ul><li><p>如果不想要程序在出现异常时终止运行，可以使用捕获异常的方式捕获这个异常，然后对异常进行处理，处理后让程序继续运行，这种捕获异常并处理的方式叫作异常处理。</p></li><li><p>异常处理可以使用 <code>try except</code> 相关语句。</p></li></ul><h4 id="2-3-1-try-except-语句">2.3.1 try except 语句</h4><h5 id="1-语法结构">（1）语法结构</h5><ul><li><p><code>Python</code> 中，捕获并处理异常可以使用 <code>try except</code> 语句，语法结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能产生异常的代码块</span><br><span class="line"><span class="keyword">except</span> [(Error1, Error2, ...) [<span class="keyword">as</span> e]]:</span><br><span class="line">    处理异常的代码块 <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> [(Error3, Error4, ...) [<span class="keyword">as</span> e]]:</span><br><span class="line">    处理异常的代码块 <span class="number">2</span></span><br><span class="line"><span class="keyword">except</span> [Exception]:</span><br><span class="line">    处理其它异常</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>try</code> 子句将可能产生异常的代码块包裹，以便后续捕获异常。</p></li><li><p><strong>一个</strong> <code>try except</code> 语句可以包含 <strong>多个</strong> <code>except</code> 子句，用来处理不同类型的异常。</p></li><li><p>多个 <code>except</code> 子句 <strong>最多只有一个</strong> 会被 <strong>执行</strong>。</p></li><li><p><code>Error1</code>、<code>Error2</code>、<code>Error3</code> 和 <code>Error4</code> 表示异常类型的名称，<strong>一个</strong> <code>except</code> 子句可以处理 <strong>多个</strong> 异常，多个异常类型必须放在 <strong>元组</strong> 中。</p></li><li><p><code>[as e]</code> 可选，用于将捕获到的异常对象 <strong>赋值</strong> 给 <code>e</code>（<code>e</code> 可以自定义，符合标识符规定即可），方便在 <code>except</code> 中使用。</p><ul><li><code>e</code> 相当于异常类型的实例对象，我们可以通过 <code>e</code> 使用这个异常类型的的所有属性和方法。</li></ul></li><li><p><code>[Exception]</code> 可选，表示可以忽略异常的名称，通常用在最后一个 <code>except</code> 块。</p></li></ul></li><li><p>示例：</p><pre><code class="language-python">def func(x, y):    try:        print(x / y)    except TypeError:        print(&quot;类型异常&quot;)    except ZeroDivisionError:        print(&quot;除零异常&quot;)    except:        print(&quot;end&quot;)        func(&quot;1&quot;, &quot;a&quot;)  # 类型异常func(2, 0)  # 除零异常func(9, 3)  # 3.0</code></pre></li></ul><h5 id="2-执行流程">（2）执行流程</h5><ul><li><p><code>try except</code> 语句的执行流程：</p><ul><li><p>首先，执行 <code>try</code> 子句。</p><ul><li><p>如果没有异常发生，忽略 <code>except</code> 子句，<code>try</code> 子句执行后结束。</p></li><li><p>如果发生异常，系统会自动生成一个异常类型，引发异常的代码行之后的语句会被跳过。</p></li></ul></li><li><p>发生了异常，将系统生成的异常类型与 <code>except</code> 子句中指定的异常类型进行比对。</p><ul><li><p>如果系统生成的异常类型和某个 <code>except</code> 字句中指定的异常类型 <strong>相匹配</strong>，那么异常就被成功 <strong>捕获</strong>，对应的 <code>except</code> 子句开始 <strong>处理异常</strong>。</p></li><li><p>如果这个异常类型没有与任何的 <code>except</code> 子句匹配，则程序终止运行。</p></li></ul></li></ul></li></ul><h5 id="3-嵌套">（3）嵌套</h5><ul><li><p>在 <code>Python</code> 中，<code>try except</code> 异常处理语句也可以嵌套。当内层 <code>try except</code> 出现异常，且指定的异常类型与系统生成的异常类型 <strong>不匹配</strong> 时，<strong>向外层</strong> <code>try except</code> <strong>传递</strong>。如果与外层指定的异常类型 <strong>相匹配</strong>，则异常 <strong>被处理</strong>，否则继续向外传递，<strong>直至最外层</strong>，如果系统生成的异常类型与所有指定的异常类型 <strong>都不匹配</strong>，则 <strong>程序终止</strong>。</p><ul><li>注：<code>except</code> 子句（嵌套的 <code>try except</code>）中触发的异常，<strong>不能</strong> 被同级其他的 <code>except</code> 子句捕获，因为多个 <code>except</code> 子句 <strong>最多只有一个</strong> 会被 <strong>执行</strong>。</li></ul></li><li><p>示例：</p><pre><code class="language-python">try:    print(&quot;第 1 层 try&quot;)    try:        print(&quot;第 2 层 try&quot;)        print(&quot;dong&quot;[7])    except IndexError:        print(&quot;第 2 层 except&quot;)        try:            print(&quot;第 3 层 try&quot;)            print(&quot;2&quot; + 1)        except TypeError:            print(&quot;第 3 层 except&quot;)            print(2 / 0)    except ZeroDivisionError:        print(&quot;第 2 层 except 异常: ZeroDivisionError&quot;)except ZeroDivisionError:    print(&quot;第 1 层 except 异常: ZeroDivisionError&quot;)# 输出：#   第 1 层 try#   第 2 层 try#   第 2 层 except#   第 3 层 try#   第 3 层 except#   第 1 层 except 异常: ZeroDivisionError- **疑惑**：为什么第 `3` 层 `except TypeError` 中 `print(2 / 0)` 触发的 `ZeroDivisionError` 异常，**没有** 被 **第** `2` **层** 的 `except ZeroDivisionError` 捕获，反而被 **第** `1` **层** 的 `except ZeroDivisionError` **捕获** 到了？- **解惑**：`print(2 / 0)` 触发异常 `ZeroDivisionError`，它所在的位置是第 `2` 层 `except IndexError` 中的嵌套 `try except` 语句中，根据 **多个** `except` **子句最多只有一个会被执行的原则**，同层级（第 `2` 层）的 `except ZeroDivisionError` 不会被执行，所以异常向外传递到第 `1` 层，被第 `1` 层的 `except ZeroDivisionError` 捕获。</code></pre></li></ul><h5 id="4-获取异常的相关信息">（4）获取异常的相关信息</h5><ul><li><p>在 <code>Python</code> 中，每种异常类型都提供了下列属性和方法，方便我们获取当前异常类型的相关信息。</p><ul><li><p><code>e.args</code>：返回一个元组类型，其中的元素是该异常的参数。</p></li><li><p><code>str(e)</code>：返回异常信息，但不包括异常信息的类型。</p></li><li><p><code>repr(e)</code>：返回较全的异常信息，包括异常信息的类型。</p></li></ul></li><li><p>示例：</p><pre><code class="language-python">def func(x, y):    try:        print(x / y)    except (TypeError, NameError, ZeroDivisionError) as e:        print(e)  # division by zero        print(e.args)  # ('division by zero',)        print(type(e))  # &lt;class 'ZeroDivisionError'&gt;        print(str(e))  # division by zero        print(repr(e))  # ZeroDivisionError('division by zero')func(2, 0)</code></pre></li></ul><h4 id="2-3-2-try-except-else-语句">2.3.2 try except else 语句</h4><ul><li><p><code>try except</code> 语句之后可以紧跟一个 <code>else</code> 子句，这个 <code>else</code> 子句必须放在所有的 <code>except</code> 子句之后，并且 <code>else</code> 子句仅会在 <code>try</code> 子句 <strong>没有</strong> 发生任何 <strong>异常</strong> 时被 <strong>执行</strong>。</p><ul><li>注：<code>else</code> 子句中触发的异常，不能被同级其他的 <code>except</code> 子句捕获。</li></ul></li><li><p>语法结构：</p><pre><code class="language-python">try:    可能产生异常的代码块except [(Error1, Error2, ...) [as e]]:    处理异常的代码块 1except [(Error3, Error4, ...) [as e]]:    处理异常的代码块 2except [Exception]:    处理其它异常else:    没有异常时执行的代码块</code></pre></li><li><p>示例：</p><pre><code class="language-python">def func(x, y):    try:        print(x / y)    except TypeError:        print(&quot;类型异常&quot;)    except ZeroDivisionError:        print(&quot;除零异常&quot;)    except:        print(&quot;end&quot;)    else:        print(&quot;无异常&quot;)  func(&quot;1&quot;, &quot;a&quot;)  # 类型异常  func(2, 0)  # 除零异常  # 输出：#   # 3.0#   无异常  func(9, 3)  # 此次调用不触发异常，else 子句可以被执行</code></pre></li></ul><h4 id="2-3-3-try-finally-语句">2.3.3 try finally 语句</h4><ul><li><p><code>try</code> 子句后可以紧跟一个 <code>finally</code> 子句（可以没有 <code>except</code> 子句）。无论 <code>try</code> 子句中是否发生异常，最终都会进入 <code>finally</code> 子句，并执行其中的代码块。</p></li><li><p>基于 <code>finally</code> 子句的这种特性，在某些情况下，当 <code>try</code> 子句中的程序打开了一些物理资源（例：文件、数据库连接等）时，由于这些资源必须手动关闭，通常这些关闭资源的工作就放在 <code>finally</code> 子句中。</p></li><li><p>当 <code>try</code> 子句和 <code>finally</code> 子句中都包含 <code>return</code> 语句时，只有 <code>finally</code> 子句中的 <code>return</code> 被返回。</p></li><li><p><code>finally</code> 子句只要求和 <code>try</code> 子句搭配使用，而 <code>try</code> 子句后是否包含 <code>except</code> 子句和 <code>else</code> 子句，对于 <code>finally</code> 不是必须的（<code>else</code> 子句必须搭配 <code>try except</code> 语句使用）。</p><ul><li>如果 <code>try</code> 子句后包含 <code>except</code> 子句和 <code>else</code> 子句，<code>finally</code> 子句必须放到整个语法结构的 <strong>末尾</strong>。</li></ul></li><li><p>示例：</p><pre><code class="language-python">def func(x, y):    try:        x / y    except ZeroDivisionError:        print(&quot;除零异常&quot;)    except:        print(&quot;end&quot;)    else:        print(&quot;else 子句只有不发生异常，才会执行&quot;)    finally:        print(&quot;finally 子句无论是否异常，都会执行&quot;)print(&quot;2 / 0&quot;)func(2, 0)print(&quot;2 / 2&quot;)func(2, 2)# 输出：  #   2 / 0  #   除零异常  #   finally 子句无论是否异常，都会执行  #   2 / 2  #   else 子句只有不发生异常，才会执行  #   finally 子句无论是否异常，都会执行</code></pre></li></ul><h3 id="2-4-抛出异常">2.4 抛出异常</h3><ul><li><p><code>Python</code> 允许我们使用 <code>raise</code> 语句抛出一个指定的异常，以及异常信息的相关描述。</p></li><li><p><code>raise</code> 语句的语法格式：<code>raise [Exception]</code>。</p><ul><li><p><code>Exception</code>：异常类型，它必须是一个异常类的 <strong>实例对象</strong> 或异常 <strong>类本身</strong>（<code>Exception</code> 的子类）。</p></li><li><p><code>args</code>：异常的描述信息。</p></li></ul></li><li><p><code>raise</code> 语句的用法：</p><ul><li><p><code>raise</code>：单独一个 <code>raise</code> 关键字，可选参数全部省略，<code>raise</code> 会把当前错误原样抛出。默认抛出 <code>RuntimeError</code> 异常。例：</p><pre><code class="language-python">def func(x, y):    try:        try:            x / y        except ZeroDivisionError:            raise  # 将 ZeroDivisionError 原样抛出    except ZeroDivisionError as z:        print(z)func(2, 0)  # division by zero</code></pre></li><li><p><code>raise Exception</code>：<code>raise</code> 后带一个异常类的 <strong>实例对象</strong> 或异常 <strong>类本身</strong>，表示抛出该类型的异常。</p><ul><li><p><code>raise</code> 异常类本身时，没有异常的描述信息，仅有触发的异常类型。</p></li><li><p><code>raise</code> 异常类的实例对象时，可以初始化异常类的基本属性，例：异常信息。</p></li><li><p>示例：</p><pre><code class="language-python">def func(x, y):    try:        if y == 0:            raise ZeroDivisionError(f&quot;&#123;x&#125; / &#123;y&#125;，除数不能为 0&quot;)  # 抛出异常类的实例对象        elif not x.isdigit():            raise ValueError  # 抛出异常类本身    except ZeroDivisionError as z:        print(repr(z))    except ValueError as v:        print(repr(v))func(2, 0)  # ZeroDivisionError('2 / 0，除数不能为 0')func(&quot;a&quot;, 10)  # ValueError()</code></pre></li></ul></li></ul></li></ul><h3 id="2-5-自定义异常">2.5 自定义异常</h3><ul><li><p><code>Python</code> 中内置了大量的异常类，虽然这些异常类可以描述编程时出现的绝大部分情况，但仍难以涵盖所有可能出现的异常。<code>Python</code> 允许程序开发人员自定义异常。</p></li><li><p>自定义异常的方法很简单，只需创建一个类，让它 <strong>继承</strong> <code>Exception</code> 类或其它异常类即可。</p></li><li><p>自定义异常类与普通类一样，也可以具有自己的它属性和方法，但一般情况下不添加或者只为其添加几个用于描述异常的详细信息的属性即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 面向对象编程（下）</title>
      <link href="/posts/language/python/python3/python13.html"/>
      <url>/posts/language/python/python3/python13.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-封装">一、封装</h2><ul><li><p>封装，即 <strong>隐藏对象的属性和方法</strong>，这样在使用此类时，将无法直接以 “<code>实例对象.属性名</code>”（或 “<code>实例对象.方法名(参数)</code>”）的形式调用这些属性（或方法），而只能使用未隐藏的类方法间接操作这些隐藏的属性和方法。</p></li><li><p><code>Python</code> 类中的变量或方法，只存在 <strong>公有</strong>（<code>public</code>）和 <strong>私有</strong>（<code>private</code>）两种访问权限，这 <code>2</code> 种权限的区别如下：</p><ul><li><p><code>public</code>：公有权限的变量或方法，在 <strong>类的外部</strong>、<strong>类的内部</strong> 和 <strong>子类</strong> 中，都可以正常访问。</p></li><li><p><code>private</code>：私有权限的变量或方法，只能在 <strong>本类内部</strong> 使用，类的外部以及子类都无法使用。</p></li></ul></li><li><p><code>Python</code> 并没有提供 <code>public</code>、<code>private</code> 这些权限修饰符。为了实现类的封装，<code>Python</code> 采取了下面的方法：</p><ul><li><p>默认情况下，<code>Python</code> 类中的变量或方法都是公有（<code>public</code>）的，它们的名称前都没有下划线（<code>__</code>）。</p></li><li><p>如果类中的变量或方法，其名称以 <strong>双下划线</strong> “<code>__</code>” 开头，则该变量（方法）为 <strong>私有变量</strong>（<strong>私有方法</strong>），“<code>__</code>” 等同于 <code>private</code>。</p></li></ul></li><li><p><strong>封装原理</strong>：<code>Python</code> 封装仅仅是一种 <strong>变形操作</strong>，即将类中所有双下划线开头的属性名或方法名（例：<code>Test</code> 类中 <code>__age</code>、<code>__info(self)</code>），<strong>自动变形</strong> 成：<code>_类名__属性名</code> 或 <code>_类名__方法名</code> 的形式（例：<code>_Test__age</code>、<code>_Test__info(self)</code>）。</p><ul><li>这种机制并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名 / 方法名就可以拼出名字：<code>_类名__属性名</code> / <code>_类名__方法名</code>，然后进行访问了。</li></ul></li><li><p><strong>不建议</strong> 使用类名和属性名 / 方法名拼出名字去直接使用使用属性 / 方法，<strong>建议</strong> 提供一个公有方法在类的外部 <strong>间接访问</strong> 私有属性 / 方法。</p></li><li><p>以 <strong>单下划线</strong> “<code>_</code>” 开头的变量或方法（例：<code>_age</code>、<code>_info(self)</code>）通常也被视为私有变量或私有方法，但这 <strong>仅仅只是一个约定</strong>，<code>Python</code> 解析器并不会真的阻止用户去访问这个变量或方法，即以 “<code>_</code>” 开头的变量或方法也能通过实例对象正常访问。</p></li><li><p>使用 <code>from  模块名 import 私有变量/方法/类</code> 的方式可以导入私有变量 / 方法 /类（<code>_</code>或<code>__</code>开头均可）并使用。但是 <code>from  模块名 import *</code> 的方式不会将私有类型导入。</p></li></ul><h2 id="二-继承">二、继承</h2><h3 id="2-1-继承机制">2.1 继承机制</h3><h4 id="2-1-1-概述">2.1.1 概述</h4><ul><li><p>继承经常用于创建和现有类功能相似的 <strong>新类</strong>，又或是新类只需要在 <strong>现有类</strong> 基础上 <strong>添加</strong> 一些成员（属性 / 方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用，节省代码。</p></li><li><p>继承的最大 <strong>意义</strong> 就是子类可以使用父类的所有公有属性与公有方法。从 <strong>子类</strong> 角度，继承 <strong>节省代码</strong>；从 <strong>父类</strong> 角度，继承可以 <strong>扩展功能</strong>。</p></li><li><p><code>Python</code> 中，实现继承的类称为 <strong>子类</strong>（派生类），被继承的类称为 <strong>父类</strong>（基类、超类）。</p></li><li><p>当子类的属性或方法不存在时，<code>Python</code> 解释器会自动去它的父类中查找。</p><ul><li><p>当调用父类的实例方法时，传入的 <code>self</code> 是子类的实例对象。</p></li><li><p>当调用父类的类方法时，传入的 <code>cls</code> 是子类本身。</p></li></ul></li><li><p><strong>派生</strong> 和继承是一个意思，只是观察角度不同：</p><ul><li><p>继承是相对于子类来说的，即子类继承自父类。</p></li><li><p>派生是相对于父类来说的，即父类派生出子类。</p></li></ul></li></ul><h4 id="2-1-2-语法">2.1.2 语法</h4><ul><li><p>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号内即可。<strong>语法格式</strong> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>, 父类<span class="number">2</span>, ...):</span><br><span class="line">    <span class="comment"># 类定义部分</span></span><br></pre></td></tr></table></figure></li><li><p><strong>子类定义</strong> 一定要写在父类定义的后面，否则抛出异常 <code>NameError: name '***' is not defined</code>。</p></li><li><p>如果一个类没有显式指定继承自哪个类，则 <strong>默认继承</strong> <code>object</code> <strong>类</strong>（<code>object</code> 类是 <code>Python</code> 中所有类的父类），可以省略类名后的括号。</p></li></ul><h4 id="2-1-3-多重继承">2.1.3 多重继承</h4><ul><li><p><code>Python</code> 的继承是 <strong>多重继承</strong> 机制，即一个子类可以同时拥有多个直接父类。</p></li><li><p>使用多继承经常需要面临的问题：多个父类中包含 <strong>同名</strong> 的方法/属性。对于这种情况，<code>Python</code> 的处置措施：根据子类继承多个父类时这些父类的 <strong>前后次序</strong> 决定，即排在 <strong>前面</strong> 父类中的方法/属性会 <strong>覆盖</strong> 排在 <strong>后面</strong> 父类中的同名方法/属性。</p></li><li><p><code>Python</code> 中，类的 <code>__mro__</code> 属性展示了 <strong>方法解析顺序</strong>（<code>MRO</code>：<code>Method Resolution Order</code>），可以使用类对象调用 <code>mro()</code> 方法或直接引用 <code>__mro__</code> 属性得到解析顺序，方法解析顺序是按照类的层次结构寻找的，类的层次结构也就是类的继承关系。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Grandfather</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Grandfather&quot;</span>)</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Father1</span>(<span class="title class_ inherited__">Grandfather</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">    Grandfather.p_class(<span class="variable language_">self</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Father1&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Father2</span>(<span class="title class_ inherited__">Grandfather</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">    Grandfather.p_class(<span class="variable language_">self</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Father2&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Son</span>(Father1, Father2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">    Father1.p_class(<span class="variable language_">self</span>)</span><br><span class="line">    Father2.p_class(<span class="variable language_">self</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Son&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(Son.mro())  <span class="comment"># [&lt;class &#x27;__main__.Son&#x27;&gt;, &lt;class &#x27;__main__.Father1&#x27;&gt;, &lt;class &#x27;__main__.Father2&#x27;&gt;, &lt;class &#x27;__main__.Grandfather&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">  <span class="built_in">print</span>(Son.__mro__)  <span class="comment"># (&lt;class &#x27;__main__.Son&#x27;&gt;, &lt;class &#x27;__main__.Father1&#x27;&gt;, &lt;class &#x27;__main__.Father2&#x27;&gt;, &lt;class &#x27;__main__.Grandfather&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line">- 如果在子类中定义初始化方法，则必须在该方法中调用父类的初始化方法，调用方式有 `<span class="number">2</span>` 种：</span><br><span class="line"></span><br><span class="line">  - 类可以看做一个独立空间，在类的外部调用其中的实例方法，可以像调用普通函数那样，只不过需要额外备注类名。例：`Bird.__init__(<span class="variable language_">self</span>)`，其中 `Bird` 为父类，`<span class="variable language_">self</span>` 为子类对象，调用的是父类 `Bird` 中的初始化方法；</span><br><span class="line">  </span><br><span class="line">  - 使用 `<span class="built_in">super</span>()` 函数。但如果涉及多继承，该函数只能调用第一个直接父类的初始化方法。例：`<span class="built_in">super</span>().__init__(<span class="variable language_">self</span>)`。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.2 C3 线性化算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.2.1 概述</span></span><br><span class="line"></span><br><span class="line">- 在计算机科学中，`C3` 算法主要用在 **多重继承** 中，确定子类应该继承哪一个父类的方法。换句话说，`C3` 超类线性化算法的输出是确定性的 **方法解析次序**（`MRO`：`Method Resolution Order`）。</span><br><span class="line"></span><br><span class="line">- 在 `Python2<span class="number">.3</span>` 之前用于处理 `MRO` 的算法存在违背本地优先级原则、违背单调性原则等问题，从 `Python2<span class="number">.3</span>` 起使用 `C3` 算法来处理 `MRO`。</span><br><span class="line"></span><br><span class="line">- `C3` 算法实现了 **三种重要特性**：</span><br><span class="line"></span><br><span class="line">  - 保持继承 **拓扑图** 的一致性（`C3` 算法是 **基于拓扑排序** 的思想来解决问题的，`C3` 算法在类的继承关系图中加入了同级别类之间的 **先后顺序**，即括号中从左至右）。</span><br><span class="line"></span><br><span class="line">  - 保证 **局部优先** 原则（又称：本地优先级，例：`A` 继承 `C`，`C` 继承 `B`，那么 `A` 读取父类方法，应该优先使用 `C` 的方法而不是 `B` 的方法）。</span><br><span class="line"></span><br><span class="line">  - 保证 **单调性** 原则（即子类不改变父类的方法搜索顺序，例：如果在父类 `C` 的解析顺序中，`A` 排在 `B` 的前面，那么在 `C` 的所有 **子类** 解析顺序中，也必须满足这个顺序）。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.2.2 算法</span></span><br><span class="line"></span><br><span class="line">- 一个类的 `C3` 超类线性化，是这个类自身的线性化加上它的所有父类的线性化和这些父类自身组成的列表 `merge` 后的总和。</span><br><span class="line"></span><br><span class="line">  - 对于类定义 `<span class="keyword">class</span> <span class="title class_">P</span>(F1, F2, ..., FN)`，将它的 `MRO` 记为 `L[P]`，`L` 代表 `linearization`（线性化）。</span><br><span class="line">  </span><br><span class="line">  - `Python` 中的任意类都会继承 `<span class="built_in">object</span>`，所以 `L[O] = [O]`。</span><br><span class="line">  </span><br><span class="line">  - `C3` 算法：`L[P] = [P] + merge(L[F1], L[F2], ..., L[FN], [F1, F2, ..., FN])`，其中 `P` 表示子类，`F` 表示 `P` 的直接父类。</span><br><span class="line">  </span><br><span class="line">    - `merge` 方法中的最后一个参数 `[F1, F2, ..., FN]`，定义了同级别类之间的先后顺序。</span><br><span class="line">  </span><br><span class="line">    - `merge` 方法的计算步骤：</span><br><span class="line"></span><br><span class="line">      - 选取第一个列表 `F1` 的第一个元素。</span><br><span class="line"></span><br><span class="line">      - 如果该元素在其他序列中也是 **第一个元素**，或在其他序列 **不出现**，则从所有执行 `merge` 操作的序列中 **删除** 这个元素，**合并** 到当前的 `mro` 中。</span><br><span class="line"></span><br><span class="line">      - 如果该元素 **不满足条件**，则执行 **下一个序列** 的第一个元素。</span><br><span class="line"></span><br><span class="line">      - `merge` 操作后的序列，**递归** 执行 `merge` 操作，直到 `merge` 操作的序列为空。</span><br><span class="line"></span><br><span class="line">        - **注**：如果 `merge` 操作的序列无法为空，则说明序列不合规。</span><br><span class="line"></span><br><span class="line">- 如果一个多重继承的关系图中 **加入先后顺序** 之后，形成了 **环路** 或 **逆序**，对应 `C3` 算法就是 `merge` 操作的序列无法为空，即不能再找出可以输出的元素，`Python` 会抛出异常 `TypeError: Cannot create a consistent method resolution order (MRO) <span class="keyword">for</span> bases *, *`。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.2.3 示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### （1）实现类 Z 的多重继承</span></span><br><span class="line"></span><br><span class="line">- 多重继承实现代码</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  O = <span class="built_in">object</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">E</span>(<span class="title class_ inherited__">O</span>): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">K1</span>(A, B, C): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">K2</span>(D, B, E): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">K3</span>(D, A): <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Z</span>(K1, K2, K3): <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># [&lt;class &#x27;__main__.Z&#x27;&gt;, &lt;class &#x27;__main__.K1&#x27;&gt;, &lt;class &#x27;__main__.K2&#x27;&gt;, </span></span><br><span class="line">  <span class="comment">#  &lt;class &#x27;__main__.K3&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, </span></span><br><span class="line">  <span class="comment">#  &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.E&#x27;&gt;, </span></span><br><span class="line">  <span class="comment">#  &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">  <span class="built_in">print</span>(Z.mro())</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （2）类 Z 的线性化计算</span></span><br><span class="line"></span><br><span class="line">- 计算使用 `C3` 线性化算法得到的类 `Z` 的 `MRO`</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  L(O) := [O] // <span class="built_in">object</span></span><br><span class="line">  L(A) := [A] + merge(L(O), [O]) // A 的线性化是 A 加上它的父类的线性化与父类列表的归并</span><br><span class="line">        = [A] + merge([O], [O])</span><br><span class="line">        = [A, O]  // 其结果是简单的将 A 前置于它的单一父类的线性化</span><br><span class="line">  L(B) := [B, O]  // B、C、D、E 的线性化的计算类似于 A</span><br><span class="line">  L(C) := [C, O]</span><br><span class="line">  L(D) := [D, O]</span><br><span class="line">  L(E) := [E, O]</span><br><span class="line">  </span><br><span class="line">  L(K1) := [K1] + merge(L(A), L(B), L(C), [A, B, C])</span><br><span class="line">          // 执行 merge 操作的序列为 [A, O], [B, O], [C, O], [A, B, C]</span><br><span class="line">          // A 是序列 [A, O] 中的第一个元素，在序列 [B, O]、[C, O] 中都不出现，在序列 [A, B, C] 中也是第一个元素，</span><br><span class="line">          // 所以从执行 merge 操作的序列 ([A, O], [B, O], [C, O], [A, B, C]) 中删除 A，合并到当前 MRO：[K1] 中。</span><br><span class="line">          = [K1] + merge([A, O], [B, O], [C, O], [A, B, C])</span><br><span class="line">          // 再次执行 merge 操作，序列为 [O], [B, O], [C, O], [B, C]</span><br><span class="line">          // O 是序列 [O] 中的第一个元素，但 O 在序列 [B, O] 中出现并且不是其中第一个元素。</span><br><span class="line">          // 继续查看 [B, O] 的第一个元素 B，B 满足条件，所以从执行 merge 操作的序列中删除 B，合并到 [K1, A] 中。</span><br><span class="line">          = [K1, A] + merge([O], [B, O], [C, O], [B, C])</span><br><span class="line">          // 同理，我们找到元素 C，并从执行 merge 操作的序列中删除 C，合并到 [K1, A, B] 中。</span><br><span class="line">          = [K1, A, B] + merge([O], [O], [C, O], [C])</span><br><span class="line">          // 最后，所有的序列中只剩下 O，O 也满足条件，将 O 合并到 [K1, A, B, C] 中</span><br><span class="line">          = [K1, A, B, C] + merge([O], [O], [O])</span><br><span class="line">          // 此时，merge 操作的序列为空，得到了 K1 的 MRO：[K1, A, B, C, O]</span><br><span class="line">          = [K1, A, B, C, O]</span><br><span class="line">  </span><br><span class="line">  // 与计算 K1 的 MRO 同理，最后得到 [K2, D, B, E, O]</span><br><span class="line">  L(K2) := [K2] + merge(L(D), L(B), L(E), [D, B, E])</span><br><span class="line">          = [K2] + merge([D, O], [B, O], [E, O], [D, B, E])  // 选择 D</span><br><span class="line">          = [K2, D] + merge([O], [B, O], [E, O], [B, E])  // 不选 O，选择 B</span><br><span class="line">          = [K2, D, B] + merge([O], [O], [E, O], [E])  // 不选 O，选择 E</span><br><span class="line">          = [K2, D, B, E] + merge([O], [O], [O])  // 选择 O </span><br><span class="line">          = [K2, D, B, E, O]</span><br><span class="line">  </span><br><span class="line">  // 与计算 K1 的 MRO 同理，最后得到 [K3, D, A, O]</span><br><span class="line">  L(K3) := [K3] + merge(L(D), L(A), [D, A])</span><br><span class="line">          = [K3] + merge([D, O], [A, O], [D, A])  // 选择 D</span><br><span class="line">          = [K3, D] + merge([O], [A, O], [A])  // 不选 O，选择 E</span><br><span class="line">          = [K3, D, A] + merge([O], [O])  // 选择 O</span><br><span class="line">          = [K3, D, A, O]</span><br><span class="line">  </span><br><span class="line">  // 与计算 K1 的 MRO 同理，最后得到 [Z, K1, K2, K3, D, A, B, C, E, O]</span><br><span class="line">  L(Z)  := [Z] + merge(L(K1), L(K2), L(K3), [K1, K2, K3])</span><br><span class="line">          = [Z] + merge([K1, A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K1, K2, K3])  // 选择 K1</span><br><span class="line">          = [Z, K1] + merge([A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K2, K3])  // 不选 A，选择 K2</span><br><span class="line">          = [Z, K1, K2] + merge([A, B, C, O], [D, B, E, O], [K3, D, A, O], [K3])  // 不选 A，不选 D，选择 K3</span><br><span class="line">          = [Z, K1, K2, K3] + merge([A, B, C, O], [D, B, E, O], [D, A, O])  // 不选 A，选择 D</span><br><span class="line">          = [Z, K1, K2, K3, D] + merge([A, B, C, O], [B, E, O], [A, O])  // 选择 A</span><br><span class="line">          = [Z, K1, K2, K3, D, A] + merge([B, C, O], [B, E, O], [O])  // 选择 B</span><br><span class="line">          = [Z, K1, K2, K3, D, A, B] + merge([C, O], [E, O], [O])  // 选择 C</span><br><span class="line">          = [Z, K1, K2, K3, D, A, B, C] + merge([O], [E, O], [O])  // 不选 O，选择 E</span><br><span class="line">          = [Z, K1, K2, K3, D, A, B, C, E] + merge([O], [O], [O])  // 选择 O</span><br><span class="line">          = [Z, K1, K2, K3, D, A, B, C, E, O]  // 完成</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-类-z-继承关系图的拓扑排序">（3）类 Z 继承关系图的拓扑排序</h5><ul><li><p>（<code>1</code>）代码中的继承关系如下图（左），加入先后顺序后如下图（右）。计算 <code>MRO</code> 相当于对右图做 <strong>拓扑排序</strong>。</p><div align=center>  <img src="https://cdn.jsdelivr.net/gh/fandong93/PictureBed/Python/13/01.png" width="579"/></div><ul><li><p>对于右图，我们使用拓扑排序进行排序：</p><ul><li><p>首先找到图中入度为 <code>0</code> 的点，只有 <code>Z</code>，选择 <code>Z</code>，将 <code>Z</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>K1</code> 点，选择 <code>K1</code> 点，将 <code>K1</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>K2</code> 点，选择 <code>K2</code> 点，将 <code>K2</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>K3</code> 点，选择 <code>K3</code> 点，将 <code>K3</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>D</code> 点，选择 <code>D</code> 点，将 <code>D</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>A</code> 点，选择 <code>A</code> 点，将 <code>A</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>B</code> 点，选择 <code>B</code> 点，将 <code>B</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，有 <code>C</code> 点和 <code>E</code> 点，按照 <strong>最左原则</strong>，选择 <code>C</code> 点，将 <code>C</code> 点和它的边删除。</p></li><li><p>再找入度为 <code>0</code> 的点，只有 <code>E</code> 点，选择 <code>E</code> 点，将 <code>E</code> 点和它的边删除。</p></li><li><p>最后选择 <code>O</code> 点，<code>object</code>。</p></li></ul></li><li><p>所以最后的排序是 <code>[Z, K1, K2, K3, D, A, B, C, E, O]</code>。</p></li></ul></li></ul><h3 id="2-3-方法重写">2.3 方法重写</h3><h4 id="2-3-1-概述">2.3.1 概述</h4><ul><li><p><code>Python</code> 子类可以继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的 <strong>修改</strong>，或者父类方法的功能不能满足需求，这时就需要采用方法的重写。<strong>方法重写又称方法覆盖</strong>。</p></li><li><p>方法的重写是指两个方法的 <strong>返回值</strong>、<strong>方法名</strong>、<strong>参数</strong> 的类型和个数相同。</p></li><li><p>方法的重写，不能发生在同类中，只能发生在 <strong>子类</strong> 中。</p></li></ul><h4 id="2-2-2-调用父类中被重写方法">2.2.2 调用父类中被重写方法</h4><h5 id="1-父类名-被重写方法">（1）父类名.被重写方法</h5><ul><li><p><code>Python</code> 中的类可以看做是一个 <strong>独立空间</strong>，而类方法就是处于该空间中的一个函数。如果想要全局命名空间中，调用类空间中的函数，只需要在调用该函数时 <strong>备注类名</strong> 即可。</p></li><li><p><code>父类名.被重写方法</code> 这种方式适用于 <strong>单继承</strong>。</p></li><li><p>示例：<code>Bird.fly(ostrich)</code>，其中 <code>Bird</code> 为父类，手动为 <code>self</code> 参数赋值子类对象 <code>ostrich</code>，调用的是父类 <code>Bird</code> 中的 <code>fly</code> 方法。</p></li><li><p>在 <strong>多继承</strong> 时，使用 <code>父类名.被重写方法</code> 这种方式会发生同一个类的某个方法被 <strong>多次调用</strong> 的情况。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Grandfather</span>:</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Grandfather&quot;</span>)</span><br><span class="line">          </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Father1</span>(<span class="title class_ inherited__">Grandfather</span>):</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">      Grandfather.p_class(<span class="variable language_">self</span>)</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Father1&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Father2</span>(<span class="title class_ inherited__">Grandfather</span>):</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">          Grandfather.p_class(<span class="variable language_">self</span>)</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Father2&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Son</span>(Father1, Father2):</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">p_class</span>(<span class="params">self</span>):</span><br><span class="line">          Father1.p_class(<span class="variable language_">self</span>)</span><br><span class="line">          Father2.p_class(<span class="variable language_">self</span>)</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Son&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  s = Son()</span><br><span class="line">  s.p_class()</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出：</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">#   Grandfather</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#   </span></span><br><span class="line">  <span class="comment"># Father1</span></span><br><span class="line">  <span class="comment">#   Grandfather</span></span><br><span class="line">  <span class="comment">#   Father2</span></span><br><span class="line">  <span class="comment">#   Son</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - 我们发现 `Grandfather` 类的 `p_class` 被调用两次。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### （2）super 类</span></span><br><span class="line"></span><br><span class="line">- 可以使用 `<span class="built_in">super</span>()` 函数解决多继承多次调用这个问题。在一个类中调用 `<span class="built_in">super</span>()` 函数可以获取 **当前类** 在 `MRO` **列表** 中的 **下一个类**，`MRO` 列表中不会出现多次相同的类。</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">super</span>()` 函数的 **工作原理**：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">super</span>(<span class="params">type1, type2</span>):</span><br><span class="line">      mro = type2.__class__.mro()  <span class="comment"># 获取 MRO 列表</span></span><br><span class="line">      <span class="keyword">return</span> mro[mro.index(type1) + <span class="number">1</span>]  <span class="comment"># 返回类 type1 下一个类</span></span><br></pre></td></tr></table></figure><ul><li>我们通过 <code>type2</code> 获取 <code>MRO</code> 列表，然后在这个列表中查找 <code>type1</code> 类，返回类 <code>type1</code> 后面一个类的信息。</li></ul></li><li><p><code>super</code> 其实本身就是一个 <strong>类</strong> <code>class super(object)</code>，<code>super()</code> 就是在对这个类进行 <strong>实例化</strong>，调用类的 <strong>初始化方法</strong> <code>__init__(self, type1=None, type2=None)</code>。</p><ul><li><p><code>__init__</code> 方法可以接收两个参数：要求 <code>type1</code> 是一个 <strong>类</strong>，<code>type2</code> 可以是一个 <strong>类</strong> 或 <strong>实例对象</strong>。</p><ul><li><code>type2</code> 提供 <code>MRO</code> 列表，<code>type1</code> 提供 <code>MRO</code> 搜索的起点。</li></ul></li><li><p><code>super</code> 类的实例化后返回一个 <strong>超类对象</strong>（<code>super object</code>），它的格式为 <code>&lt;super: &lt;class '*'&gt;, &lt;* object&gt;&gt;</code>，它是一个动态对象，它会根据调用顺序和方法解析顺序（<code>MRO</code>）动态计算。</p><ul><li><code>&lt;class '*'&gt;</code> 中的 <code>*</code> 表示 <code>super</code> 所在方法的类</li></ul></li></ul></li><li><p>根据参数的 <strong>数量</strong> 和 <strong>类型</strong>，<code>super()</code> 可以有以下 <code>4</code> 种情况：</p><ul><li><p><strong>无参形式</strong> <code>super()</code>：</p><ul><li><p>无参形式的 <code>super()</code> 函数等价于 <code>super(__class__, &lt;first argument&gt;)</code>，本质上是一个二参形式。</p><ul><li><p><code>__class__</code> 代表调用 <code>super()</code> 函数的方法所在类。</p><ul><li><code>__class__</code> 出现在类的内部定义方法之外就是 <code>not defined</code> 的状态，所以也说明无参的 <code>super()</code> 只能出现在类的内部定义方法之内。</li></ul></li><li><p><code>&lt;first argument&gt;</code> 是指调用 <code>super()</code> 函数的方法的第一个参数。</p><ul><li><p>类方法中就是 <code>cls</code>，实例方法中就是 <code>self</code>。</p></li><li><p>类方法第一个参数一定是类本身 <code>cls</code>，那么调用 <code>super()</code> 就相当于调用 <code>super(__class__, cls)</code>。因此在类方法中使用 <code>super()</code>，就相当于调用父类中的类方法。</p></li></ul></li></ul></li><li><p>调用 <code>super()</code> 时用到 <code>&lt;first argument&gt;</code> 的 <code>MRO</code> 列表，在这个列表中查找 <code>__class__</code> 类，返回该类后面一个类的实例对象。</p></li></ul></li><li><p><strong>二参形式</strong> <code>super(type1, obj)</code>：</p><ul><li><p>这种形式要求两个参数 <code>type</code> 类对象和 <code>obj</code> 实例对象必须符合 <code>isinstance(obj, type)==True</code>，即 <code>obj</code> 必须是 <code>type</code> 的 <strong>实例对象</strong>。</p><ul><li>子类的实例对象也是父类的实例对象，即 <code>isinstance</code> 返回 <code>True</code>。</li></ul></li><li><p>调用 <code>super(type1, obj)</code> 时用到 <code>obj</code> 的 <code>MRO</code> 列表，从指定type的下一个类开始查找，<br>看看是否有指定的方法，如果有，就将obj当作调用方法的第一个自变量。</p></li></ul></li><li><p><strong>二参形式</strong> <code>super(type1, type2)</code>：</p><ul><li><p>这种形式要求两个参数 <code>type1</code> <strong>类对象</strong> 和 <code>type2</code> <strong>类对象</strong> 必须符合 <code>issubclass(type2, type1)==True</code>，即 <code>type2</code> 必须是 <code>type1</code> 的 <strong>子类</strong>。</p><ul><li>当 <code>type1 == type2</code> 时，<code>issubclass</code> 返回 <code>True</code>，表示调用自己父类中的类方法。</li></ul></li></ul></li></ul></li><li><p><code>super()</code> 函数和父类并没有直接关联，<code>super</code> 获取到的也可能不是父类。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">          <span class="built_in">super</span>().func()</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;A func&quot;</span>)</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;B func&quot;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;C func&quot;</span>)</span><br><span class="line">            <span class="built_in">super</span>().func()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 输出：</span></span><br><span class="line">  <span class="comment">#   C func</span></span><br><span class="line">  <span class="comment">#   B func</span></span><br><span class="line">  <span class="comment">#   A func</span></span><br><span class="line">  C().func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  - 我们会发现类 `A` 和类 `B` 没有继承关系，可是类 `A` 中的 `<span class="built_in">super</span>()` 却调用了类 `B` 中的 `func` 方法。这是因为类 `C` 的 `MRO` 列表为：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    [&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;]</span><br><span class="line"></span><br><span class="line">- 类 `C` 中的 `<span class="built_in">super</span>()` 等价于 `<span class="built_in">super</span>(C, C())`，获取到类 `C` 在 `MRO` 列表中的下一个类 `A`，因此 `<span class="built_in">super</span>().func()` 等价于 `A().func()`。</span><br><span class="line"></span><br><span class="line">- 类 `A` 中的 `<span class="built_in">super</span>()` 等价于 `<span class="built_in">super</span>(A, A())`，获取到类 `A` 在 `MRO` 列表中的下一个类 `B`，因此 `<span class="built_in">super</span>().func()` 等价于 `B().func()`。</span><br><span class="line"></span><br><span class="line">  - 这里也就解释清楚了类 `A` 和类 `B` 没有继承关系，可是类 `A` 中的 `<span class="built_in">super</span>()` 却调用了类 `B` 中的 `func` 方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.4 继承的 \_\_init\_\_</span></span><br><span class="line"></span><br><span class="line">- 如果子类 **未重写** `__init__` 方法，那么子类 **继承** 父类的 `__init__` 方法，实例化子类时，会 **自动调用** 父类中定义的 `__init__` 方法。</span><br><span class="line"></span><br><span class="line">  - 当子类继承多个父类时，只有第一个父类中的 `__init__` 方法会被调用。</span><br><span class="line"></span><br><span class="line">- 如果子类 **重写** 了 `__init__` 方法，实例化子类时，就 **不会调用** 父类中已经定义的 `__init__` 方法。</span><br><span class="line"></span><br><span class="line">  - 如果想要在子类中调用父类中的 `__init__` 方法，需要 **显式调用**，有两种方式：</span><br><span class="line">  </span><br><span class="line">    - `父类名.__init__(<span class="variable language_">self</span>, 参数列表)`</span><br><span class="line"></span><br><span class="line">    - **推荐**：`<span class="built_in">super</span>(子类, <span class="variable language_">self</span>).__init__(参数列表)` 或 `<span class="built_in">super</span>().__init__(参数列表)`</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.5 继承相关的内置函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.5.1 isinstance</span></span><br><span class="line"></span><br><span class="line">- 格式：`<span class="built_in">isinstance</span>(<span class="built_in">object</span>, classinfo)`，用于判断一个 `<span class="built_in">object</span>` 实例对象是否是给定的 `classinfo` 或其 **子类** 的实例对象，如果是则返回 `<span class="literal">True</span>`，反之返回 `<span class="literal">False</span>`。`classinfo` 可以是类，也可以是由类组成的元组。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.5.2 issubclass</span></span><br><span class="line"></span><br><span class="line">- 格式：`<span class="built_in">issubclass</span>(<span class="keyword">class</span>, classinfo)`，用于判断一个类 `<span class="keyword">class</span>` 是否是给定的 `classinfo` 的子类。`classinfo` 可以是类，也可以是由类组成的元组。</span><br><span class="line"></span><br><span class="line">- 判断规则：</span><br><span class="line"></span><br><span class="line">  - 一个类是自己的子类。</span><br><span class="line">  </span><br><span class="line">  - 一个类直接或间接继承自另一个类，都被认为是子类。</span><br><span class="line">  </span><br><span class="line">  - `classinfo` 可以是一个元组，`<span class="keyword">class</span>` 是其中一个类的子类（满足前两条），函数就返回 `<span class="literal">True</span>`。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 三、多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 3.1 概述</span></span><br><span class="line"></span><br><span class="line">- 多态是指一类事物有多种形态，例：动物类，可以有猫，狗等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</span><br><span class="line"></span><br><span class="line">- **类的多态特性**，需要满足以下 `<span class="number">2</span>` 个 **前提条件**：</span><br><span class="line"></span><br><span class="line">  - 继承：多态一定是发生在子类和父类之间。</span><br><span class="line"></span><br><span class="line">  - 重写：子类重写了父类的方法。</span><br><span class="line">  </span><br><span class="line">- 当子类和父类都存在 **相同** 的方法时，子类的方法 **覆盖** 了父类的方法。</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">shout</span>(<span class="params">self</span>):</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;动物怎么叫？&quot;</span>)</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">shout</span>(<span class="params">self</span>):</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;狗叫汪汪~&quot;</span>)</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">shout</span>(<span class="params">self</span>):</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;猫叫喵喵~&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  a = Animal()</span><br><span class="line">  a.shout() <span class="comment"># 动物怎么叫？</span></span><br><span class="line">  </span><br><span class="line">  a = Dog()</span><br><span class="line">  a.shout() <span class="comment"># 狗叫汪汪~</span></span><br><span class="line">  </span><br><span class="line">  a = Cat()</span><br><span class="line">  a.shout() <span class="comment"># 猫叫喵喵~</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-鸭子模型-duck-typing">3.2 鸭子模型 duck typing</h3><ul><li><p>鸭子类型（<code>duck typing</code>）在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定，而是由当前方法和属性的集合决定。这个概念的名字来源于由 <code>James Whitcomb Riley</code> 提出的鸭子测试：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;duck quack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>: <span class="comment"># Bird 类与 Duck 类无继承关系</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bird quack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="comment"># Dog类与 Duck 类无继承关系</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dog quack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_quack</span>(<span class="params">animal</span>): <span class="comment"># animal_quack 方法可以调用任何对象的 quack() 方法，不关心对象是谁</span></span><br><span class="line">    animal.quack()</span><br><span class="line"></span><br><span class="line">duck = Duck()</span><br><span class="line">bird = Bird() <span class="comment"># bird 实例与 duck 实例无任何关系</span></span><br><span class="line">dog = Dog() <span class="comment"># dog 实例与 duck 实例无任何关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> [duck, bird, dog]:</span><br><span class="line">    animal_quack(animal)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    输出：</span></span><br><span class="line"><span class="string">      duck quack</span></span><br><span class="line"><span class="string">      bird quack</span></span><br><span class="line"><span class="string">      dog quack</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 递归函数</title>
      <link href="/posts/language/python/python3/python11.html"/>
      <url>/posts/language/python/python3/python11.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
